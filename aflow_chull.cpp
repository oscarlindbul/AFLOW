// ***************************************************************************
// *                                                                         *
// *           Aflow STEFANO CURTAROLO - Duke University 2003-2021           *
// *           Aflow COREY OSES - Duke University 2013-2021                  *
// *                                                                         *
// ***************************************************************************
// Written by Corey Oses
// corey.oses@duke.edu
// Previous versions also written by Eric Perim and Eric Gossett

#ifndef _AFLOW_CHULL_CPP_
#define _AFLOW_CHULL_CPP_

#include "aflow.h"
#include "aflow_chull.h"
#include "aflow_compare_structure.h"
#include "aflow_chull_jupyter.cpp"  //MB20190301 - jupyter notebook stuff
#include "aflow_chull_jupyter_plotter.cpp"  //MB20190305
#include "aflow_chull_jupyter_requirements.cpp"  //MB20190305
#include "aflow_chull_python.cpp"  //MB20190305

#define _DEBUG_CHULL_ false  //CO20190116

#define _AFLOW_CHULL_PRINT_LOGO_1 TRUE
#define _AFLOW_CHULL_PRINT_LOGO_2 FALSE

// DEFINITIONS
const std::string AFLOW_WEB = string("http://" + AFLOWLIB_MATERIALS_SERVER);
const std::string NOMAD_WEB = string("http://www.nomad-coe.eu/");
const std::string ENTRY_PAGE_URL_PREFIX = string(AFLOW_WEB + "/material/?id=");  //"/material.php?id="
const std::string AFLOW_HULL_ENDPOINT_STRING = "aflow_hull_endpoint";
const std::string LATEX_DEFAULT_COLORS = "blue,green,red,brown,cyan,lime,magenta,olive,orange,pink,purple,teal,violet,darkgray,gray,lightgray,black,white,yellow"; //putting favorites near beginning, not so good ones in the back
const std::string LATEX_DVIPS_COLORS = "Apricot,Aquamarine,Bittersweet,Black,Blue,BlueGreen,BlueViolet,BrickRed,Brown,BurntOrange,CadetBlue,CarnationPink,Cerulean,CornflowerBlue,Cyan,Dandelion,DarkOrchid,Emerald,ForestGreen,Fuchsia,Goldenrod,Gray,GreenGreen,Yellow,JungleGreen,Lavender,LimeGreen,Magenta,Mahogany,Maroon,Melon,MidnightBlue,Mulberry,NavyBlue,OliveGreen,Orange,OrangeRed,Orchid,Peach,Periwinkle,PineGreen,Plum,ProcessBlue,Purple,RawSienna,Red,RedOrange,RedViolet,Rhodamine,RoyalBlue,RoyalPurple,RubineRed,Salmon,SeaGreen,Sepia,SkyBlue,SpringGreen,Tan,TealBlue,Thistle,Turquoise,Violet,VioletRed,White,WildStrawberry,Yellow,YellowGreen,YellowOrange";  //contains defaults and more
const std::string LATEX_COLORS_TO_AVOID = "black,white,yellow,darkgray,gray,lightgray";

// USAGE FLAGS
//[CO20180819 - MOVED TO AFLOWRC]const bool IGNORE_BAD_DATABASE = true;        //skip bad entries
const bool CORRECT_BAD_DATABASE = true;                                        //make minor corrections, carried over from apennsy (SC)
const bool PRINT_DIST2HULL_COL_TEX = false;                                    //print Dist2hull column in tex, there's no need because it's not used for anything in the image
const bool GET_DECOMPOSITION_POLYMORPHS = true;                                //print decomposition information for polymorphs

// LATEX PRINTING MODES
const char ADDPLOT_MODE_HULL_POINTS = 'P';
const char ADDPLOT_MODE_OFF_HULL_POINTS = 'O';
const char ADDPLOT_MODE_HULL_FACETS = 'F';
const char ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS = 'D';
const char ADDPLOT_MODE_HEAT_MAPS = 'H';

// AFLOW LOGO
const std::string _AFLOW_LOGO_FULL_BASE64_ = "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IABnAGUAbgDoAHIAaQBjAEMepQB1ACAAaADsAG4AaAAgAFIARwBCACAAQwBoAHUAbgBnAFAAZQByAGYAaQBsACAAUgBHAEIAIABHAGUAbgDpAHIAaQBjAG8EFwQwBDMEMAQ7BEwEPQQ4BDkAIAQ/BEAEPgREBDAEOQQ7ACAAUgBHAEIAUAByAG8AZgBpAGwAIABnAOkAbgDpAHIAaQBxAHUAZQAgAFIAVgBCAMEAbAB0AGEAbADhAG4AbwBzACAAUgBHAEIAIABwAHIAbwBmAGkAbJAadSgAIABSAEcAQgAggnJfaWPPj/AARwBlAG4AZQByAGkAcwBrACAAUgBHAEIALQBwAHIAbwBmAGkAbABPAGIAZQBjAG4A/QAgAFIARwBCACAAcAByAG8AZgBpAGwF5AXoBdUF5AXZBdwAIABSAEcAQgAgBdsF3AXcBdkAUAByAG8AZgBpAGwAbwAgAFIARwBCACAAZwBlAG4AZQByAGkAYwBvAFAAcgBvAGYAaQBsACAAUgBHAEIAIABnAGUAbgBlAHIAaQBjAEEAbABsAGcAZQBtAGUAaQBuAGUAcwAgAFIARwBCAC0AUAByAG8AZgBpAGzHfLwYACAAUgBHAEIAINUEuFzTDMd8Zm6QGgAgAFIARwBCACBjz4/wZYdO9k4AgiwAIABSAEcAQgAgMNcw7TDVMKEwpDDrA5MDtQO9A7kDugPMACADwAPBA78DxgOvA7sAIABSAEcAQgBQAGUAcgBmAGkAbAAgAFIARwBCACAAZwBlAG4A6QByAGkAYwBvAEEAbABnAGUAbQBlAGUAbgAgAFIARwBCAC0AcAByAG8AZgBpAGUAbA5CDhsOIw5EDh8OJQ5MACAAUgBHAEIAIA4XDjEOSA4nDkQOGwBHAGUAbgBlAGwAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGkAWQBsAGUAaQBuAGUAbgAgAFIARwBCAC0AcAByAG8AZgBpAGkAbABpAEcAZQBuAGUAcgBpAQ0AawBpACAAUgBHAEIAIABwAHIAbwBmAGkAbABVAG4AaQB3AGUAcgBzAGEAbABuAHkAIABwAHIAbwBmAGkAbAAgAFIARwBCBB4EMQRJBDgEOQAgBD8EQAQ+BEQEOAQ7BEwAIABSAEcAQgZFBkQGQQAgBioGOQYxBkoGQQAgAFIARwBCACAGJwZEBjkGJwZFAEcAZQBuAGUAcgBpAGMAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGV0ZXh0AAAAAENvcHlyaWdodCAyMDA3IEFwcGxlIEluYy4sIGFsbCByaWdodHMgcmVzZXJ2ZWQuAFhZWiAAAAAAAADzUgABAAAAARbPWFlaIAAAAAAAAHRNAAA97gAAA9BYWVogAAAAAAAAWnUAAKxzAAAXNFhZWiAAAAAAAAAoGgAAFZ8AALg2Y3VydgAAAAAAAAABAc0AAHNmMzIAAAAAAAEMQgAABd7///MmAAAHkgAA/ZH///ui///9owAAA9wAAMBs/8AAEQgCEwSWAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAgICAgICAwICAwUDAwMFBgUFBQUGCAYGBgYGCAoICAgICAgKCgoKCgoKCgwMDAwMDA4ODg4ODw8PDw8PDw8PD//bAEMBAgICBAQEBwQEBxALCQsQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEP/dAAQASv/aAAwDAQACEQMRAD8A/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAZyDTgc0EZpvSgrcfRQOaKCQoooo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UhgWNlCqDKPvDKAbckEetfDLwRP8PPB/hbwJ4n1q81u5sLK3tF1OW4uI/tMkEYVtyeawjZmAKLk/LhSSyktq4xUVJPXsLW53Pw28B6T8MPCll4H0Waa4tLIO6SXDBpGMjl3ztCqPmbgAAc+uSdLxh478F/D7TYtY8c63Z6DYzSrAk17MkEbSsCQoZyBnAJPoASeATWhc6XYwRi5dWmEB3ETSPKNv8XDs3Qc/UCvL/jT8Bvhb8cPDNr4c+JGkG+0+wuo7pBDNLaOrD5Hy8DI2xkZgyk4xz1AIlNOV5g9tD2tWV1DKQQRkEdCKWobe3gtLeK1toxFDCqoiKMKqqMAAegFTVkMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//1f38ooooAKKKKACiiigAooooAKKKKACmE0pNNoKSCiiigoKKKKACiiigAooooAK8N/aD+G2sfFnwEvgzQvEsvha7nu4pRcxRNNvRAwaNo1kiLDDb8BxyoPOK6P4h6T4u8U2NrZ+CNUOlvaXIknmDvGJVVWBiVkBY4JBP8ORtJzkDpIHuDe2AmH2hjE829SNzbAsanBwAG8xmx2PHatYNxalF6iavoZXhnwlP4S8PafoOn3pxaQRQyXMsSGWeVECGaQJt+eQrliS3Xp3G+E1vT8+VDb3gbq+54X4/vDExbHrn2ArWa5j2lJonGeCNhcYP+7uFVrTULV5zYrcJLIAWTDhiVHXPfK9/Xg+uIu+oykusamAQ2jzTsDgtbywPH9AZXibPqCgr5z0H9obw/wDEn466x8CbfSb+zl8JQjUb2WWIlZWhaIRxMqZaMb5VkUnIkCcfKTn6K1fV9KtZzZLdwx6oyZjjMirIF5O9lzny1ALMSMYB70miwz6fYpJPCXaf95I4H73LktiRe5GcHHfPyiri0k7oTNCbVNPCMs04tmI484GLnsQH25x7VTfXtHmWGWG+gZwQ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ykKAEBS3JJGFYZFXvD3gS4Elrq3jO4TUb60wba2jBFjZYHHko2S8g7zSZc/w7QSKl92I5mCLU/EfijV7C0E2jaF4mtBc+Y8e26uJbcLbTSIrcwK0bW6guN5CkqqHD1S+D3gvwwra34sj0iCG8u9QubdTt3eWluFt5UXdnkzRyFj1Yk5JrkP2n/2mfAP7NqeF9X8YW91eXN/PcPFDaCPebaGMJcFmkdAADKjKv8bKOmCw9Y+DN1DeeANIv7dt0Wr20Orx8Y+XVB9qbOecmR3JrWUJKCk1o9hJpux6Sts8H/HrIQv9x/mX8D1H6geleE+Dfhd8Ifg/4r8eeO9M0iDQNQ8Qyx3+pXpllZWjfccLvdliDTCVikaoGLDgnGPoKuE8YaTpmrQX+l6rALm11TT5UljORn7MwaPaRgggyE5zwQDkYrGMugzSTxBBqWjtq2gt/aNo0TSLKgyHAB+VOm5sjGOMHIJBGKzPh5r8nifRJdYuLGWxneeRHEp3F9mMMrYXK4wOAACDXR6FoWneHdLttH0qEW9paKVijBLBQSSeWySSSSSTk1s05Na2EFFFFQMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//1P38ooooAKKKKACkJxQTimUFJBSgZoAzT6Bth0ooooICiiigAr4k0r9r7w141/aavP2XrXS72yuLZ7yF76OTDyS2URllVlADQRMqsFlDFmJXbsLA19t1zMvgzwnNrM/iM6PaprN1GsUl/HCsd40afdU3CAS4HYbuK1pzik7q/wCgmmN1Pwt4evrGx0a50+FrKCXMcWwbUIViCo7c8n175rWF4LQmHUXWPAJWViFRwOT7BgOo/EcZA526v9Z8Pzo+pRSatpyBj58Ee66i6DMkEY/eADPzRDdyB5eAXrP8Z+H9D+KfgabT7e9M9ld7ZoZ7ORWDvC25cH5lYblwR/IjIntcZ6A0qrjHzE8gDkn/AD61haRbNPDczXJ4muZyUHQ7JDGN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DjyJYafqNt/amohv3vmzyiN443x81w/mFpG6Rg/3iAParHQNF03R4fD9lZRR6dAgjSDaDHtHPIOc5PJJySeTzVTqRstNRJFTydH8E+FpF062S003RrV3SKMYVY4lLH8Tgkk8k8nmvI/DPh2TTPEHw30u8BEun6Jq17Ln/n8keySQ/ncS1nfE7xxYeHbqTwJpouLk3UKG7iZt0UdvI2GRGbLhnQEAZ2KCOOaktPHGseIPHkmpaDoMm230uGGO51BzaWii6mkZ3DFWkdW8lAuIxuweRwaiMJcvN0Hc9ZXSZbPxDf3miMtu80UEssLf6mZ2aUEnAJRzgfOo56srcYnu/EPh6ZW0nWdq3MgG6xkXzZmGeCsSBi655DKCPcEHHMwaLqOqa21t4l8R+dctAHlsdNb7GiKh+XcVZrgg7zz5ig/3ew7a08OaHp1v9n02yjswDu3QqEfd03FhyWPcknPfOTWbsB8k+JrH4w3nxktbbRGvBpEclpPYpNN/o8UAGXNwu8nLMkn38uV4HTA+k9YuPF8osLOfTrFhNdxHKXkgJ8jM/wB1rfA/1f8Aerx7xv8AHr4d/CXxtp1l8QL+SK88UXyafpzxQtIHjtgIcyBfu4ubhkyM5OTgAHHt89rqOtalYLqamztY/NnFujZkbaojHmyKcD/WfcQ445ZgcDapzWjdaGel2WV8Q6lO729ro88ksZ2u6yQNChHBG4yKWI7qBnscZBrmfHnjHw14R8LXOpeMLOe5hnK27QNAsvmtLwEAJ8rHcgt0HOT19KHk2saQxIFVQFREAHA4AA6AD8hWZrGgaV4k06XSvENpHfWk2N0Mg3JlTkH6g8g9R2rBNXAh8LeINM8U+H7LXtHVks7tCUV1Csu0lCpAyAVII4JHHBxXQVT0/TrHSbKHTdMgS2tbdQkccY2qqjsBVylK19AQUUUUgCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9b9/KKKKAEIzQBilooHcKKK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rI5ALEV3On+Ddb0LwxpWi6NLbWqeH4o0s4oo2kkKwx+XsM0jhS0iZVmaPqd2MirDxN4j+JEczc2PhSJgo6g392g3Eg9DHbsAjDr5si9jXpVckpGp4PqHhe2lt7bSVvpZNMv3+06W7ouyOeQEvbsqqmA24vHx8o3rgBQD1iaW/gvwmvh2zlJmu5DDFcL8u2S4Yl5NvO3y03P1IwhJINauq2duskmj3bmKzuna8R1OGheLMjspOcFZdsq9cktxtGK8m8F/G7SvHerWpj066kmt45PsscKq32mVsK0gDMoi2oGxvbAVmBYHra5pLTpqLQ9uv7W3FpZ+HLNAkE4EZVei2sQG8fRhiPrkb89q2rsWrWsy32z7MyMJPMxs2EYbdnjGOua8/wBPtvFmq3U+pxeRotu/7lI/+PiYIjHcQceXE5bOcCVSADjIyems9C0zzVnvBJfXcZ3b7tvMZWz95E/1afWNVHFZNDMvS9Y3XS6dbiTUXt43Ec4+5LCSu1zI2FYqflcqWORuxzivK9S+EMOr/Fv/AITi6viPOa3ee0CeYgMEe3aJCV+Qqqbl2dZOvPPu9/F+8ivFbbJbhyD0yDgspPoQv4HB7V5F8GfjR8OPjSNa1HwDqZ1BtInWC5DRvGUMwLow3AbkdV2qR1CdB0rSHMk5x/q5Ltsz3Cnimin1gEgooooJCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//0P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArDewn06V7vSBlHJaW1Jwjk8s0ZPCOepH3WPXBJetyigDPjuYdRtWe2JLIcFWG1kkXDBWB5B6cHtz0NTREec5X7syq49zjB/TbUNzYiWUXds/kXSjbvAyGUchXXjcvPHIIycEZNeY+HviTD4g8c6v4Em0ueyn0MZklb5klUlR8vA+QlwVP8SjJC9KuMb7Bc6zxXptjqthHqV7bxzpo00V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jbBlnPO0dcevt+NIEd+ZiP8AdHT8fX+XtWVxnkHiD4nwWPxH0T4cW9uLuTUkWWV8uGjRi45G3YOEJIZgSDwPXtfB/wAPfAvw/ivoPAvh+w8Px6ncNd3S2NvHbiad+DI4jA3NjjJ6DgcVfm8JeHLnxDB4sn0+J9Xt4/KjuSPnCc8ehxuOCRkZOK6QCqk1ZWJAClooqCQooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArB8TRanLod3/AGLEkuooha3DnAEnYg5HOM45Geh4Jreoppgcb4Yl8Rz6DZL42hii1FgRIY1BUncQuRllViuMgZGTxjoNK30yCKW6iMssYD+YgWQqqq4yflHycuGOCK32UMCrDIPBB718uWlt+0xb/tF6xdagljd/CAWCC0gjeEXjXG1MABgsm9ZDIW8yTyzHjb82ANIq99bCue26n4WtPElqbLUI4p9OLBvLmhBMjL0b92YyFGeO578cHzzwZp3xE8CazrDeKJorzwvNcP8AYYrcbjZRM5KBV2hvL2kAoSxBHynGAfarLVLG/Zo4JCJkGWidTHKo9SjAMAexxg9qvMqupRwGVhgg8gg1PO9gsNhliuIkngdZI5AGVlIKsDyCCOCDWLAvlw30K9LW5aRfU7ts5H4liKpm0uPD0zT6eplsJCWkhzyhJyWTPTPcdD14OSdXS5obl7y4gbekkwIPTpEgIIPIIIwQeQeDUjGXA3a7Y56LBcN+O6IfyJriV+Gnha58bXXxAjgMesCRQsoYmJmjiVNzR5wSOVJGOnYjNdrGuNRtB/zygnT8niH64zVaK8uJ4ha6SFaViWllYZihLksRxje4z90EY6sRkA0m1sB8i/toftC/EL4EeCdMl8E+GxrN9rU8ltNKIp7lIYyoVMR27JIryuwVGY7Qwx8xIr6l8KvP4m8G+HvEOt6U/h3VbrT7W4ltM7ZrCWaJXktycDPlMdrKRtJXlaZrken6TpzxRq95ePLbXEvR5pVimViznhVXCkDO1B91QOBV/wDsK6vfm1Z1kg6ixUn7OPTcxwX+hGzp8mRuq5TTila1uvcSWtz5k8S+O/GSfEWwu2lEmh2Ny0cz20XXT+UmnMqBm2KhMrFTtyowAQCPoC5uLDxlYxaJ4auY20KRVS5ubVwVkjIz9nhdDgbl5kYHKr8q/MwZOG/aN+Hk3xi+FOrfC7S9Sk0TUdYWMxXCR+Z5KW0qSuXjBXfGwXYVDDcWC5AyRyv7MXwKi+Cnwj07wbca/NqupWVxePNqESeQrTSTvuSKEtIDEuMIH3ZyWwpYgaS5HBSWj7frcSvc+pIIIbWGO2to1ihiUIiIAqqqjAAA4AA4AFfN37T3gW++JHw1YaE5F54WvItbiIUsJjZJIJbdMZLNLE7xjHGTgntXuXmavH8uqxefbD+K3BDkf9NI8k49kLZ7gDirWoa3YaZoV7rihri206CWZ0gG5yIULFFX+9gYC8HPFYRbTTRTPJVNx4d+Gml6VZzDUNW1CCCz0uaQme3knuR+7kMZJBSBSZWXqYo2Kk4OPS9E0XRfAHhWy0LR4SljpcMcESDBkkIAUbjxukkbqx5ZjknnNfnN+xp+1pZfH/4jP8LrzQUtLfwtok13pTQymeKO2WaG22XG5QPOSKREjcAZXzcj5q/SKKOSW8Fy+6WztSwhzy2/7rOe7ADKr3+8fmBBG2JpShNwnuTCSaujjfH9r45sPhj4ru/ASxz+NLiwuZbPeV2G78o+UimT5MLwqb/lJ5fq1fB/7BM37TkX/CWH406DrEOgq9kumrqyiO/EkCyK6os7JJ9mUeWUz8u4fugcyEfpndyCXyrWM7vtB5xz+7Xlj9Dwv/AqsQjLPMernA/3V4H9T+NKNdqm4WWv3/eHLrcqWur6fdyCCOXZMckRSq0UpA7+XIFbHvjFJcaNp1zKbgxeXOf+WsRMcn/fSEE/Q8Vent4LmMw3MayxnqrgMDj2Nef+L7vWItA1jTfh5KD4i+yzJaGU77S3u2jIgM5YMFVXKkxplyvRCORilqUVPH13420jQJoPBtwL3VJhiISxB5Y0z88gKgKxUfdDIcnGc81wnhX4pQ6FceG/AHjWxn0/XLq3LcoqReWZGWFmLPnc/l/NwcHlsZ4h+ANj+0Fofw/E3x8k07VPFck8zNLBPtZLXP7mJvJtxGzjk5QDO4A5YEn2m3Baf+0NT0iQXOCPNIil8tDxsTazPtx1wOSScc4Grsrx38xeZYu7dEnTXFIkGzZMF5Uw8kMuOpQkkHupYAZIxsq2EJY5KjqO47H8ayFi0neZId1kzHJO14Ax/wCBBQfWvCvGnxPt7TxNF8JfAvijTv8AhMtouBZzlfMFrsMjDLDy/lX5tmd/l8gYyamFNy0Q+ax7XqyJfQvpkrbbVQq3B7Oz4Ai9wcgv6jC4O442x58/3cwx+pHzn6Dt+PPsK8oTxncWPj3SfBA0W4vI7uAzvqQLGBXO8t5Y2YK5ALNuB5Gc9/ZKmSasNSIY4UiXagwOp9SfUk9TUmKdRUBzBRRRQIKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigCpd2FpfKouog5Q5RujIfVWGCp9wQarLDqFn/qZPtcQ/gl4kA9nHDYHADDJPJetSincCrFdwzN5TAxyd43GG98diPcEj3rG+ytpt/c3NlhYXVJJEJwpOCufbCqAD2HB+XG3oJI45V2SqHX0IzXzFb/AAo+NcP7RWqfEg/EBX8BXFgkNroEsc0yxzhI1y0ZkWPCuryLIp3kttI2jJuCTvd2Ez2C513Sr3WpNKOoxWcssAKxNIqXMm8kNtXO5VG0ZYckcrgYaurjimeJbeyX7DbIMAhQHx/sqeFHuRnrwOtfO3iz4U+PLz4s6D480m5tm0+0kSS9iRvLeRo9q5RHVsDyxtC+cPm5zg4H0GLxzxcrPbt/daPcuPUtFuA/77HvTlFWVmCG6laWlloeoJEojV4ZSzMclmKEZZjyT7k5q3c6pBbwtMqPMFxgRrncScAKThSSeAM8nisXXdW0TSNB1DWdUvbO2srWF2mu55ljjiUjGXkckKOcZLCrOmavp3iC3ttd0+VbzTZkElpPAyzxTBxxKrxlgykfdI4IJOTkYnldrjKsmlavf2N6GkXT73UI2Xz1JkkgypCKgG0Ax7iQdxBbJx81cZ8MfC+sfD2xufDmtag+uMXF0tyQ29RIPLKKjM5Kr5eSQc5bpjBr1hbu2ZgglUOeNpOG/I81n6pNbae8Gr3cqQQ2+9JZJGCokcmCSSeB8yrzQpPYDVSRJUEkbB1boQcg1zmo2/8Aat01nYM1u6YW4uojtdR1EasOrHrzkKOcZIqV7iO/VX0CdW+0KHM8RDxbGHDAjKsxHQjoOTkYVrttawxxLbSrsVc4jzlD3JJPLknkluSeSM0gPle48M2fwc120uPg34K0zT4PEoij1SfT9PS3e6lDHy98sIUb/mbMhzlnBwNpz9YR3NtEixlTbqgAAZdqjHQA/d/I1CVgudPW2/1gkjA+Q8jjgg9BjqD+VY+o3Nymks1y6/a3It0Qf6vzmO0Mw6sgHzsOmwE7eKqTv0A4fxnq3jZ9Om1L4ZWceoXv2pLc79vlrboWErpvZFLmUbTg42jJ5Ar0GLWvsVlbDWoGtrt41zHGpkBcAbwmzdlQfXGBycDmpLayjitYbLTI/IhhRYxKchiqjA2gYJ6dW46HDVetrBLVmkjcvK/3nk+Zjj34OPQdB2FK6tYDPVbnWFLzz/ZrX/nlDJ+8bv8APKh+X/dQ9vvkHFaVraQQIiW8SwwxDEcaKFVQe+BwM/56muNlh8ay+OkLxW7eGhDy2F80OFyMHO/dv/4Dt96i+I2h+NtZ0GKz8A6qmlXy3MbyPKzAPCA25A4V2U5Kngc4x3NFtUriud3t8+UMf9XEeB6t6/h/P6CntPGpKjLsP4V5P4+n44qC0tp0tIIb2XzpURVdlG1WYDBO0die1XFVUAVQAB2FSxlY/a5emIF/76f/AAB/76rzNPgh8LV+KA+NMmgRS+Nhb/Zf7Td5DJ5e3ZkR7vKD7Bs8wIH2fLu28V6tRQpPoAUUUUgCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//0/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDgPif8NPC3xe8Dap8PvGUUkmlauiJKYJDFMhjkWVHjkHKsrorDqDjBBGRVv4deAPDXws8EaP8PvCELwaRokAgt1lkaWQjJZmd2yWZmJZj6ngAcV2lFVzu3LfQLDWVXUo4DKeoPINeD/tE/Djxz8RfhPq3hL4Varb+HvEF20DRTzl44GWOVXZHeFXZMgcMEYgjGMEmveqKdOo4yUl0E1fQ4D4V+E9U8DfDjw34S128TUtV0uxghvbqNSiXF0FHnSgHkB5Nzc+vQdK6XxHoVr4n0HUPD19JJFb6jC8DvC22RVcYJUkEZ+oI9RW1RUt63Gcv4N8KWHgnw9a+G9Nmlnt7XdteYgud7Fj90KAMngACvEviB+z1eeOvjv4J+M8fjK+0q28Ix7X0iBAYbtwZCG8zePL3iTbKNjeYiqoK4zX0rRVxqyTbT1f6isgooorMYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//ZCmVuZHN0cmVhbQplbmRvYmoKOSAwIG9iagoxMDY3NzgKZW5kb2JqCjExIDAgb2JqCjw8IC9MZW5ndGggMTIgMCBSIC9OIDMgL0FsdGVybmF0ZSAvRGV2aWNlUkdCIC9GaWx0ZXIgL0ZsYXRlRGVjb2RlID4+CnN0cmVhbQp4AYVVW4gbVRj+kznJCrvO09rVLaRDvXQpu0u2Fd2ltJpbk7RrGrLZ1RZBs5OTZMzsJM5M0gt9KoLii6u+SUG8vS0IgtJ6wdYH+1KpUFZ36yIoPrR4QSj0RbfxO5NkJllqm2XPfPP93/lv558ZooG1Qr2u+xWiJcM2c8mo8tzRY8rAOvnpIRqkURosqFY9ks3OEn5CK679v1s/kE8wVyfubO9Xb7kbLHJLJfLdB75WtNQl4BNEgbNq3bSJBobBTx+36wKLHIZNJAj8osDlNoaNhhfb+DVHk8/FoDkLLKuVQhF4BXh8sYcv9+B2DlDAT5Ib3NRURfQia9ZKms4dQ3u5h7lHeTe4pDdQs/PbgXXIqs4dxnUMtb9SLMQFngReUQuJOeBHgK81tYVMB9+u29Ec8GNE/p2N6nwEeDdwqmQenAeGH79ZaaS6+J1Tlfyz4LeB/8ZYzBzp7F1TrRh6STvB367wtOhviEhSNDudB4Yf6YBZywk9cpBKRR5PAI8D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PyG+JxSr1U+aWrliK3vC4SeVCD59XEkb6uS4UtB1xTFZisktbjZ5cZLEd1PsI7qZc76Hvm1XPM5+hmj/X3j3fe9xxxpEKxbRyOMeN4Z35QPvEp17Qm2YzbY/8vm+I7JKe/c4976hKN5fP7daN/EeG3iLaPPNVuuf91utzQ/gf4Pogv4foJ98VQplbmRzdHJlYW0KZW5kb2JqCjE0IDAgb2JqCjEwNzkKZW5kb2JqCjEwIDAgb2JqClsgL0lDQ0Jhc2VkIDEzIDAgUiBdCmVuZG9iagozIDAgb2JqCjw8IC9UeXBlIC9QYWdlcyAvTWVkaWFCb3ggWzAgMCA2ODAgMjYyXSAvQ291bnQgMSAvS2lkcyBbIDIgMCBSIF0gPj4KZW5kb2JqCjE1IDAgb2JqCjw8IC9UeXBlIC9DYXRhbG9nIC9QYWdlcyAzIDAgUiA+PgplbmRvYmoKMTYgMCBvYmoKKE1hYyBPUyBYIDEwLjExIFF1YXJ0eiBQREZDb250ZXh0KQplbmRvYmoKMTcgMCBvYmoKKFBvd2VyUG9pbnQpCmVuZG9iagoxOCAwIG9iagooRDoyMDE2MDYxMzE4MDMwNlowMCcwMCcpCmVuZG9iagoxOSAwIG9iagooKQplbmRvYmoKMjAgMCBvYmoKWyBdCmVuZG9iagoxIDAgb2JqCjw8IC9Qcm9kdWNlciAxNiAwIFIgL0NyZWF0b3IgMTcgMCBSIC9DcmVhdGlvbkRhdGUgMTggMCBSIC9Nb2REYXRlIDE4IDAgUiAvS2V5d29yZHMKMTkgMCBSIC9BQVBMOktleXdvcmRzIDIwIDAgUiA+PgplbmRvYmoKeHJlZgowIDIxCjAwMDAwMDAwMDAgNjU1MzUgZiAKMDAwMDExMDMwNiAwMDAwMCBuIAowMDAwMDAwMzA3IDAwMDAwIG4gCjAwMDAxMTAwMTIgMDAwMDAgbiAKMDAwMDAwMDAyMiAwMDAwMCBuIAowMDAwMDAwMjg4IDAwMDAwIG4gCjAwMDAwMDA0MTEgMDAwMDAgbiAKMDAwMDEwODczNiAwMDAwMCBuIAowMDAwMDAwNTI5IDAwMDAwIG4gCjAwMDAxMDc1MTEgMDAwMDAgbiAKMDAwMDEwOTk3NSAwMDAwMCBuIAowMDAwMTA3NTMzIDAwMDAwIG4gCjAwMDAxMDg3MTUgMDAwMDAgbiAKMDAwMDEwODc3MiAwMDAwMCBuIAowMDAwMTA5OTU0IDAwMDAwIG4gCjAwMDAxMTAwOTUgMDAwMDAgbiAKMDAwMDExMDE0NSAwMDAwMCBuIAowMDAwMTEwMTk2IDAwMDAwIG4gCjAwMDAxMTAyMjUgMDAwMDAgbiAKMDAwMDExMDI2NyAwMDAwMCBuIAowMDAwMTEwMjg2IDAwMDAwIG4gCnRyYWlsZXIKPDwgL1NpemUgMjEgL1Jvb3QgMTUgMCBSIC9JbmZvIDEgMCBSIC9JRCBbIDxhODFiMGQ5NTc0NDA3YzVkNGY0ODRiMzUyMGIzNzhhMT4KPGE4MWIwZDk1NzQ0MDdjNWQ0ZjQ4NGIzNTIwYjM3OGExPiBdID4+CnN0YXJ0eHJlZgoxMTA0MzYKJSVFT0YK";
const std::string _AFLOW_LOGO_SKINNY_BASE64_ = "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AFIARwBCACAAQwBoAHUAbgBnAFAAZQByAGYAaQBsACAAUgBHAEIAIABHAGUAbgDpAHIAaQBjAG8EFwQwBDMEMAQ7BEwEPQQ4BDkAIAQ/BEAEPgREBDAEOQQ7ACAAUgBHAEIAUAByAG8AZgBpAGwAIABnAOkAbgDpAHIAaQBxAHUAZQAgAFIAVgBCAMEAbAB0AGEAbADhAG4AbwBzACAAUgBHAEIAIABwAHIAbwBmAGkAbJAadSgAIABSAEcAQgAggnJfaWPPj/AARwBlAG4AZQByAGkAcwBrACAAUgBHAEIALQBwAHIAbwBmAGkAbABPAGIAZQBjAG4A/QAgAFIARwBCACAAcAByAG8AZgBpAGwF5AXoBdUF5AXZBdwAIABSAEcAQgAgBdsF3AXcBdkAUAByAG8AZgBpAGwAbwAgAFIARwBCACAAZwBlAG4AZQByAGkAYwBvAFAAcgBvAGYAaQBsACAAUgBHAEIAIABnAGUAbgBlAHIAaQBjAEEAbABsAGcAZQBtAGUAaQBuAGUAcwAgAFIARwBCAC0AUAByAG8AZgBpAGzHfLwYACAAUgBHAEIAINUEuFzTDMd8Zm6QGgAgAFIARwBCACBjz4/wZYdO9k4AgiwAIABSAEcAQgAgMNcw7TDVMKEwpDDrA5MDtQO9A7kDugPMACADwAPBA78DxgOvA7sAIABSAEcAQgBQAGUAcgBmAGkAbAAgAFIARwBCACAAZwBlAG4A6QByAGkAYwBvAEEAbABnAGUAbQBlAGUAbgAgAFIARwBCAC0AcAByAG8AZgBpAGUAbA5CDhsOIw5EDh8OJQ5MACAAUgBHAEIAIA4XDjEOSA4nDkQOGwBHAGUAbgBlAGwAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGkAWQBsAGUAaQBuAGUAbgAgAFIARwBCAC0AcAByAG8AZgBpAGkAbABpAEcAZQBuAGUAcgBpAQ0AawBpACAAUgBHAEIAIABwAHIAbwBmAGkAbABVAG4AaQB3AGUAcgBzAGEAbABuAHkAIABwAHIAbwBmAGkAbAAgAFIARwBCBB4EMQRJBDgEOQAgBD8EQAQ+BEQEOAQ7BEwAIABSAEcAQgZFBkQGQQAgBioGOQYxBkoGQQAgAFIARwBCACAGJwZEBjkGJwZFAEcAZQBuAGUAcgBpAGMAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGV0ZXh0AAAAAENvcHlyaWdodCAyMDA3IEFwcGxlIEluYy4sIGFsbCByaWdodHMgcmVzZXJ2ZWQuAFhZWiAAAAAAAADzUgABAAAAARbPWFlaIAAAAAAAAHRNAAA97gAAA9BYWVogAAAAAAAAWnUAAKxzAAAXNFhZWiAAAAAAAAAoGgAAFZ8AALg2Y3VydgAAAAAAAAABAc0AAHNmMzIAAAAAAAEMQgAABd7///MmAAAHkgAA/ZH///ui///9owAAA9wAAMBs/8AAEQgCEwSWAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAgICAgICAwICAwUDAwMFBgUFBQUGCAYGBgYGCAoICAgICAgKCgoKCgoKCgwMDAwMDA4ODg4ODw8PDw8PDw8PD//bAEMBAgICBAQEBwQEBxALCQsQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEP/dAAQASv/aAAwDAQACEQMRAD8A/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAZyDTgc0EZpvSgrcfRQOaKCQooooAKKKKACiiigAooooAKKKKACiikzQAtFFFABRRRQAUUUU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sLK3tF1OW4uI/tMkEYVtyeawjZmAKLk/LhSSyktq4xUVJPXsLW53Pw28B6T8MPCll4H0Waa4tLIO6SXDBpGMjl3ztCqPmbgAAc+uSdLxh478F/D7TYtY8c63Z6DYzSrAk17MkEbSsCQoZyBnAJPoASeATWhc6XYwRi5dWmEB3ETSPKNv8XDs3Qc/UCvL/jT8Bvhb8cPDNr4c+JGkG+0+wuo7pBDNLaOrD5Hy8DI2xkZgyk4xz1AIlNOV5g9tD2tWV1DKQQRkEdCKWobe3gtLeK1toxFDCqoiKMKqqMAAegFTVkMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//1f38ooooAKKKKACiiigAooooAKKKKACmE0pNNoKSCiiigoKKKKACiiigAooooAK8N/aD+G2sfFnwEvgzQvEsvha7nu4pRcxRNNvRAwaNo1kiLDDb8BxyoPOK6P4h6T4u8U2NrZ+CNUOlvaXIknmDvGJVVWBiVkBY4JBP8ORtJzkDpIHuDe2AmH2hjE829SNzbAsanBwAG8xmx2PHatYNxalF6iavoZXhnwlP4S8PafoOn3pxaQRQyXMsSGWeVECGaQJt+eQrliS3Xp3G+E1vT8+VDb3gbq+54X4/vDExbHrn2ArWa5j2lJonGeCNhcYP+7uFVrTULV5zYrcJLIAWTDhiVHXPfK9/Xg+uIu+oykusamAQ2jzTsDgtbywPH9AZXibPqCgr5z0H9obw/wDEn466x8CbfSb+zl8JQjUb2WWIlZWhaIRxMqZaMb5VkUnIkCcfKTn6K1fV9KtZzZLdwx6oyZjjMirIF5O9lzny1ALMSMYB70miwz6fYpJPCXaf95I4H73LktiRe5GcHHfPyiri0k7oTNCbVNPCMs04tmI484GLnsQH25x7VTfXtHmWGWG+gZwQ2wSoWweG4BzwDn8K24pop03wuHXpx2PofQ+1eH/E747f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YHHko2S8g7zSZc/w7QSKl92I5mCLU/EfijV7C0E2jaF4mtBc+Y8e26uJbcLbTSIrcwK0bW6guN5CkqqHD1S+D3gvwwra34sj0iCG8u9QubdTt3eWluFt5UXdnkzRyFj1Yk5JrkP2n/2mfAP7NqeF9X8YW91eXN/PcPFDaCPebaGMJcFmkdAADKjKv8bKOmCw9Y+DN1DeeANIv7dt0Wr20Orx8Y+XVB9qbOecmR3JrWUJKCk1o9hJpux6Sts8H/HrIQv9x/mX8D1H6geleE+Dfhd8Ifg/4r8eeO9M0iDQNQ8Qyx3+pXpllZWjfccLvdliDTCVikaoGLDgnGPoKuE8YaTpmrQX+l6rALm11TT5UljORn7MwaPaRgggyE5zwQDkYrGMugzSTxBBqWjtq2gt/aNo0TSLKgyHAB+VOm5sjGOMHIJBGKzPh5r8nifRJdYuLGWxneeRHEp3F9mMMrYXK4wOAACDXR6FoWneHdLttH0qEW9paKVijBLBQSSeWySSSSSTk1s05Na2EFFFFQMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//1P38ooooAKKKKACkJxQTimUFJBSgZoAzT6Bth0ooooICiiigAr4k0r9r7w141/aavP2XrXS72yuLZ7yF76OTDyS2URllVlADQRMqsFlDFmJXbsLA19t1zMvgzwnNrM/iM6PaprN1GsUl/HCsd40afdU3CAS4HYbuK1pzik7q/wCgmmN1Pwt4evrGx0a50+FrKCXMcWwbUIViCo7c8n175rWF4LQmHUXWPAJWViFRwOT7BgOo/EcZA526v9Z8Pzo+pRSatpyBj58Ee66i6DMkEY/eADPzRDdyB5eAXrP8Z+H9D+KfgabT7e9M9ld7ZoZ7ORWDvC25cH5lYblwR/IjIntcZ6A0qrjHzE8gDkn/AD61haRbNPDczXJ4muZyUHQ7JDGNx/i+VRxwPUGpdC0yDQ9FsdM05muLW1gjjjZyDIyIoAJP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XLS7aCw1+6015kUJcJJlrWK4Cxy+WGDBQBCrEj0HoK+w9Qh8a/G/VLnwroGsvdeAtMmAvb64RIZtSmQgm3ilt0VPLB53CI46nd8oPyr45+MPiz4EfE6wb4e/Du01GTxHe3djYOsE08csdvIlo0FrJEEKuhgaSRmB3K+5h1NbYWNm1Zbdf63JqI+qfgx4Wf4TR6z4oa4gOgyIFu7iW+jZrmfcrLcGZztckMQCzrneMele82vjHU/EeDDbXPhfTmAP2rULcx3Emf8AnmjhoogezTHdkEeTghq818HfCBLPV73xha6zDqOupd/aY/3CDSAZreLLWtmrMLct8wE6O0xBIkkkHy17pp3iEyTpp2t2x0vUG4VHbfDMf+mM2AH9dpCuByUArkqyTdxqOh5N8a/hh8O/G/w4ksde0Gw8Q7bi2ezkvoUvWF1NMkKSB5Q5LHdtznlfl6cV6j/YCaJdW03hvbZx7TC1tjFuwxuXgf6s/KRuUdWJZWNUPGelWNzBp0KwCOS61OxLSR/u3/czLPyy4JyYwOazPifaeK/+EbRfC19JHMbmFWwUWQh22IqOQMfvCucnPv1zEdbIT0O6i1ZZZvsJjMV8BkxP2H94MOGX6c+oByBX1i32W63Dnc43h36cPGygew3FePXBPPNN0DTr5PD1ha+Itk2oLEhuHXvPj5nBGPmz3GPbAxXm3x1+Kug/A74Yar8QfFyT3mmae0KbYFUyl5ZVSMEsVQLuIyxIwOzHGSEXKSjHcTdtT2uiuP8Ah9420n4k+BtA+IGgpNFpviKxgv7dbhPLlWK4QSKHXJAOD2JB6gkYNdhWbQwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1f38ooooAKQnFBOBTKCkgpwHrSgUtANhRRRQSFFFFABRRRQAUUUUAcLeeKNVtvHFn4Zj0aWayuYS7XoJ2oQGbpt24yApywOSOPWtrXg+b7bNr/g+5fQdZlO6V1RZbS7IGP8A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rHQNF03R4fD9lZRR6dAgjSDaDHtHPIOc5PJJySeTzVTqRstNRJFTydH8E+FpF062S003RrV3SKMYVY4lLH8Tgkk8k8nmvI/DPh2TTPEHw30u8BEun6Jq17Ln/n8keySQ/ncS1nfE7xxYeHbqTwJpouLk3UKG7iZt0UdvI2GRGbLhnQEAZ2KCOOaktPHGseIPHkmpaDoMm230uGGO51BzaWii6mkZ3DFWkdW8lAuIxuweRwaiMJcvN0Hc9ZXSZbPxDf3miMtu80UEssLf6mZ2aUEnAJRzgfOo56srcYnu/EPh6ZW0nWdq3MgG6xkXzZmGeCsSBi655DKCPcEHHMwaLqOqa21t4l8R+dctAHlsdNb7GiKh+XcVZrgg7zz5ig/3ew7a08OaHp1v9n02yjswDu3QqEfd03FhyWPcknPfOTWbsB8k+JrH4w3nxktbbRGvBpEclpPYpNN/o8UAGXNwu8nLMkn38uV4HTA+k9YuPF8osLOfTrFhNdxHKXkgJ8jM/wB1rfA/1f8Aerx7xv8AHr4d/CXxtp1l8QL+SK88UXyafpzxQtIHjtgIcyBfu4ubhkyM5OTgAHHt89rqOtalYLqamztY/NnFujZkbaojHmyKcD/WfcQ445ZgcDapzWjdaGel2WV8Q6lO729ro88ksZ2u6yQNChHBG4yKWI7qBnscZBrmfHnjHw14R8LXOpeMLOe5hnK27QNAsvmtLwEAJ8rHcgt0HOT19KHk2saQxIFVQFREAHA4AA6AD8hWZrGgaV4k06XSvENpHfWk2N0Mg3JlTkH6g8g9R2rBNXAh8LeINM8U+H7LXtHVks7tCUV1Csu0lCpAyAVII4JHHBxXQVT0/TrHSbKHTdMgS2tbdQkccY2qqjsBVylK19AQUUUUgCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9b9/KKKKAEIzQBilooHcKKKKBBRRRQAUUUUAFFFFABRRRQAVDKrAiWMZZeo/vD0/wAP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sM0jhS0iZVmaPqd2MirDxN4j+JEczc2PhSJgo6g392g3Eg9DHbsAjDr5si9jXpVckpGp4PqHhe2lt7bSVvpZNMv3+06W7ouyOeQEvbsqqmA24vHx8o3rgBQD1iaW/gvwmvh2zlJmu5DDFcL8u2S4Yl5NvO3y03P1IwhJINauq2duskmj3bmKzuna8R1OGheLMjspOcFZdsq9cktxtGK8m8F/G7SvHerWpj066kmt45PsscKq32mVsK0gDMoi2oGxvbAVmBYHra5pLTpqLQ9uv7W3FpZ+HLNAkE4EZVei2sQG8fRhiPrkb89q2rsWrWsy32z7MyMJPMxs2EYbdnjGOua8/wBPtvFmq3U+pxeRotu/7lI/+PiYIjHcQceXE5bOcCVSADjIyems9C0zzVnvBJfXcZ3b7tvMZWz95E/1afWNVHFZNDMvS9Y3XS6dbiTUXt43Ec4+5LCSu1zI2FYqflcqWORuxzivK9S+EMOr/Fv/AITi6viPOa3ee0CeYgMEe3aJCV+Qqqbl2dZOvPPu9/F+8ivFbbJbhyD0yDgspPoQv4HB7V5F8GfjR8OPjSNa1HwDqZ1BtInWC5DRvGUMwLow3AbkdV2qR1CdB0rSHMk5x/q5Ltsz3Cnimin1gEgooooJCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//0P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArDewn06V7vSBlHJaW1Jwjk8s0ZPCOepH3WPXBJetyigDPjuYdRtWe2JLIcFWG1kkXDBWB5B6cHtz0NTREec5X7syq49zjB/TbUNzYiWUXds/kXSjbvAyGUchXXjcvPHIIycEZNeY+HviTD4g8c6v4Em0ueyn0MZklb5klUlR8vA+QlwVP8SjJC9KuMb7Bc6zxXptjqthHqV7bxzpo00V9CXQMwa3cSMyE/dJQMoI659K7KoGNtco8DFZUdSGXggqeCCPQ1U0dpG0y3SZi8sS+VIxOSZIjsc575YHnvUgUdKT7BqF9pnSJ3N1F7CckuM/9dNzfjXQdOTXB+PPFWl+C7O217UVklKuYljhCtI24bjgMVHG3BJOACe+KbZa0vjjS7XUtIiZ9IvUV4zJ+7E+Rk7wcsI17jaQ54J2fefK9wKXiTwxofxa0268P+JrOPUPCNwpilt5Rlb8+vqIVP3WBDO2SCEAMnH/AAf+HPwu+CngyXwV4N0u18PacbqSVo4ifMnuFbyWlZ3LSySkw8EliAFA4AA9lGn3UiCO4umSMDGyAbMj0LnL591K1ieHdNstOPn20Ko89xexu/WRz58jqXc/M2Ap6knmnfSwHz/8cE1fxAdNWS3uf7MhDhS8ZjEs3J3eWcPkKP4lGOccGrfwgafwzoaaD4lhl09NWv4pLOa4jKRukYDeXvPQkx4VGwSGyuRmvoXWIvP1TRo84Mc8soI7FYXTP/j9cpf+OfA934sfwHqVzHcamsJSSzMTSKxlCuEJ2lMlBnBOcGtee8VFIm2tz0yviD9pPwQfjpqF74W0jRovEUfhnTzE5aOGVI7jUZVM4jkm4juoYbZdvl5cLOfu5Gfpf/hHtesxi0lebSB/zDGl/ehfRbgnOP8ApkW29vM2cU74aPptzo11qlkohk1W5e8eHb5TRxMBHahouNhFrHEMDgkEgnOazi7alHmH7Oln4x1j4WWY8eX919qgnuLaWES7JfMtpDDN5ki/veZ0kKgOPlIzkHA+h9P0zTtKg+y6ZbR2sWSxWJQgLHqTjqT3J5NcN4eg/sHx34g0fG231oJq0GeSZQqW91jHAUYhIHUszHnmuhvZrzWZX0zS5Wt7ZCVubpOGBHBihP8Af7M/8HQfPna6kuaTYkrHy5+1TBPr3hPVfEXh2D7XP8PNPv8AVZJCwSNbiGLekSsSNzYRvMUfw/KTlsV+Yf7A/wAbvi78Sv2lr3TNPure/jl0i8nnlltV8m0XdAPnMGwhXaJEAYk55H8Wf2Y0jRbTx3eQSxwrF4K0edZLSAD5NSuoGzHMwPW2hYb48/62bMv3UjaTiT4Z0z4a/tO2XiLR7KGx034n6VNY3nlIsaHV9JZrqFyFAzLcW0k249SLcZ5rqhibUnSsvXqS4e9zHqt94k8faVbiC/8AD8d1cTny4pdPuFkG4gncYpxEcKAWIDHOMDk15l8XvHsGneBbb4feFrq40LxF4wnTRLKa7ie3e1FwGa7vfMkARmt7dZZgwYhpQik5cV9D2qfart9Rb7qgxQ/7mcs3/AyBj2UEdTXjWgX2k+JvifrfjzU7qIWmgJL4f0eNmBZmEitqdwi/eJeeNLYDGQbZiOJK5IlnB/GDSPCfw00D4V63oaR2OieDdSh0yBIvmAsrmzltoIUxnP8ApK2p/wCA5PrXoI+J3hyBNR8Y6HKJNInt5Jb2edXhhtZ7GIyO0mVLFmt1JIUHiJem4GuI+P8AoGk+L/BGoaX4a0O4fVdPUawskVqLfZJYHz4S4m8oyb5Y1UAZP3iM7SD4p8UfAvxLtPDll4O8FxfbLK9ubfVtXFuwmmMEb4tECIgKCWZQfkkk3rG4ICkg7RimldiufRnwX+H0eleHJviN8QUDeJ/Fdw+vagLg4isXuFHkwIjEqn2W3EcJYkncrMGwxr1ea81zxH+50Mtpent96+kQedIP+neJxgD/AKaSDH91GBDDifAE3iP/AIRjTJ/ihaXJ1CJdwLqJokwxMbOsY3eaFxlpE+U9CDnPsNreWl9EJ7OZJ4zxujYMM/UVlU0kxo868QeANCi8MXq6XGbTUIEluYr7JkuftAjI3ySOS0m4fK4Y4K/Lxxia88TWtgpOuvHY6rHHsEBdQZp1P7oW+4gyCYkhAOTyhwwYDvL+A3VjcWw6yxun/fQIr4W/an/ZXuf2rNa8NX+n+Mbjwra+HopY52jtxc/aBK8butvmSPypl27TL84yQNuYyKqjyt2m7ITbS0PsjwlpradpmJyGupXd52HRp2YvMR7eaz7f9nA6AV07MqKXchVUZJPAAFc7o1y0VmEvPluLci3uRyf3ygYYZySJAQRnJIK55yK1TA12Q12MRg5WL1PYv6+w6DrycYye5omYF9bTeIJ8wEww2ybo3OVaR3JyMjlUIXBIwxBOMDBPIeFfhz4I8ONqeo+GtJS1kv5PKjDlpFjBC71VHLKoWQMWUDjbjoBXqcO1RLMx2hnJOe20bf8A2XNfLnhf4U/ES8+Pr/G2TxtcJ4NurNkt/DxV9heSMKXOX8tYzJvmTCbyWGSMsK0hs9bAz6Zh0xbOJItPleBIwFVCTImBwBhskADspFTHz+BcRB8dHjPI9Tg8j6AmrDzKjbBlnPO0dcevt+NIEd+ZiP8AdHT8fX+XtWVxnkHiD4nwWPxH0T4cW9uLuTUkWWV8uGjRi45G3YOEJIZgSDwPXtfB/wAPfAvw/ivoPAvh+w8Px6ncNd3S2NvHbiad+DI4jA3NjjJ6DgcVfm8JeHLnxDB4sn0+J9Xt4/KjuSPnCc8ehxuOCRkZOK6QCqk1ZWJAClooqCQooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArB8TRanLod3/AGLEkuooha3DnAEnYg5HOM45Geh4Jreoppgcb4Yl8Rz6DZL42hii1FgRIY1BUncQuRllViuMgZGTxjoNK30yCKW6iMssYD+YgWQqqq4yflHycuGOCK32UMCrDIPBB718uWlt+0xb/tF6xdagljd/CAWCC0gjeEXjXG1MABgsm9ZDIW8yTyzHjb82ANIq99bCue26n4WtPElqbLUI4p9OLBvLmhBMjL0b92YyFGeO578cHzzwZp3xE8CazrDeKJorzwvNcP8AYYrcbjZRM5KBV2hvL2kAoSxBHynGAfarLVLG/Zo4JCJkGWidTHKo9SjAMAexxg9qvMqupRwGVhgg8gg1PO9gsNhliuIkngdZI5AGVlIKsDyCCOCDWLAvlw30K9LW5aRfU7ts5H4liKpm0uPD0zT6eplsJCWkhzyhJyWTPTPcdD14OSdXS5obl7y4gbekkwIPTpEgIIPIIIwQeQeDUjGXA3a7Y56LBcN+O6IfyJriV+Gnha58bXXxAjgMesCRQsoYmJmjiVNzR5wSOVJGOnYjNdrGuNRtB/zygnT8niH64zVaK8uJ4ha6SFaViWllYZihLksRxje4z90EY6sRkA0m1sB8i/toftC/EL4EeCdMl8E+GxrN9rU8ltNKIp7lIYyoVMR27JIryuwVGY7Qwx8xIr6l8KvP4m8G+HvEOt6U/h3VbrT7W4ltM7ZrCWaJXktycDPlMdrKRtJXlaZrken6TpzxRq95ePLbXEvR5pVimViznhVXCkDO1B91QOBV/wDsK6vfm1Z1kg6ixUn7OPTcxwX+hGzp8mRuq5TTila1uvcSWtz5k8S+O/GSfEWwu2lEmh2Ny0cz20XXT+UmnMqBm2KhMrFTtyowAQCPoC5uLDxlYxaJ4auY20KRVS5ubVwVkjIz9nhdDgbl5kYHKr8q/MwZOG/aN+Hk3xi+FOrfC7S9Sk0TUdYWMxXCR+Z5KW0qSuXjBXfGwXYVDDcWC5AyRyv7MXwKi+Cnwj07wbca/NqupWVxePNqESeQrTSTvuSKEtIDEuMIH3ZyWwpYgaS5HBSWj7frcSvc+pIIIbWGO2to1ihiUIiIAqqqjAAA4AA4AFfN37T3gW++JHw1YaE5F54WvItbiIUsJjZJIJbdMZLNLE7xjHGTgntXuXmavH8uqxefbD+K3BDkf9NI8k49kLZ7gDirWoa3YaZoV7rihri206CWZ0gG5yIULFFX+9gYC8HPFYRbTTRTPJVNx4d+Gml6VZzDUNW1CCCz0uaQme3knuR+7kMZJBSBSZWXqYo2Kk4OPS9E0XRfAHhWy0LR4SljpcMcESDBkkIAUbjxukkbqx5ZjknnNfnN+xp+1pZfH/4jP8LrzQUtLfwtok13pTQymeKO2WaG22XG5QPOSKREjcAZXzcj5q/SKKOSW8Fy+6WztSwhzy2/7rOe7ADKr3+8fmBBG2JpShNwnuTCSaujjfH9r45sPhj4ru/ASxz+NLiwuZbPeV2G78o+UimT5MLwqb/lJ5fq1fB/7BM37TkX/CWH406DrEOgq9kumrqyiO/EkCyK6os7JJ9mUeWUz8u4fugcyEfpndyCXyrWM7vtB5xz+7Xlj9Dwv/AqsQjLPMernA/3V4H9T+NKNdqm4WWv3/eHLrcqWur6fdyCCOXZMckRSq0UpA7+XIFbHvjFJcaNp1zKbgxeXOf+WsRMcn/fSEE/Q8Vent4LmMw3MayxnqrgMDj2Nef+L7vWItA1jTfh5KD4i+yzJaGU77S3u2jIgM5YMFVXKkxplyvRCORilqUVPH13420jQJoPBtwL3VJhiISxB5Y0z88gKgKxUfdDIcnGc81wnhX4pQ6FceG/AHjWxn0/XLq3LcoqReWZGWFmLPnc/l/NwcHlsZ4h+ANj+0Fofw/E3x8k07VPFck8zNLBPtZLXP7mJvJtxGzjk5QDO4A5YEn2m3Baf+0NT0iQXOCPNIil8tDxsTazPtx1wOSScc4Grsrx38xeZYu7dEnTXFIkGzZMF5Uw8kMuOpQkkHupYAZIxsq2EJY5KjqO47H8ayFi0neZId1kzHJO14Ax/wCBBQfWvCvGnxPt7TxNF8JfAvijTv8AhMtouBZzlfMFrsMjDLDy/lX5tmd/l8gYyamFNy0Q+ax7XqyJfQvpkrbbVQq3B7Oz4Ai9wcgv6jC4O442x58/3cwx+pHzn6Dt+PPsK8oTxncWPj3SfBA0W4vI7uAzvqQLGBXO8t5Y2YK5ALNuB5Gc9/ZKmSasNSIY4UiXagwOp9SfUk9TUmKdRUBzBRRRQIKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigCpd2FpfKouog5Q5RujIfVWGCp9wQarLDqFn/qZPtcQ/gl4kA9nHDYHADDJPJetSincCrFdwzN5TAxyd43GG98diPcEj3rG+ytpt/c3NlhYXVJJEJwpOCufbCqAD2HB+XG3oJI45V2SqHX0IzXzFb/AAo+NcP7RWqfEg/EBX8BXFgkNroEsc0yxzhI1y0ZkWPCuryLIp3kttI2jJuCTvd2Ez2C513Sr3WpNKOoxWcssAKxNIqXMm8kNtXO5VG0ZYckcrgYaurjimeJbeyX7DbIMAhQHx/sqeFHuRnrwOtfO3iz4U+PLz4s6D480m5tm0+0kSS9iRvLeRo9q5RHVsDyxtC+cPm5zg4H0GLxzxcrPbt/daPcuPUtFuA/77HvTlFWVmCG6laWlloeoJEojV4ZSzMclmKEZZjyT7k5q3c6pBbwtMqPMFxgRrncScAKThSSeAM8nisXXdW0TSNB1DWdUvbO2srWF2mu55ljjiUjGXkckKOcZLCrOmavp3iC3ttd0+VbzTZkElpPAyzxTBxxKrxlgykfdI4IJOTkYnldrjKsmlavf2N6GkXT73UI2Xz1JkkgypCKgG0Ax7iQdxBbJx81cZ8MfC+sfD2xufDmtag+uMXF0tyQ29RIPLKKjM5Kr5eSQc5bpjBr1hbu2ZgglUOeNpOG/I81n6pNbae8Gr3cqQQ2+9JZJGCokcmCSSeB8yrzQpPYDVSRJUEkbB1boQcg1zmo2/8Aat01nYM1u6YW4uojtdR1EasOrHrzkKOcZIqV7iO/VX0CdW+0KHM8RDxbGHDAjKsxHQjoOTkYVrttawxxLbSrsVc4jzlD3JJPLknkluSeSM0gPle48M2fwc120uPg34K0zT4PEoij1SfT9PS3e6lDHy98sIUb/mbMhzlnBwNpz9YR3NtEixlTbqgAAZdqjHQA/d/I1CVgudPW2/1gkjA+Q8jjgg9BjqD+VY+o3Nymks1y6/a3It0Qf6vzmO0Mw6sgHzsOmwE7eKqTv0A4fxnq3jZ9Om1L4ZWceoXv2pLc79vlrboWErpvZFLmUbTg42jJ5Ar0GLWvsVlbDWoGtrt41zHGpkBcAbwmzdlQfXGBycDmpLayjitYbLTI/IhhRYxKchiqjA2gYJ6dW46HDVetrBLVmkjcvK/3nk+Zjj34OPQdB2FK6tYDPVbnWFLzz/ZrX/nlDJ+8bv8APKh+X/dQ9vvkHFaVraQQIiW8SwwxDEcaKFVQe+BwM/56muNlh8ay+OkLxW7eGhDy2F80OFyMHO/dv/4Dt96i+I2h+NtZ0GKz8A6qmlXy3MbyPKzAPCA25A4V2U5Kngc4x3NFtUriud3t8+UMf9XEeB6t6/h/P6CntPGpKjLsP4V5P4+n44qC0tp0tIIb2XzpURVdlG1WYDBO0die1XFVUAVQAB2FSxlY/a5emIF/76f/AAB/76rzNPgh8LV+KA+NMmgRS+Nhb/Zf7Td5DJ5e3ZkR7vKD7Bs8wIH2fLu28V6tRQpPoAUUUUgCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//0/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDgPif8NPC3xe8Dap8PvGUUkmlauiJKYJDFMhjkWVHjkHKsrorDqDjBBGRVv4deAPDXws8EaP8PvCELwaRokAgt1lkaWQjJZmd2yWZmJZj6ngAcV2lFVzu3LfQLDWVXUo4DKeoPINeD/tE/Djxz8RfhPq3hL4Varb+HvEF20DRTzl44GWOVXZHeFXZMgcMEYgjGMEmveqKdOo4yUl0E1fQ4D4V+E9U8DfDjw34S128TUtV0uxghvbqNSiXF0FHnSgHkB5Nzc+vQdK6XxHoVr4n0HUPD19JJFb6jC8DvC22RVcYJUkEZ+oI9RW1RUt63Gcv4N8KWHgnw9a+G9Nmlnt7XdteYgud7Fj90KAMngACvEviB+z1eeOvjv4J+M8fjK+0q28Ix7X0iBAYbtwZCG8zePL3iTbKNjeYiqoK4zX0rRVxqyTbT1f6isgooorMYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//ZCmVuZHN0cmVhbQplbmRvYmoKOSAwIG9iagoxMDY3NzgKZW5kb2JqCjEwIDAgb2JqCjw8IC9MZW5ndGggMTEgMCBSIC9OIDMgL0FsdGVybmF0ZSAvRGV2aWNlUkdCIC9GaWx0ZXIgL0ZsYXRlRGVjb2RlID4+CnN0cmVhbQp4AYVVW4gbVRj+kznJCrvO09rVLaRDvXQpu0u2Fd2ltJpbk7RrGrLZ1RZBs5OTZMzsJM5M0gt9KoLii6u+SUG8vS0IgtJ6wdYH+1KpUFZ36yIoPrR4QSj0RbfxO5NkJllqm2XPfPP93/lv558ZooG1Qr2u+xWiJcM2c8mo8tzRY8rAOvnpIRqkURosqFY9ks3OEn5CK679v1s/kE8wVyfubO9Xb7kbLHJLJfLdB75WtNQl4BNEgbNq3bSJBobBTx+36wKLHIZNJAj8osDlNoaNhhfb+DVHk8/FoDkLLKuVQhF4BXh8sYcv9+B2DlDAT5Ib3NRURfQia9ZKms4dQ3u5h7lHeTe4pDdQs/PbgXXIqs4dxnUMtb9SLMQFngReUQuJOeBHgK81tYVMB9+u29Ec8GNE/p2N6nwEeDdwqmQenAeGH79ZaaS6+J1Tlfyz4LeB/8ZYzBzp7F1TrRh6STvB367wtOhviEhSNDudB4Yf6YBZywk9cpBKRR5PAI8Dv16tHRY5wKf0mdWcE7zIZ+1UJSbyFPzllwqHssCjwL9yPSn0iCX9W7eznRxYyNAzIi5isTi3nHrhh4XsSj4FHnGZbpv5zl62XNIOpjv6TypmSvBi77W67swocgv4zUZO1I5YgcmCmUgCw2cgy4150U+Bm7TgKxCnGi1iVcmgTVIoR0mK4lonE5YSaaSD4bByMBx3Xc2Es8+iKniNmo7Nwpp1lO2dXa1CZbAGXXe0KsVCH1EDnir0B9iK61OhGO4a4Mr/46edy42OnxobYWG2F//72Czbz6bZDCnsKfY0O8DiYGfYPtd3Fnu6FYl8biBK28/LiMgd3QJqv4gabSpg/QWKGlmuh76uLI82xjzLGfMFTb3yxt89vdKws+oqJvo6euRePQ/8FrgeWMW6HthwfSiBnwIb+FtHb7xaap6902VxUhpOtNan23oWXVUElerOziV0QUPNvKfmiV4fl05/+aAXbZWde/7q0KXTJWN51GNFF/irmVsZOjPuseEfw3+GV8PvhT8M/y69LX0qfSWdlz6XLpMiXZAuSl9L30ofS1+4+rvNkHv2JDIXcyXyFtPVrbC315hYOSpvlx+W4/IO+VF51lUp8og8JafkXbBsd8/Nm2+lt3L05Siidftz51jiWdFcTzgD3/2YAM2L2DcD88hYo+PwaaLfYt4MOglt75PXqYiF2BRLb5nuaTHzXd/BRDAejJAS3B2cCU4FDwncfZaDu2CbwZrozQ3z4Sr6KuU2PyG+JxSr1U+aWrliK3vC4SeVCD59XEkb6uS4UtB1xTFZisktbjZ5cZLEd1PsI7qZc76Hvm1XPM5+hmj/X3j3fe9xxxpEKxbRyOMeN4Z35QPvEp17Qm2YzbY/8vm+I7JKe/c4976hKN5fP7daN/EeG3iLaPPNVuuf91utzQ/gf4Pogv4foJ98VQplbmRzdHJlYW0KZW5kb2JqCjExIDAgb2JqCjEwNzkKZW5kb2JqCjcgMCBvYmoKWyAvSUNDQmFzZWQgMTAgMCBSIF0KZW5kb2JqCjMgMCBvYmoKPDwgL1R5cGUgL1BhZ2VzIC9NZWRpYUJveCBbMCAwIDQyMSA3Ml0gL0NvdW50IDEgL0tpZHMgWyAyIDAgUiBdID4+CmVuZG9iagoxMiAwIG9iago8PCAvVHlwZSAvQ2F0YWxvZyAvUGFnZXMgMyAwIFIgPj4KZW5kb2JqCjEzIDAgb2JqCihNYWMgT1MgWCAxMC4xMi42IFF1YXJ0eiBQREZDb250ZXh0KQplbmRvYmoKMTQgMCBvYmoKKFBvd2VyUG9pbnQpCmVuZG9iagoxNSAwIG9iagooRDoyMDE4MDgxNjE5MDEwMVowMCcwMCcpCmVuZG9iagoxNiAwIG9iagooKQplbmRvYmoKMTcgMCBvYmoKWyBdCmVuZG9iagoxIDAgb2JqCjw8IC9Qcm9kdWNlciAxMyAwIFIgL0NyZWF0b3IgMTQgMCBSIC9DcmVhdGlvbkRhdGUgMTUgMCBSIC9Nb2REYXRlIDE1IDAgUiAvS2V5d29yZHMKMTYgMCBSIC9BQVBMOktleXdvcmRzIDE3IDAgUiA+PgplbmRvYmoKeHJlZgowIDE4CjAwMDAwMDAwMDAgNjU1MzUgZiAKMDAwMDEwOTAzNCAwMDAwMCBuIAowMDAwMDAwMjc2IDAwMDAwIG4gCjAwMDAxMDg3MzkgMDAwMDAgbiAKMDAwMDAwMDAyMiAwMDAwMCBuIAowMDAwMDAwMjU3IDAwMDAwIG4gCjAwMDAwMDAzNzkgMDAwMDAgbiAKMDAwMDEwODcwMyAwMDAwMCBuIAowMDAwMDAwNDk3IDAwMDAwIG4gCjAwMDAxMDc0NzggMDAwMDAgbiAKMDAwMDEwNzUwMCAwMDAwMCBuIAowMDAwMTA4NjgyIDAwMDAwIG4gCjAwMDAxMDg4MjEgMDAwMDAgbiAKMDAwMDEwODg3MSAwMDAwMCBuIAowMDAwMTA4OTI0IDAwMDAwIG4gCjAwMDAxMDg5NTMgMDAwMDAgbiAKMDAwMDEwODk5NSAwMDAwMCBuIAowMDAwMTA5MDE0IDAwMDAwIG4gCnRyYWlsZXIKPDwgL1NpemUgMTggL1Jvb3QgMTIgMCBSIC9JbmZvIDEgMCBSIC9JRCBbIDxhOWFhZjRiODNkZjJmYmEwNGFhZTY1YjY1ZmVlOTZmNz4KPGE5YWFmNGI4M2RmMmZiYTA0YWFlNjViNjVmZWU5NmY3PiBdID4+CnN0YXJ0eHJlZgoxMDkxNjQKJSVFT0YK";
const std::string _AFLOW_LOGO_NOBALL_BASE64_ = "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bgBoACAAUgBHAEIAIABDAGgAdQBuAGcAUABlAHIAZgBpAGwAIABSAEcAQgAgAEcAZQBuAOkAcgBpAGMAbwQXBDAEMwQwBDsETAQ9BDgEOQAgBD8EQAQ+BEQEMAQ5BDsAIABSAEcAQgBQAHIAbwBmAGkAbAAgAGcA6QBuAOkAcgBpAHEAdQBlACAAUgBWAEIAwQBsAHQAYQBsAOEAbgBvAHMAIABSAEcAQgAgAHAAcgBvAGYAaQBskBp1KAAgAFIARwBCACCCcl9pY8+P8ABHAGUAbgBlAHIAaQBzAGsAIABSAEcAQgAtAHAAcgBvAGYAaQBsAE8AYgBlAGMAbgD9ACAAUgBHAEIAIABwAHIAbwBmAGkAbAXkBegF1QXkBdkF3AAgAFIARwBCACAF2wXcBdwF2QBQAHIAbwBmAGkAbABvACAAUgBHAEIAIABnAGUAbgBlAHIAaQBjAG8AUAByAG8AZgBpAGwAIABSAEcAQgAgAGcAZQBuAGUAcgBpAGMAQQBsAGwAZwBlAG0AZQBpAG4AZQBzACAAUgBHAEIALQBQAHIAbwBmAGkAbMd8vBgAIABSAEcAQgAg1QS4XNMMx3xmbpAaACAAUgBHAEIAIGPPj/Blh072TgCCLAAgAFIARwBCACAw1zDtMNUwoTCkMOsDkwO1A70DuQO6A8wAIAPAA8EDvwPGA68DuwAgAFIARwBCAFAAZQByAGYAaQBsACAAUgBHAEIAIABnAGUAbgDpAHIAaQBjAG8AQQBsAGcAZQBtAGUAZQBuACAAUgBHAEIALQBwAHIAbwBmAGkAZQBsDkIOGw4jDkQOHw4lDkwAIABSAEcAQgAgDhcOMQ5IDicORA4bAEcAZQBuAGUAbAAgAFIARwBCACAAUAByAG8AZgBpAGwAaQBZAGwAZQBpAG4AZQBuACAAUgBHAEIALQBwAHIAbwBmAGkAaQBsAGkARwBlAG4AZQByAGkBDQBrAGkAIABSAEcAQgAgAHAAcgBvAGYAaQBsAFUAbgBpAHcAZQByAHMAYQBsAG4AeQAgAHAAcgBvAGYAaQBsACAAUgBHAEIEHgQxBEkEOAQ5ACAEPwRABD4ERAQ4BDsETAAgAFIARwBCBkUGRAZBACAGKgY5BjEGSgZBACAAUgBHAEIAIAYnBkQGOQYnBkUARwBlAG4AZQByAGkAYwAgAFIARwBCACAAUAByAG8AZgBpAGwAZXRleHQAAAAAQ29weXJpZ2h0IDIwMDcgQXBwbGUgSW5jLiwgYWxsIHJpZ2h0cyByZXNlcnZlZC4AWFlaIAAAAAAAAPNSAAEAAAABFs9YWVogAAAAAAAAdE0AAD3uAAAD0FhZWiAAAAAAAABadQAArHMAABc0WFlaIAAAAAAAACgaAAAVnwAAuDZjdXJ2AAAAAAAAAAEBzQAAc2YzMgAAAAAAAQxCAAAF3v//8yYAAAeSAAD9kf//+6L///2jAAAD3AAAwGz/wAARCAITBJYDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9sAQwACAgICAgIDAgIDBQMDAwUGBQUFBQYIBgYGBgYICggICAgICAoKCgoKCgoKDAwMDAwMDg4ODg4PDw8PDw8PDw8P/9sAQwECAgIEBAQHBAQHEAsJCxAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQ/90ABABK/9oADAMBAAIRAxEAPwD9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9H9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9L9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigBnINOBzQRmm9KCtx9FA5ooJCiiigAooooAKKKKACiiigAooooAKKKTNAC0UUUAFFF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fWrzW7mwsre0XU5bi4j+0yQRhW3J5rCNmYAouT8uFJLKS2rjFRUk9ewtbnc/DbwHpPww8KWXgfRZpri0sg7pJcMGkYyOXfO0Ko+ZuAABz65J0vGHjvwX8PtNi1jxzrdnoNjNKsCTXsyQRtKwJChnIGcAk+gBJ4BNaFzpdjBGLl1aYQHcRNI8o2/xcOzdBz9QK8v+NPwG+Fvxw8M2vhz4kaQb7T7C6jukEM0to6sPkfLwMjbGRmDKTjHPUAiU05XmD20Pa1ZXUMpBBGQR0Ipaht7eC0t4rW2jEUMKqiIowqqowAB6AVNWQwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//V/fyiiigAooooAKKKKACiiigAooooAKYTSk02gpIKKKKCgooooAKKKKACiiigArw39oP4bax8WfAS+DNC8Sy+Frue7ilFzFE029EDBo2jWSIsMNvwHHKg84ro/iHpPi7xTY2tn4I1Q6W9pciSeYO8YlVVYGJWQFjgkE/w5G0nOQOkge4N7YCYfaGMTzb1I3NsCxqcHAAbzGbHY8dq1g3FqUXqJq+hleGfCU/hLw9p+g6fenFpBFDJcyxIZZ5UQIZpAm355CuWJLdencb4TW9Pz5UNveBur7nhfj+8MTFseufYCtZrmPaUmicZ4I2Fxg/7u4VWtNQtXnNitwksgBZMOGJUdc98r39eD64i76jKS6xqYBDaPNOwOC1vLA8f0BleJs+oKCvnPQf2hvD/AMSfjrrHwJt9Jv7OXwlCNRvZZYiVlaFohHEyploxvlWRSciQJx8pOforV9X0q1nNkt3DHqjJmOMyKsgXk72XOfLUAsxIxgHvSaLDPp9ikk8Jdp/3kjgfvcuS2JF7kZwcd8/KKuLSTuhM0JtU08IyzTi2YjjzgYuexAfbnHtVN9e0eZYZYb6BnBDbBKhbB4bgHPAOfwrbiminTfC4denHY+h9D7V4f8Tvjt8JPhW8mgeOdVSbU7/m10a0ie/1K8Egztis4FeVstnkqFGRlgKmKvokB6r4l8SeFfCmmNq/jHVLLSNORgpuL+eO3hDHoN8pVcnnAzXmOv8AxD0fXbS30z4ca5HfnUYhNLfafNHeR29ozGNWiYF0aed1aK3UEAsHchliZT+HX7d/xS8Xaj4n8N654o8EXXgXw6dPkj0+zv5LYXkzpKRLd3VtAzG1aUMiKkpydhIJ5A7D/gnB8FPH/wAYrPxd4vuvF3ijwN4LS4tzp7aJcx2cd/fAOs7oZoZgyxIEVmQLliBuJTC+lPB0oUY1Oe8nuuxgpyc2raH69fCnS/G2h/b9P8bwiHS4iu1EVfLik/ubl+ZoVT+JyQfvMck175cWtvqNg1sr4imQbHjI+XujoemVOCp9QDXytb/staZHqbW2ofE/4hXu+JXUv4ou4S5ViHz9m8nplemOtbsH7KHwzs0DW974iuplJZvtvijXJ45Seu9PtoGfcAc8kHpXDPlbvc2Ssj360Nr4j0aWx1q2iuN2+2vLeRA8TOvyupRs5RvvLuHKkHvXCT6H4u8GzS3XgicavpcSKX0jUJiHRRuJFnePuZMckRT70PCq8CDNeO6h8NfgL4H8R2CeLdCtrOHWA0G3U7iW7ja4iG5ZI5Lh3DqyZV93zDEeVUHNUr7wj8K/FWv3vhvwT4V0PTtJ0xo21LVI9NtQkSMisqxny8PJIDmNeQQRLIDF5cd0lEk8m0n/AIKH/AfVficdG14ajoek3UcVtBeXMMckL3cLSttkW3klfBZgsZUOGbngbSfbfE3xnf4jaJcWngP4f+Jtf0sqJft81muiWrIvzM6vqrW8rJtzho4JSx6Ljk/MngP9gH4Gx/tKat4nB1gaXoFrZavYaPNdlYbe51CW7RGDxqlwnk/Z/MiQyl0LIzNkbR9yahqfxA+GqtJqdtceOfCqj5praIPrVmnfzLdAFvowP4oQs4AA8qdiXrorypcydJNbbsiKdveOM8JeC/jXpOivpI/sHwzptxI0s8SLPr9428AEiRxp8KMAB8vkygYwN/Wu0tPhFa3dus174w13VDnKg3i21rgdYza2SW8BTPBVkJ7Fq6z4Z+MvDfjnwjbav4W1OHVrKF5LTz4X3/NbtsxIOqSbQC6MAyk4IB4rq7rTnaVrzT5fs10epxujkx2kTIz9QQw9cZB5ZTd9SzwT4qeDtG0/4P8AjHQ9X8H6Tqugy6bdTXENrBHArtDEZEd7aT5SY2UMGEpcEAqMgV4l8Edb8M6V5mhfAHwhB4btrNXlh05ZFWHULWMLvWUYAW63EvHKzkFiUkfadw9h+MfjdNR8JzaBOy6bbXOp6Tpl3M7/ALu4W91K3tJ47aXgMsaSMZm4KgFSoO4r6TpHhP4ceHrZte0eC00abVCZVurdkjYlyXAjPKkc8oBtbuprSMkl7yEzp/Cet6L4r0qHxDpU7XQZnjbzVKS280ZKSwvEQDFJGwKOhAYEYbNdXXy34suvFfhPxGfHngnSpLnU7namo2OPstpr8US4Uw+cQYdSiQAQlhtmQeSzsoR4PbfBPizSfiJ4bs/Fnh7U1utNvQ20RIYnR0YrJDMsn7xJYnBR0IR0YFWAIwMpR6jMSPxJovi34hx+H9JvortfD1rLcXsasDsmuHEMGP73ypcK2MgA4PLDHfXFla6tHdW17GJbeQCIqehC8kgjBBDHqOQRkHIrwj4beDfDGi694t+IFtC00F7qFxp8JlIcxQWBEDoowOPtkc+M5OCvqa96tdNtYbdEeCPfjLEKMFjyx6dzTnZPQEcnBr8nhm7Gg+K5y0bq7WN844uUjUu0MmBgXCIpbGP3qAunIkVOK8E/GDwt488NasdOaSz+wQuFF0URniYP5bDDNzhfmHUH613mq6Fo3jnTp9KvrZZNGmwCy5R5nQhleJ0wyBGAZJFIYsAykAAt5t4PtrLwRrFx8LtZtILGXW4pfsGoQQpBFqYjUlgyxhVS7jjJMkSgIyqZYgFMkcLjazvuB65rHi7wzoNkdR1bUoYLcMF3bt5y3QALkn8BWtBqFrdQx3FuzSRSqGRlRirKwyCDjkEVhS6fpfjTw/aRa3bLcQXEcM7ISRh2UMMFSCOvr0+taws9K0u1RU22VtCqqAr+UigcAcED2qGkBDreuW+h6Lf63NDNNHp9vLcNHFGxkcRKXKqDjLHGB71jeAfGdr4+8M2/iWztpLWOcsuyQgkFDg4YcEe/4VuJfwtza3DXIPdYzImfTcgCg/U/WvH/AI8eN/if8Pvhjq3iv4WeFR4l1608oRWTAyFgzgM6wxOrSbVz8iuGPGM4wbhFN8vcTZ7vRXkfwP8AH3ib4kfDnTPE3jPQT4b12RFS9sSxIiuAimRRuAYAMxXBzgjqRyfXKzas7DCiiikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/1v38ooooAKKKKACiiigAooooAKKKQ0DQ00lFFBYUUUUAFFFFABRRSEhRknAFACkgDJ4ArPYPf/KCUtu5HDSfQ9Qvv1PbAwTYMZnOZRiMdF9fdv6D8/Qcv4i8d+HPDJlgvJ2uL2JPMNpaoZ7gL2ZkTPlqegeQqmerCml2A6SZE2x2MShVcYIAwBGuMgD8l46ZyOlcf4T8S6B4m1nW5NA1O11FNPaCzkFtMkuxlDyZOwnaP3hQZ7o1clbN4y+JWmy3kF7H4a0TUVaPFuEutTeIbkKtIwNvbtnOQFnIzw6kceX/AAQ/Zs8PfCy61nWU1S61mXVpmtEe62obWG1lkSMKYdh3sfvPkZyAAvOdUo8ru9QZ9c1z/iCfTRplzJdqJ/sitNsVBK6tGCQdv6c4BBwTg1kzeAtGuEZZrzVG3f8AUUvQB/wETbT+INVD4NvrG2ZLbxdq1pbRqSVxZTBVA5+aa1kbH1JrNJdwPmbR9K8P+K/iHdeMLeaXS7r7RD9u01VWTybdIdjTrIpBERUBXUoMFupBAPtGs/FS1inm07wE9/411eBjG9tYW0c9tC4zlbi6/wBHghYHqrTeZjpG3Svz40b9m74w3n7QOlvq+lRf2Zo15FqOq3rywvFfWEjvmIwhi8huRG8ZjZMDndgYz+p3hY2mnwf8I1aqkcOnxobUIAqtZvnyioHHy4KHv8u4/eFdmJ5E0ovmSREL9UfPGreD/j18QCkvjDxDD4T09xiTT/DDXNteOvZZtUlt5ZMeogihIPSQ9a8n8YeN/AX7HthZR+D/AIaifxN4lea3tFgkBu9UuMBt093cbrqUIQGkkfIVck4JAP118YPi54Q+CXgW98eeM52W2tsRwW8Q3XF5cycRW8CdXkkPAHYZY4UEjwv4K/C3xRrniJfjv8eLSOXx54iUiz0xx5kHh3SFBaOzhDDHnFmRriTGWfAGADnOEtLy2KZ5b4J8Tr4N1zWdM8WW517xx4vW0bxBrNzEY1gkmUMltZ2kqMxtLWN1EKMV3kF2yzk17V+y1q0mleDfEHwrispGl+G/iDU9ERS0akWXm/a9PLAtkD7HcQrkAglTjPNexeI/hh4a1jVB4mtbGCLXIVHk3DJkB05jYgd1bkEgjrkGvlD4eeMV0D9trxNoF1C1jH8UPDNnqTQydE1nw/I9jcwoejE25V9w+8qA8dKHJSjotf6/Qm2p9e6vceKYtZ0yS2trKL7QZrVWeaSTBdPOyUEaZwISPv8AethbDxVN8lzrEES+ttZlH/OWWZf/AB2o/FjC3sbTUc7Ws720cN0AWSVYZCfby5GzXknxh+MN34a1CD4a/DzyLzx3q0BuAZ8taaPYA7X1K/2kERqflhiBD3EuI0wN7Jik3axTPGP2ifB11478T6f4P8Ka9NqHibT7d5tQku4YJbXS9Pm+5JKIUiH2iZ1220JDNKQScRoWrq/gZ8I7/wCGk1jLdFhoaxeZ5ssom+03MuCtzINxw7Ekl2GQWwMA8evfCb4a2ngzRVMrT3NzczNeT3F6Q17e3koAkvbxhgGZwAEQAJDGFjQKFAH5y/tiftZ+OPhzc6T8F/h9ff2NNb2TnUL4IjzOkVxNaRxR+YGCAiAuzAZO4AEYOfQwVCdeSw9O2vc56s1Bc7Pv34Laj/wknjT4ueKc7oj4mGk259IdJsLWBxn2ujcfnX0FX88n7Iv7fOpfBbxFqPw4+IdlqPi3w/rU13qFqdLtVu9VTUrmUzT5G5DMkzM7MWJZWxj5eK/Ry6/b+0yJYDD8EfiWv2ttkButDhtFnb+7EZboFz7KCawxODnCo4di4TUldHpnxI+HPh+w+I1z4s8I+LU+G/jPWLaKaK+R4za6hLAfKeLUbKRliukKmMI3yzLhvLlXkHi7f9pzULXxFbfCr47W8Hw/vprlrKTxDazPJoOpSoqn7PY3zKPs1xID80VwVeIcIzuQw+VPH3iD4/eMPHd/46k+CXiW20/VmiW1W9ls43ijRFjRHRZmMZLAkKQMk9yTXv3hyw/aT8ffDiLwRe/Dfwq/horLbT2Ou3zOHZZG3rcpbRTfMj542jkZOTjFeyXIpN6gm72PZ/j7pum+JIfhd8NdN221hrvie3jjMYG0RabYXmoAonAKKbZec45GM5yPc/AfgrR/BujR2NiiyzqZBJcFFDuS5yMjkKD0Gf1r+V/44jx94A+L2q/CGFpJ9c8NXqWelWOkXN3qi2gmImtrWxmkYz4TzAqLtDhuCoYGvtfwX8VPEFzLbeDv2xvix8Q/hj4gfEZhv7SXTdJnJAJ2XWmvBIwJJLNJhcclzzW1fCRUYqE76XehMJNt3R+8fibUPC1hpE58YXVpaaZIpWVr2RIoSOvJkIX3r8ov2gvjxb/sx+IoviX8BvE9h4j0vxnJJb6nA27UNP8AtUUYMVy80EiqboKuzeJN8ka/vlcxq4+hvh3+y34IurO28Z/DvxnpGtLMMw6xFpNjqk7jr8t/K80zf9/TXQ/Gj9nvWvGXw61iw+InjgeIdKt4XuFs7/T4BA08SnysHcdjljtVlG4Z464PNh5whNN6rsVJNqyPA/2VP2svG/xd+Gdl4b0PwDa6teaddS2VzcnWoLFb6WPbcSTrDKrS5lMmZCoZS5faeCF+rtK8Y/tA+MUawj8D6DBZWjbZmuPEs6NeJyFKtDpUoMZIIcjhyCAduc/mHoujp8JXEOkaQ+maXaZGpWMcRjaw8oZN4EwCqoBm4z0QebwVbf8Aq7/wtmx0yysNT8TaNd+HJLWNcSmMXGn3Fu4G5Yrq33xYIAdN2zkAcAmtcRTikpxtr+AoN7M6+1vfjVMqrc6H4e08DjEeqXd2APbNhb/0ryP9pDw/8Vtf+DOv2mk3uljxBGkU+lJBbzRzi/ilQwfZ7lpx5U7PiOJwn32HKgkj6bsdb0nVdNi1fSLuK/s7gBopbd1kSTd02spwc/WvN/D1w3jzxdc6/kSaH4anltbRh9y61JN0VzMp7x2uXt4+mZDOSvyxtXHCdnzW2LaPi39g/SP2hNF8KeIrn9okatYaDdz2zaDFe3rzTQgK/wBpkkeKR3jhfMfliRggKu2F3At+jdlpujx+Xe2UETMw3LOAHdgw+95hyzZHck5rM0V/sOqajoD8Kjfa7f3huWYsPcrKH47KUFX30aGKRrjTHNjM5LN5YzE7Hkl4z8pJP3mGHPTcKdaq5yc3uxRjZWRsVVkjW7V43/1Yyv8AwLuR9O3v+FZc2o3dsVtb6LY0mf38WWjCjqzD7yevIKjjLHmtqHyjEhgIMeBtIOQR2wayGcjYR3EtvBq9hj7d5MXnxk4WcBeh9G7ox7HB4NdRZ3kN7AJ4cgZIZWGGVh1Vh2I71zFpdQ6bGmo3Eiw2vn3NvIzkKkYWZxGSTgAfKE/FRW5NAS41PTSGd1BZQRsmTtz03Afdb8Dx0bA1aKht7iO5iEsXQ8EHggjqCOxFTVIBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/1/38ooooAKKKKACiiigAooooAKYafTDQVESiiigoKKKKACiiigDhfGXxL8D/AA+ksE8ZatFpf9ov5cLS5Ck8DLEDCrkjJOAOp4BI42zs5Lrx5d+N9FvLjVYruMRQ2yDFsgSMJkzswQIW+cooZ+d+DnA5P9oL4MeHPjdZ2CaxfXenR+HGkd7izZAzRSmP7RHiRWUkIgYNjKsAOckV7BYaHd+DtJsdK8Pt9p0zTYYoIbe4b50iiUIoSbknCjgODk8blrb3UlbfqIkl0fxFq/8AyHdQNpbH/l301mjOP9u4OJSehBjEfcEEVoWXhrw7Y6bLpVjZxR2r5LxKu0FmHLFRj5zjlsbvertjrVlezGzO62vFBZreYbJQBwSByHUHjchZc960pY0cDcM4Ix6jntWbbGVNP0yy0q0Wx02MQQx5KqMkZYknOck5J55zWJ4d3XHhq2nl+Vr5WutwGQrXLGYcdtpb6cda2r+ZtPs57/dlLaNpGVuflQZIB68475rO8Oq+neHdLs7pCrW9rBGWA3LlYwD06dOcgClcDbtp1uYEnX+MZIBzg9xn2PFZviByNIniHBudluD6G4cRA/gWzWRca/4d0zVP7MuNRjtri7xLEAw53kqcjleWU8nucDpXnPxH8da9oGq2thDYx3NravDcTcsrz7W3AR8kDBA67ssO1VGDb0Fc6vS74N8YvEumk8x6DocoH+/daop/9BFZXxP8S6T8MNIk+ImtXK2mmaNvmmdjj93IR50AGeTLgPEO8yqufnArj/8AhJtK0L9onxpqOt3cdjp+neDdHnuJpmCRxxxXuouzMTwAA9fKBPiP9vLXtS1G3D6V8KPCsrrp6TAp/a1+g4eXuFAPPXYpCgbmcjeFK7u9kUdf8C9C139qT4hQ/tO/FKIQeHdClePwZ4edw4tRnnUbpBkee+AY89OGHyrGx+92fzPEEUa/8u9q5f8A7bOuz/0W1fP/AMBvBmq+FtR1H+0lSzK20KLbqRmSNzujmwvy7cKVGOh3DjHPvFg5n8RatMPuwpbWx/3kDyn9JVpYhrm916Eo6Gvy0/bvSH4UfFv4KftBIcWOm+ITZ6kiMVkW3voVhupkC/OSYIwMj7rImMFs1+j/AIo8feBfA9v9r8aeItO0CEDdv1C7htVx65lZRX4C/t2fH/Sfjb8X7DT/AALrdvqnhXwvAsNtLA++3ubi5CvPKCM5K8IPTacdTXTleFlVqqK2M60+WNz9MPjd+0/o2jeFR4P+E2qaf8SPEfi6GW30uC2uVkex+Ubrq/aEMqwQbg2W2SFgEAYlnXmfgz4i+F/wZ8L6x49+PHiy1stYmu1u9S1HUZVE2ragVJEqp9+QQL8ltbRIVgTlQWYtX4dap4x1TwXbP4k8OajLpWr2aOEngba43DGBjqrA4K4IIyCDyK/W/wDZm/YA+G8/hzwz8f8A423V18UNe8QWFpqrW+oh2tbWO7iWdB5BZjcNGGwyyEow+7GCAG9DNMDSw/7tSv8AqYUKzqK7R7Np/wC158V/2grqTS/2Qvh7JeaQHMb+MPFIksdGjwcFoIE/f3JHopVlP3kxzXz78V/+Cf2ufGO48Q6z4w+LckvxJ0mWFpdQubSGDSXsrmISiFLWEq8CpO8u1/McnqyknI/YG1bSdO0mJ7LybbTLeFTH5e1IEhVfl24woQL0xxivhT4c/DT4heE/iBB4p8XwtDZQXTz3GqSMGEySbvnZcmRQ+fm3qNmcttxXk0Z6vlfKbSPz/wDBH7LPir9hnXNK/aG8XarD4o0K4d9C168fTXVNJsdUaOJb+2gkl8yQRuPLlaVF+WXCRuMk/qHB4o8PfCbXSPs8ni0zwxSx61NOJrz7NMu5IxIwKsgGCvllFKkcEgk/RvjjQvC/izwZrPhvxjAl3oOsWktrdxNyJIZ1KMoxzuOfl285xt5xX5e/sk64fAnxK1r9i743Zm8SeEU87wbqN3ybzR8GaCEgHY8kCncFywCh4xgQ8kXzpuW47dj9UbLTJ2nXUtZdZ7wZ2IufJgB4xGDyTjguRk84Cqdo+Vv2pfi9efs0eGrv4heHbZNRv/FbDSrLTCwBm1yWMrZzqpI3LhcTgEZRVIORz9ZaZfrqFkty6+VIpZJUJ/1ciHa6k+xHB7jB6GvinwD4Zs/2oPizqHx78WW4vfAPhuO80PwXaSjMV15mYdR1jb388gwW7f8APJS+AWU1hT3vLYpos/Cf9kybwH+zlrfgi+1EXHxI8Xk63quusd8jeIw4uracPjLJa3KoU7EqzYBdq9j+Gfivw38efAWma74i0e2ubfxFpyrf6ZeRJPFBfWEzwX1tJHIGUmGcmM5HO3NaPw11y+8P6xd/CHxRO0t/pCCXTLmQ83umk4Q57yRfcf1xnnk18X6h4w8U/AX9rTxL8O9AVG0fx6reKNIgZN6vfziKPVrRSOd0jxR3O0YI3s38XOiTk333Eez63+w18H9K1O48YfB7UtW+D2uEGSS68NXrWto+3kCeyl32zxDugRBXAeGtU/a0M9n4g1qx0740eC9FupPsc1oY/D2rXzxYC3jWsxeznWMhhEolg3N8+Mhces6xqnj744eJbr4cadd2uk+GdNK/25dWYed5G/58o5mKKSSMSEJ2Izjhvoix8D6da2sNndXd3eQ26LGkbTGGFUUYCiG3EUe0DgAqaTqNL3tQPmrxX+0t8LNU0yJNbkufB3inR54r1dF8S2raZeXEaZS4ig879zdb7d5VH2eSUHNYvhXxpD+zp41074baiJ7n4U+M5xH4Tv5EaNNJvp8v/Y0rzbB9mkGWsXz8ozByFSvrPWvCPgO68O3+keINI059Dnjb7XDcwRfZmjA+YyBxtwBySenWvxn+NU+kz/szeIPB3wcXVdetfD995OtJZO9/oTaRZzh47q3SfzIlKnyjusNu0Bnkwuc6UIRm1HZMUnZXPprxRpPjYfFGz8B+AUbQte8WSXkizWZe0isdNjbNxfh4htfyw6xwF1dWlkjUrtzj7L8K+GviB4D0Ow8M6CmmXuj6XBHbW0E0kkM6RRKFUGaKHY5AHeJSTyW5zX4N/wDBPv4jfEbUvjL4km+H+jan4l0aDR1/tH+zWsTdWzrPm1eI6jNCjAM0oeNXyys3yk4r9rbD47eBUsZZviBe6/4Vksxi6i1nTriwgikAB2i9ht0gcnIKhJyWBHHIFaY2kozcIO6X4k05XV2cv8V/jV4m8H+NND0630SK21KG3kmlNzJuR7adihjXymIOXiDZyCCo45Ir3DQvH+oa5oVnrsOkziG5jV2OyJEUnqA888W4Z4BA561yNj4M+GPxbsYvG3iD7PrlrGCbXF+9zFbQj5iJJElZWdvvOCxVeFGcFmb4D+IfwtuLXUtI8GaxpOp/2NKlvaS2EsM/yT5EMX7okl4iChUZYoqvzvFYNLk0jqh9St4L1D4r/wDCWatqOrfZLnTJw6RRS3i7tyyfJ5SW8UzBVXcCCec5yetepebq8bGcyJZs5ywjtXKsx68vIoYn12Bj0rctnv54Y4bKI2dsihRJOMysoHBWPtkd3IIPVK0oLKKFvNJMsvQyOct747AeygD2rKUrvYpH5+2njnxX8Zr34o/D3xr4b1nwbo/hTUY57XVbm2Zra5aIkbTF5cZkDiMTDymdQJFLH7pf6u+GGo6FYeBtJtNH1qK+tYY2UNcq1szOHbeFD4YKr5UAqcYxn07pLC1urzWtJv4hNBe+VM6noUkjEO0++YSc+4qh4b0m18O/adE0SMQ20BWZIMkqBNkNhmyQxkR2Ocg57ZyNJ1U1ZK3kSkbzSbX+1ohjdgNwOCkg7HcMgH0Jxnoe2NKKVJkEkZypqjDa6dIWaKBYpR97auxwT7rg8+oOD7ivjZv2RJF+LHjP4h2vxC1ZG8VPDOLFgGt4VDlmV8OrTBSAIclfLXj5utRCMXe7sN3PtuiszSfMhs0sbh2kntFWJ3Y5Z9owHP8Avjk++R2rTrJjCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//0P38ooooAKKKKACiiigAooooAKjPWpDTD1oKiJRRRQUFFFFABWTe3paYaZYSL9scZbGCYY+7sP0UHqfUA4tX17Fp9s1xKC3IVUXlndjhVUHHJPAzx6kDJrznwz8PrPwj4h1jxlNfu91rRaS4DkeTEzkMwDEAlARhc4wPrVRS6gdbq2ns/h/VNM09cs1pLDGO5kdG/Ulh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raMEWNlgceSjZLyDvNJlz/DtBIqX3YjmYItT8R+KNXsLQTaNoXia0Fz5jx7bq4ltwttNIitzArRtbqC43kKSqocPVL4PeC/DCtrfiyPSIIby71C5t1O3d5aW4W3lRd2eTNHIWPViTkmuQ/af/aZ8A/s2p4X1fxhb3V5c389w8UNoI95toYwlwWaR0AAMqMq/xso6YLD1j4M3UN54A0i/t23RavbQ6vHxj5dUH2ps55yZHcmtZQkoKTWj2Emm7HpK2zwf8eshC/3H+ZfwPUfqB6V4T4N+F3wh+D/ivx5470zSINA1DxDLHf6lemWVlaN9xwu92WINMJWKRqgYsOCcY+gq4TxhpOmatBf6XqsAubXVNPlSWM5GfszBo9pGCCDITnPBAORisYy6DNJPEEGpaO2raC39o2jRNIsqDIcAH5U6bmyMY4wcgkEYrM+HmvyeJ9El1i4sZbGd55EcSncX2YwythcrjA4AAINdHoWhad4d0u20fSoRb2lopWKMEsFBJJ5bJJJJJJOTWzTk1rYQUUUVAwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//U/fyiiigAooooAKQnFBOKZQUkFKBmgDNPoG2HSiiiggKKKKACviTSv2vvDXjX9pq8/ZetdLvbK4tnvIXvo5MPJLZRGWVWUANBEyqwWUMWYlduwsDX23XMy+DPCc2sz+Izo9qms3UaxSX8cKx3jRp91TcIBLgdhu4rWnOKTur/AKCaY3U/C3h6+sbHRrnT4WsoJcxxbBtQhWIKjtzyfXvmtYXgtCYdRdY8AlZWIVHA5PsGA6j8RxkDnbq/1nw/Oj6lFJq2nIGPnwR7rqLoMyQRj94AM/NEN3IHl4Bes/xn4f0P4p+BptPt70z2V3tmhns5FYO8LblwfmVhuXBH8iMie1xnoDSquMfMTyAOSf8APrWFpFs08NzNcnia5nJQdDskMY3H+L5VHHA9Qal0LTIND0Wx0zTma4tbWCOONnIM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D/eIA9qsdA0XTdHh8P2VlFHp0CCNINoMe0c8g5zk8knJJ5PNVOpGy01EkVPJ0fwT4WkXTrZLTTdGtXdIoxhVjiUsfxOCSTyTyea8j8M+HZNM8QfDfS7wES6fomrXsuf+fyR7JJD+dxLWd8TvHFh4dupPAmmi4uTdQobuJm3RR28jYZEZsuGdAQBnYoI45qS08cax4g8eSaloOgybbfS4YY7nUHNpaKLqaRncMVaR1byUC4jG7B5HBqIwly83Qdz1ldJls/EN/eaIy27zRQSywt/qZnZpQScAlHOB86jnqytxie78Q+HplbSdZ2rcyAbrGRfNmYZ4KxIGLrnkMoI9wQcczBouo6prbW3iXxH51y0AeWx01vsaIqH5dxVmuCDvPPmKD/d7DtrTw5oenW/2fTbKOzAO7dCoR93TcWHJY9ySc985NZuwHyT4msfjDefGS1ttEa8GkRyWk9ik03+jxQAZc3C7ycsySffy5XgdMD6T1i48Xyiws59OsWE13EcpeSAnyMz/AHWt8D/V/wB6vHvG/wAevh38JfG2nWXxAv5IrzxRfJp+nPFC0geO2AhzIF+7i5uGTIzk5OAAce3z2uo61qVgupqbO1j82cW6NmRtqiMebIpwP9Z9xDjjlmBwNqnNaN1oZ6XZZXxDqU7vb2ujzySxna7rJA0KEcEbjIpYjuoGexxkGuZ8eeMfDXhHwtc6l4ws57mGcrbtA0Cy+a0vAQAnysdyC3Qc5PX0oeTaxpDEgVVAVEQAcDgADoAPyFZmsaBpXiTTpdK8Q2kd9aTY3QyDcmVOQfqDyD1HasE1cCHwt4g0zxT4fste0dWSzu0JRXUKy7SUKkDIBUgjgkccHFdBVPT9OsdJsodN0yBLa1t1CRxxjaqqOwFXKUrX0BBRRRSAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1v38ooooAQjNAGKWigdwooooEFFFFABRRRQAUUUUAFFFFABUMqsCJYxll6j+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SQrDH5ewzSOFLSJlWZo+p3YyKsPE3iP4kRzNzY+FImCjqDf3aDcSD0MduwCMOvmyL2NelVySkang+oeF7aW3ttJW+lk0y/f7Tpbui7I55AS9uyqqYDbi8fHyjeuAFAPWJpb+C/Ca+HbOUma7kMMVwvy7ZLhiXk287fLTc/UjCEkg1q6rZ26ySaPduYrO6drxHU4aF4syOyk5wVl2yr1yS3G0YrybwX8btK8d6tamPTrqSa3jk+yxwqrfaZWwrSAMyiLagbG9sBWYFgetrmktOmotD26/tbcWln4cs0CQTgRlV6LaxAbx9GGI+uRvz2rauxatazLfbPszIwk8zGzYRht2eMY65rz/AE+28WardT6nF5Gi27/uUj/4+JgiMdxBx5cTls5wJVIAOMjJ6az0LTPNWe8El9dxndvu28xlbP3kT/Vp9Y1UcVk0My9L1jddLp1uJNRe3jcRzj7ksJK7XMjYVip+VypY5G7HOK8r1L4Qw6v8W/8AhOLq+I85rd57QJ5iAwR7dokJX5CqpuXZ1k688+738X7yK8VtsluHIPTIOCyk+hC/gcHtXkXwZ+NHw4+NI1rUfAOpnUG0idYLkNG8ZQzAujDcBuR1XapHUJ0HStIcyTnH+rku2zPcKeKaKfWASCiiigkKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsN7CfTpXu9IGUclpbUnCOTyzRk8I56kfdY9cEl63KKAM+O5h1G1Z7YkshwVYbWSRcMFYHkHpwe3PQ1NER5zlfuzKrj3OMH9NtQ3NiJZRd2z+RdKNu8DIZRyFdeNy88cgjJwRk15j4e+JMPiDxzq/gSbS57KfQxmSVvmSVSVHy8D5CXBU/xKMkL0q4xvsFzrPFem2Oq2EepXtvHOmjTRX0JdAzBrdxIzIT90lAygjrn0rsqgY21yjwMVlR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QeIPifBY/EfRPhxb24u5NSRZZXy4aNGLjkbdg4QkhmBIPA9e18H/AA98C/D+K+g8C+H7Dw/Hqdw13dLY28duJp34MjiMDc2OMnoOBxV+bwl4cufEMHiyfT4n1e3j8qO5I+cJzx6HG44JGRk4rpAKqTVlYkAKWiioJCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9H9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsHxNFqcuh3f8AYsSS6iiFrcOcASdiDkc4zjkZ6Hgmt6immBxvhiXxHPoNkvjaGKLUWBEhjUFSdxC5GWVWK4yBkZPGOg0rfTIIpbqIyyxgP5iBZCqqrjJ+UfJy4Y4IrfZQwKsMg8EHvXy5aW37TFv+0XrF1qCWN38IBYILSCN4ReNcbUwAGCyb1kMhbzJPLMeNvzYA0ir31sK57bqfha08SWpstQjin04sG8uaEEyMvRv3ZjIUZ47nvxwfPPBmnfETwJrOsN4omivPC81w/wBhitxuNlEzkoFXaG8vaQChLEEfKcYB9qstUsb9mjgkImQZaJ1Mcqj1KMAwB7HGD2q8yq6lHAZWGCDyCDU872Cw2GWK4iSeB1kjkAZWUgqwPIII4INYsC+XDfQr0tblpF9Tu2zkfiWIqmbS48PTNPp6mWwkJaSHPKEnJZM9M9x0PXg5J1dLmhuXvLiBt6STAg9OkSAgg8ggjBB5B4NSMZcDdrtjnosFw347oh/ImuJX4aeFrnxtdfECOAx6wJFCyhiYmaOJU3NHnBI5UkY6diM12sa41G0H/PKCdPyeIfrjNVory4niFrpIVpWJaWVhmKEuSxHGN7jP3QRjqxGQDSbWwHyL+2h+0L8QvgR4J0yXwT4bGs32tTyW00oinuUhjKhUxHbskivK7BUZjtDDHzEivqXwq8/ibwb4e8Q63pT+HdVutPtbiW0ztmsJZoleS3JwM+Ux2spG0leVpmuR6fpOnPFGr3l48ttcS9HmlWKZWLOeFVcKQM7UH3VA4FX/AOwrq9+bVnWSDqLFSfs49NzHBf6EbOnyZG6rlNOKVrW69xJa3PmTxL478ZJ8RbC7aUSaHY3LRzPbRddP5SacyoGbYqEysVO3KjABAI+gLm4sPGVjFonhq5jbQpFVLm5tXBWSMjP2eF0OBuXmRgcqvyr8zBk4b9o34eTfGL4U6t8LtL1KTRNR1hYzFcJH5nkpbSpK5eMFd8bBdhUMNxYLkDJHK/sxfAqL4KfCPTvBtxr82q6lZXF482oRJ5CtNJO+5IoS0gMS4wgfdnJbCliBpLkcFJaPt+txK9z6kgghtYY7a2jWKGJQiIgCqqqMAADgADgAV83ftPeBb74kfDVhoTkXnha8i1uIhSwmNkkglt0xks0sTvGMcZOCe1e5eZq8fy6rF59sP4rcEOR/00jyTj2QtnuAOKtahrdhpmhXuuKGuLbToJZnSAbnIhQsUVf72BgLwc8VhFtNNFM8lU3Hh34aaXpVnMNQ1bUIILPS5pCZ7eSe5H7uQxkkFIFJlZepijYqTg49L0TRdF8AeFbLQtHhKWOlwxwRIMGSQgBRuPG6SRurHlmOSec1+c37Gn7Wll8f/iM/wuvNBS0t/C2iTXelNDKZ4o7ZZobbZcblA85IpESNwBlfNyPmr9Ioo5JbwXL7pbO1LCHPLb/us57sAMqvf7x+YEEbYmlKE3Ce5MJJq6ON8f2vjmw+GPiu78BLHP40uLC5ls95XYbvyj5SKZPkwvCpv+Unl+rV8H/sEzftORf8JYfjToOsQ6Cr2S6aurKI78SQLIrqizskn2ZR5ZTPy7h+6BzIR+md3IJfKtYzu+0HnHP7teWP0PC/8CqxCMs8x6ucD/dXgf1P40o12qbhZa/f94cutypa6vp93III5dkxyRFKrRSkDv5cgVse+MUlxo2nXMpuDF5c5/5axExyf99IQT9DxV6e3guYzDcxrLGequAwOPY15/4vu9Yi0DWNN+HkoPiL7LMloZTvtLe7aMiAzlgwVVcqTGmXK9EI5GKWpRU8fXfjbSNAmg8G3AvdUmGIhLEHljTPzyAqArFR90MhycZzzXCeFfilDoVx4b8AeNbGfT9curctyipF5ZkZYWYs+dz+X83BweWxniH4A2P7QWh/D8TfHyTTtU8VyTzM0sE+1ktc/uYm8m3EbOOTlAM7gDlgSfabcFp/7Q1PSJBc4I80iKXy0PGxNrM+3HXA5JJxzgauyvHfzF5li7t0SdNcUiQbNkwXlTDyQy46lCSQe6lgBkjGyrYQljkqOo7jsfxrIWLSd5kh3WTMck7XgDH/AIEFB9a8K8afE+3tPE0Xwl8C+KNO/wCEy2i4FnOV8wWuwyMMsPL+Vfm2Z3+XyBjJqYU3LRD5rHterIl9C+mStttVCrcHs7PgCL3ByC/qMLg7jjbHnz/dzDH6kfOfoO348+wryhPGdxY+PdJ8EDRbi8ju4DO+pAsYFc7y3ljZgrkAs24HkZz39kqZJqw1IhjhSJdqDA6n1J9ST1NSYp1FQHMFFFFAgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAKl3YWl8qi6iDlDlG6Mh9VYYKn3BBqssOoWf+pk+1xD+CXiQD2ccNgcAMMk8l61KKdwKsV3DM3lMDHJ3jcYb3x2I9wSPesb7K2m39zc2WFhdUkkQnCk4K59sKoAPYcH5cbegkjjlXZKodfQjNfMVv8ACj41w/tFap8SD8QFfwFcWCQ2ugSxzTLHOEjXLRmRY8K6vIsineS20jaMm4JO93YTPYLnXdKvdak0o6jFZyywArE0ipcybyQ21c7lUbRlhyRyuBhq6uOKZ4lt7JfsNsgwCFAfH+yp4Ue5GevA6187eLPhT48vPizoPjzSbm2bT7SRJL2JG8t5Gj2rlEdWwPLG0L5w+bnODgfQYvHPFys9u391o9y49S0W4D/vse9OUVZWYIbqVpaWWh6gkSiNXhlLMxyWYoRlmPJPuTmrdzqkFvC0yo8wXGBGudxJwApOFJJ4AzyeKxdd1bRNI0HUNZ1S9s7aytYXaa7nmWOOJSMZeRyQo5xksKs6Zq+neILe213T5VvNNmQSWk8DLPFMHHEqvGWDKR90jggk5ORieV2uMqyaVq9/Y3oaRdPvdQjZfPUmSSDKkIqAbQDHuJB3EFsnHzVxnwx8L6x8PbG58Oa1qD64xcXS3JDb1Eg8soqMzkqvl5JBzlumMGvWFu7ZmCCVQ542k4b8jzWfqk1tp7wavdypBDb70lkkYKiRyYJJJ4HzKvNCk9gNVJElQSRsHVuhByDXOajb/wBq3TWdgzW7phbi6iO11HURqw6sevOQo5xkipXuI79VfQJ1b7QoczxEPFsYcMCMqzEdCOg5ORhWu21rDHEttKuxVziPOUPckk8uSeSW5J5IzSA+V7jwzZ/BzXbS4+DfgrTNPg8SiKPVJ9P09Ld7qUMfL3ywhRv+ZsyHOWcHA2nP1hHc20SLGVNuqAABl2qMdAD938jUJWC509bb/WCSMD5DyOOCD0GOoP5Vj6jc3KaSzXLr9rci3RB/q/OY7QzDqyAfOw6bATt4qpO/QDh/GereNn06bUvhlZx6he/aktzv2+WtuhYSum9kUuZRtODjaMnkCvQYta+xWVsNaga2u3jXMcamQFwBvCbN2VB9cYHJwOaktrKOK1hstMj8iGFFjEpyGKqMDaBgnp1bjocNV62sEtWaSNy8r/eeT5mOPfg49B0HYUrq1gM9VudYUvPP9mtf+eUMn7xu/wA8qH5f91D2++QcVpWtpBAiJbxLDDEMRxooVVB74HAz/nqa42WHxrL46QvFbt4aEPLYXzQ4XIwc792//gO33qL4jaH421nQYrPwDqqaVfLcxvI8rMA8IDbkDhXZTkqeBzjHc0W1SuK53e3z5Qx/1cR4Hq3r+H8/oKe08akqMuw/hXk/j6fjioLS2nS0ghvZfOlRFV2UbVZgME7R2J7VcVVQBVAAHYVLGVj9rl6YgX/vp/8AAH/vqvM0+CHwtX4oD40yaBFL42Fv9l/tN3kMnl7dmRHu8oPsGzzAgfZ8u7bxXq1FCk+gBRRRSAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//T/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAOA+J/w08LfF7wNqnw+8ZRSSaVq6IkpgkMUyGORZUeOQcqyuisOoOMEEZFW/h14A8NfCzwRo/w+8IQvBpGiQCC3WWRpZCMlmZ3bJZmYlmPqeABxXaUVXO7ct9AsNZVdSjgMp6g8g14P+0T8OPHPxF+E+reEvhVqtv4e8QXbQNFPOXjgZY5Vdkd4VdkyBwwRiCMYwSa96op06jjJSXQTV9DgPhX4T1TwN8OPDfhLXbxNS1XS7GCG9uo1KJcXQUedKAeQHk3Nz69B0rpfEehWvifQdQ8PX0kkVvqMLwO8LbZFVxglSQRn6gj1FbVFS3rcZy/g3wpYeCfD1r4b02aWe3td215iC53sWP3QoAyeAAK8S+IH7PV546+O/gn4zx+Mr7SrbwjHtfSIEBhu3BkIbzN48veJNso2N5iKqgrjNfStFXGrJNtPV/qKyCiiisxhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/9T9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9b9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9f9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9kKZW5kc3RyZWFtCmVuZG9iago5IDAgb2JqCjEwNjc3OAplbmRvYmoKMTAgMCBvYmoKPDwgL0xlbmd0aCAxMSAwIFIgL04gMyAvQWx0ZXJuYXRlIC9EZXZpY2VSR0IgL0ZpbHRlciAvRmxhdGVEZWNvZGUgPj4Kc3RyZWFtCngBhVVbiBtVGP6TOckKu87T2tUtpEO9dCm7S7YV3aW0mluTtGsastnVFkGzk5NkzOwkzkzSC30qguKLq75JQby9LQiC0nrB1gf7UqlQVnfrIig+tHhBKPRFt/E7k2QmWWqbZc988/3f+W/nnxmigbVCva77FaIlwzZzyajy3NFjysA6+ekhGqRRGiyoVj2Szc4SfkIrrv2/Wz+QTzBXJ+5s71dvuRsscksl8t0Hvla01CXgE0SBs2rdtIkGhsFPH7frAoschk0kCPyiwOU2ho2GF9v4NUeTz8WgOQssq5VCEXgFeHyxhy/34HYOUMBPkhvc1FRF9CJr1kqazh1De7mHuUd5N7ikN1Cz89uBdciqzh3GdQy1v1IsxAWeBF5RC4k54EeArzW1hUwH367b0RzwY0T+nY3qfAR4N3CqZB6cB4Yfv1lppLr4nVOV/LPgt4H/xljMHOnsXVOtGHpJO8HfrvC06G+ISFI0O50Hhh/pgFnLCT1ykEpFHk8AjwO/Xq0dFjnAp/SZ1ZwTvMhn7VQlJvIU/OWXCoeywKPAv3I9KfSIJf1bt7OdHFjI0DMiLmKxOLeceuGHhexKPgUecZlum/nOXrZc0g6mO/pPKmZK8GLvtbruzChyC/jNRk7UjliByYKZSALDZyDLjXnRT4GbtOArEKcaLWJVyaBNUihHSYriWicTlhJppIPhsHIwHHddzYSzz6IqeI2ajs3CmnWU7Z1drUJlsAZdd7QqxUIfUQOeKvQH2IrrU6EY7hrgyv/jp53LjY6fGhthYbYX//vYLNvPptkMKewp9jQ7wOJgZ9g+13cWe7oViXxuIErbz8uIyB3dAmq/iBptKmD9BYoaWa6Hvq4sjzbGPMsZ8wVNvfLG3z290rCz6iom+jp65F49D/wWuB5Yxboe2HB9KIGfAhv4W0dvvFpqnr3TZXFSGk601qfbehZdVQSV6s7OJXRBQ828p+aJXh+XTn/5oBdtlZ17/urQpdMlY3nUY0UX+KuZWxk6M+6x4R/Df4ZXw++FPwz/Lr0tfSp9JZ2XPpcukyJdkC5KX0vfSh9LX7j6u82Qe/YkMhdzJfIW09WtsLfXmFg5Km+XH5bj8g75UXnWVSnyiDwlp+RdsGx3z82bb6W3cvTlKKJ1+3PnWOJZ0VxPOAPf/ZgAzYvYNwPzyFij4/Bpot9i3gw6CW3vk9epiIXYFEtvme5pMfNd38FEMB6MkBLcHZwJTgUPCdx9loO7YJvBmujNDfPhKvoq5TY/Ib4nFKvVT5pauWIre8LhJ5UIPn1cSRvq5LhS0HXFMVmKyS1uNnlxksR3U+wjuplzvoe+bVc8zn6GaP9fePd973HHGkQrFtHI4x43hnflA+8SnXtCbZjNtj/y+b4jskp79zj3vqEo3l8/t1o38R4beIto881W65/3W63ND+B/g+iC/h+gn3xVCmVuZHN0cmVhbQplbmRvYmoKMTEgMCBvYmoKMTA3OQplbmRvYmoKNyAwIG9iagpbIC9JQ0NCYXNlZCAxMCAwIFIgXQplbmRvYmoKMyAwIG9iago8PCAvVHlwZSAvUGFnZXMgL01lZGlhQm94IFswIDAgMzg1IDEwNF0gL0NvdW50IDEgL0tpZHMgWyAyIDAgUiBdID4+CmVuZG9iagoxMiAwIG9iago8PCAvVHlwZSAvQ2F0YWxvZyAvUGFnZXMgMyAwIFIgPj4KZW5kb2JqCjEzIDAgb2JqCihNYWMgT1MgWCAxMC4xMi42IFF1YXJ0eiBQREZDb250ZXh0KQplbmRvYmoKMTQgMCBvYmoKKFBvd2VyUG9pbnQpCmVuZG9iagoxNSAwIG9iagooRDoyMDE4MDgxNjE4NTc0MlowMCcwMCcpCmVuZG9iagoxNiAwIG9iagooKQplbmRvYmoKMTcgMCBvYmoKWyBdCmVuZG9iagoxIDAgb2JqCjw8IC9Qcm9kdWNlciAxMyAwIFIgL0NyZWF0b3IgMTQgMCBSIC9DcmVhdGlvbkRhdGUgMTUgMCBSIC9Nb2REYXRlIDE1IDAgUiAvS2V5d29yZHMKMTYgMCBSIC9BQVBMOktleXdvcmRzIDE3IDAgUiA+PgplbmRvYmoKeHJlZgowIDE4CjAwMDAwMDAwMDAgNjU1MzUgZiAKMDAwMDEwOTA0MCAwMDAwMCBuIAowMDAwMDAwMjgwIDAwMDAwIG4gCjAwMDAxMDg3NDQgMDAwMDAgbiAKMDAwMDAwMDAyMiAwMDAwMCBuIAowMDAwMDAwMjYxIDAwMDAwIG4gCjAwMDAwMDAzODQgMDAwMDAgbiAKMDAwMDEwODcwOCAwMDAwMCBuIAowMDAwMDAwNTAyIDAwMDAwIG4gCjAwMDAxMDc0ODMgMDAwMDAgbiAKMDAwMDEwNzUwNSAwMDAwMCBuIAowMDAwMTA4Njg3IDAwMDAwIG4gCjAwMDAxMDg4MjcgMDAwMDAgbiAKMDAwMDEwODg3NyAwMDAwMCBuIAowMDAwMTA4OTMwIDAwMDAwIG4gCjAwMDAxMDg5NTkgMDAwMDAgbiAKMDAwMDEwOTAwMSAwMDAwMCBuIAowMDAwMTA5MDIwIDAwMDAwIG4gCnRyYWlsZXIKPDwgL1NpemUgMTggL1Jvb3QgMTIgMCBSIC9JbmZvIDEgMCBSIC9JRCBbIDxiODZlNGE3MjU2ZDE3ZDg4MDkzNjhlOGM3MWMxZjg3Nj4KPGI4NmU0YTcyNTZkMTdkODgwOTM2OGU4YzcxYzFmODc2PiBdID4+CnN0YXJ0eHJlZgoxMDkxNzAKJSVFT0YK";
const std::string _NOMAD_LOGO_BASE64_ = "iVBORw0KGgoAAAANSUhEUgAADdcAAAdiCAYAAADNSTX6AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAC4jAAAuIwF4pT92AACAAElEQVR42uz9349cZ5ondj4nMxQ/JFLMJDNJVae1pGF6gb0SZ42FYXgAxRgWMDeGcu6MvGlp/oCp8grwZXet74muwQJerG+oBhZaAzams7xYwAAH7hA8U42u7doi3asujUuizhGdmqSYYmSySKXIZubZiwyKFMUk80fEeSPifD5AQsXMiPM8L1EneN487/e8WVmWAQAAAAAAAAAAAAAAAAB1MpO6AQAAAAAAAAAAAAAAAAComnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAAAAAAAAAAAAAAUDvCdQAAAAAAAAAAAAAAAADUjnAdAAAAAAAAAAAAAAAAALUjXAcAAAAAAAAAAAAAAABA7QjXAQAAAAAAAAAAAAAAAFA7wnUAAAAAAAAAAAAAAAAA1I5wHQAAAAAAAAAAAAAAAAC1I1wHAAAAAAAAAAAAAAAAQO0I1wEAAAAAAAAAAAAAAABQO8J1AAAAAAAAAAAAAAAAANSOcB0AAAAAAAAAAAAAAAAAtSNcBwAAAAAAAAAAAAAAAEDtCNcBAAAA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AAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAGR3MdAAAAAAAAAAAAAAAAAIOjuQ4AAAAAAAAAAAAAAACAwdFcBwAAAAAAAAAAAAAAAMDgaK4DAAAAAAAAAAAAAAAAYHA01wEAAAAAAAAAAAAAAAAwOJrrAAAAAAAAAAAAAAAAABgczXUAAAAAAAAAAAAAAAAADI7mOgAAAAAAAAAAAAAAAAAG5/8Hu/TV8771xv4AAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDMtMTlUMTk6MzM6NDMtMDQ6MDC+Z2xKAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAzLTE5VDE5OjMzOjQzLTA0OjAwzzrU9gAAAABJRU5ErkJggg==";

// CITATION INFO
const std::string CHULL_CITE = "Use of this data welcomes reference to the following publication:"; //Use of this data welcomes reference to the following publication: //cite:
const std::string CHULL_AUTHORS = "C. Oses, E. Gossett, D. Hicks, F. Rose, M. J. Mehl, E. Perim, I. Takeuchi, S. Sanvito, M. Scheffler, Y. Lederer, O. Levy, C. Toher, and S. Curtarolo";
const std::string CHULL_TITLE = "AFLOW-CHULL: Cloud-Oriented Platform for Autonomous Phase Stability Analysis";
const std::string CHULL_JOURNAL_LATEX = "J. Chem. Inf. Model. \\textbf{58}(12), 2477-2490 (2018). \\href{https://doi.org/10.1021/acs.jcim.8b00393}{doi:10.1021/acs.jcim.8b00393}";
const std::string CHULL_JOURNAL_TXT = "J. Chem. Inf. Model. 58(12), 2477-2490 (2018). doi:10.1021/acs.jcim.8b00393";
//const std::string CHULL_JOURNAL_LATEX = "submitted \\href{https://arxiv.org/abs/1806.06901}{arXiv:1806.06901} (2018)";
//const std::string CHULL_JOURNAL_TXT = "submitted arXiv:1806.06901 (2018)";
//const std::string CHULL_JOURNAL = "submitted to Comput. Mater. Sci. (2018)";

// LATEX
const double LATEX_PT2INCH = 100.0/7227.0;  //https://tex.stackexchange.com/questions/8260/what-are-the-various-units-ex-em-in-pt-bp-dd-pc-expressed-in-mm
const double LATEX_WIDTH_LETTER_STD = 8.5;  //inches
const double LATEX_LEFT_MARGIN_LETTER_STD = 0.5;  //inches
const double LATEX_RIGHT_MARGIN_LETTER_STD = 0.5;  //inches
const double LATEX_TABCOLSEP_STD = 6;  //pt
const double LATEX_ARRAYRULEWIDTH_STD = .4;  //pt

//CO20180419 - moved to aurostd::xerror and aurostd::xerror
//namespace chull {
//  aurostd::xerror::aurostd::xerror(_AFLOW_FILE_NAME_,const std::string& function,const std::string& message) : std::runtime_error(message),f_name(function) {}  // I/O or computer type errors (no entries loaded)
//  aurostd::xerror::aurostd::xerror(_AFLOW_FILE_NAME_,const std::string& function,std::stringstream& message) : std::runtime_error(message.str()),f_name(function) {message.str("");}  // I/O or computer type errors (no entries loaded)
//  string aurostd::xerror::where(){return f_name;}
//  aurostd::xerror::aurostd::xerror(_AFLOW_FILE_NAME_,const std::string& function,const std::string& message) : std::logic_error(message),f_name(function) {}    //errors in logic, unintended (and insurmountable) use of functionality
//  aurostd::xerror::aurostd::xerror(_AFLOW_FILE_NAME_,const std::string& function,std::stringstream& message) : std::logic_error(message.str()),f_name(function) {message.str("");}    //errors in logic, unintended (and insurmountable) use of functionality
//  string aurostd::xerror::where(){return f_name;}
//} // namespace chull

namespace chull {
  bool convexHull(const aurostd::xoption& _vpflow) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    ostream& oss = cout;
    ofstream FileMESSAGE;
    string soliloquy=XPID+"chull::convexHull():";
    stringstream message;
    aurostd::xoption vpflow(_vpflow);
    string directory=getPath(vpflow,FileMESSAGE,oss);
    vpflow.flag("CHULL::PATH",true);
    vpflow.pop_attached("CHULL::PATH");
    vpflow.push_attached("CHULL::PATH",directory);  //rectify directory in case it changes (to pwd)
    _aflags aflags; aflags.Directory=directory;

    //do this immediately, we don't want JSON-reader to bomb because there's no output
    if(vpflow.flag("CHULL::SCREEN_ONLY")){
      if(!(vpflow.flag("CHULL::TEXT_DOC")||vpflow.flag("CHULL::JSON_DOC"))){vpflow.flag("CHULL::JSON_DOC",true);}
      if(vpflow.flag("CHULL::TEXT_DOC")&&vpflow.flag("CHULL::JSON_DOC")){vpflow.flag("CHULL::TEXT_DOC",false);} //only one output allowed
    }

    //////////////////////////////////////////////////////////////////////////////
    // START Display usage, if requested
    //////////////////////////////////////////////////////////////////////////////

    string usage_usage="aflow --convex_hull=|--chull --alloy=MnPdPt[,AlCuZn,...] [chull_options] [--destination=[DIRECTORY]]";
    vector<string> usage_options;
    usage_options.push_back(usage_usage);
    usage_options.push_back(" ");
    usage_options.push_back("chull_options:");
    usage_options.push_back(" ");
    usage_options.push_back("GENERAL OPTIONS:");
    usage_options.push_back("--usage");
    usage_options.push_back("--print=|--p=|--output=|--o=latex|pdf|png|json|text|jupyter|jupyter2|jupyter3");
    usage_options.push_back("--keep=log|--keep_log|--keeplog|--log");
    usage_options.push_back("--keep=tex,log");
    usage_options.push_back(" ");
    usage_options.push_back("LOADING OPTIONS:");
    usage_options.push_back("--load_library=|--loadlibrary=|--ll=icsd|lib1|lib2|lib3");
    usage_options.push_back("--load_API|--load_api|--loadapi|--lapi|--api");
    usage_options.push_back("--load_entries_entry_output|--loadentriesentryoutput|--leo");
    usage_options.push_back("--neglect=|--ban=aflow:bb0d45ab555bc208);aflow:fb9eaa58604ce774");
    usage_options.push_back("--see_neglect|--seeneglect|--sn");
    usage_options.push_back("--remove_extreme_points=|--removeextremepoints=|--remove_extrema=|--removeextrema=|--rep=-1000");
    usage_options.push_back("--entropic_temperature|--entropictemperature|--entroptemp");
    usage_options.push_back(" ");
    usage_options.push_back("ANALYSIS OPTIONS:");
    usage_options.push_back("--distance_to_hull=|--distancetohull=|--distance2hull=|--dist2hull=|--d2h=aflow:bb0d45ab555bc208,aflow:fb9eaa58604ce774");
    usage_options.push_back("--stability_criterion=|--stabilitycriterion=|--stable_criterion=|--scriterion=|--sc=aflow:bb0d45ab555bc208,aflow:fb9eaa58604ce774");
    usage_options.push_back("--n+1_enthalpy_gain=|--=|--n+1enthalpygain=|--n+1energygain=|--n+1egain=|--n1egain=|--n+1_enthalpygain=|--n+1+energygain=|--n+1_egain=aflow:bb0d45ab555bc208,aflow:fb9eaa58604ce774");
    usage_options.push_back("--hull_formation_enthalpy=|--hull_energy=0.25,0.25");
    usage_options.push_back("--skip_structure_comparison|--skipstructruecomparison|--skipstructcomp|--ssc");
    usage_options.push_back("--skip_stability_criterion_analysis|--skipstabilitycriterionanalysis|--skipscriterion|--sscriterion");
    usage_options.push_back("--skip_n_plus_1_enthalpy_gain_analysis|--skip_n_plus_1_energy_gain_analysis|--skipnplus1enthalpygainanalysis|--skipnplus1energygainanalysis|--skipnplus1|--snp1|--snpo");
    usage_options.push_back("--include_skewed_hulls|--include_skewed|--ish");
    usage_options.push_back("--include_unreliable_hulls|--include_unreliable|--iuh");
    usage_options.push_back("--include_outliers|--io");
    usage_options.push_back("--strict_outlier_analysis|--soa");
    usage_options.push_back("--include_ill_converged|--iic");
    usage_options.push_back("--force");
    usage_options.push_back(" ");
    usage_options.push_back("LATEX/PDF/PNG OPTIONS:");
    usage_options.push_back("--image_only|--imageonly|--image");
    usage_options.push_back("--no_document|--nodocument|--no_doc|--nodoc|--full_page_image|--fullpageimage");
    usage_options.push_back("--document_only|--documentonly|--doc_only|--doconly|--doc");
    usage_options.push_back("--keep=tex|--keep_tex|--keeptex|--tex");
    usage_options.push_back("--latex_output|--latexoutput");
    usage_options.push_back("--latex_interactive|--latexinteractive");
    usage_options.push_back("--light_contrast|--lightcontrast|--lc");
    usage_options.push_back("--large_font|--largefont|--large|--lf");
    usage_options.push_back("--png_resolution=|--pngresolution=|--pngr=300");
    usage_options.push_back("--plot_iso_max_latent_heat|--iso_max|--isomax");
    usage_options.push_back(" ");
    // output usage
    if(vpflow.flag("CHULL::USAGE")) {
      if(!vpflow.flag("CHULL::SCREEN_ONLY")){init::MessageOption( "--usage", "CHULL()", usage_options);}
      if(vpflow.flag("CHULL::SCREEN_ONLY")&&vpflow.flag("CHULL::JSON_DOC")){oss << "{}";} //so JSON-reader doesn't bomb
      return TRUE;
    }

    //////////////////////////////////////////////////////////////////////////////
    // END Display usage, if requested
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Flag manipulation
    //////////////////////////////////////////////////////////////////////////////

    // address possible flag issues
    // get libraries to load from flags
    vector<string> vlibraries;
    if(!vpflow.flag("PFLOW::LOAD_LIBRARY")) {vpflow.push_attached("PFLOW::LOAD_LIBRARY","all");}
    aurostd::string2tokens(vpflow.getattachedscheme("PFLOW::LOAD_LIBRARY"),vlibraries,",");
    // special case, all
    if((vlibraries.size() == 1) && (vlibraries[0] == "all")) {pflow::defaultLoadEntriesFlags(vpflow, FileMESSAGE, oss, std::string("A"), false, true);}
    else {
      bool found=false;
      for(uint i=0,fl_size_i=vlibraries.size();i<fl_size_i;i++) {
        found = false;
        for(uint lib=1;lib<=_AFLOW_LIB_MAX_ && !found;lib++) {
          string LIB = aurostd::utype2string(lib);
          if(!found && (aurostd::toupper(vlibraries[i]) == "LIB" + LIB)) {
            pflow::defaultLoadEntriesFlags(vpflow, FileMESSAGE, oss, LIB, false, true);
            found = true;
          }
        }
        if(!found && (aurostd::toupper(vlibraries[i]) == "ICSD")) {
          pflow::defaultLoadEntriesFlags(vpflow, FileMESSAGE, oss, "ICSD", false, true);
          found = true;
        }
        //} else {
        if(!found) {
          message << "Incorrect input for loadlibraries \"" << vlibraries[i] << "\"";
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
          if(vpflow.flag("CHULL::SCREEN_ONLY")&&vpflow.flag("CHULL::JSON_DOC")){oss << "{}";} //so JSON-reader doesn't bomb
          return FALSE;
        }
    }
    }
    // get desired output from flags
    // give an error if input is not as desired
    if(vpflow.flag("CHULL::OUTPUT")) {
      vector<string> out_forms;
      aurostd::string2tokens(vpflow.getattachedscheme("CHULL::OUTPUT"), out_forms, ",");
      for(uint i=0,fl_size_i=out_forms.size();i<fl_size_i;i++) {
        if(!((out_forms[i][0] == 'A' || out_forms[i][0] == 'a') ||
              (out_forms[i][0] == 'F' || out_forms[i][0] == 'f') ||
              (out_forms[i][0] == 'T' || out_forms[i][0] == 't') ||
              (out_forms[i][0] == 'J' || out_forms[i][0] == 'j') ||
              (out_forms[i][0] == 'W' || out_forms[i][0] == 'w') ||
              (out_forms[i][0] == 'L' || out_forms[i][0] == 'l' || out_forms[i][0] == 'P' || out_forms[i][0] == 'p'))) {
          message << "Incorrect input for output \"" << out_forms[i] << "\"";
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
          if(vpflow.flag("CHULL::SCREEN_ONLY")&&vpflow.flag("CHULL::JSON_DOC")){oss << "{}";} //so JSON-reader doesn't bomb
          return FALSE;
        }
      }
    }

    //////////////////////////////////////////////////////////////////////////////
    // END Flag manipulation
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Gathering hull inputs
    //////////////////////////////////////////////////////////////////////////////

    message << aflow::Banner("BANNER_NORMAL");
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_RAW_);  //first to screen (not logged, file not opened)
    message << "Processing inputs. Eliminating degenerate (duplicate-element) inputs and duplicates.";
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_MESSAGE_);

    // get elements input
    vector<string> vinputs, velements;
    string inputs = vpflow.getattachedscheme("PFLOW::ALLOY");
    if(inputs.empty()) {
      message << "No input given for elements";
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
      //really drive the point home
      if(!vpflow.flag("CHULL::SCREEN_ONLY")){init::ErrorOption( "--alloy=" + vpflow.getattachedscheme("PFLOW::ALLOY"), "PFLOW()", usage_options);}
      if(vpflow.flag("CHULL::SCREEN_ONLY")&&vpflow.flag("CHULL::JSON_DOC")){oss << "{}";} //so JSON-reader doesn't bomb
      return FALSE;
    }
    inputs=aurostd::RemoveWhiteSpaces(inputs);  //CO20200531 - sometimes web injects spaces
    aurostd::StringSubst(inputs,"-","");;  //CO20200531 - removing '-' from web
    vector<string> tokens_comma;
    uint nary;
    string original_input;
    bool verbose_elimination=true;
    if(aurostd::substring2bool(inputs,":")){  //enumeration mode
      vector<string> tokens_colon;
      aurostd::string2tokens(inputs,tokens_colon,":");
      nary=tokens_colon.size();
      vector<vector<string> > vcomponents;  //< <Ag,Au>,<Mn> >
      vector<int> vsizes;
      for(uint i=0,fl_size_i=tokens_colon.size();i<fl_size_i;i++){
        vcomponents.push_back(vector<string>(0));
        if(tokens_colon[i]=="LIB2"){tokens_colon[i]=SPECIE_RAW_LIB2;verbose_elimination=false;}
        if(tokens_colon[i]=="LIB2U"){tokens_colon[i]=SPECIE_RAW_LIB2U;verbose_elimination=false;}
        if(tokens_colon[i]=="LIB3"){tokens_colon[i]=SPECIE_RAW_LIB3;verbose_elimination=false;}
        aurostd::string2tokens(tokens_colon[i],tokens_comma,",");
        for(uint j=0,fl_size_j=tokens_comma.size();j<fl_size_j;j++){vcomponents[i].push_back(tokens_comma[j]);}
        vsizes.push_back(vcomponents[i].size());
      }
      aurostd::xcombos xc(vsizes,'E');
      while(xc.increment()){
        velements=xc.applyCombo(vcomponents);
        if(verbose_elimination){velements=aurostd::getElements(aurostd::joinWDelimiter(velements,""),pp_string,FileMESSAGE,true,true,false,oss);}  //fast way to eliminate pseudopotential information  //clean and sort, do not keep_pp  //CO20190712
        //[CO20190712 - OBSOLETE]if(verbose_elimination){velements=pflow::getAlphabeticVectorString(aurostd::joinWDelimiter(velements,""),FileMESSAGE,oss);}  //fast way to eliminate pseudopotential information
        std::sort(velements.begin(),velements.end());
        original_input=aurostd::joinWDelimiter(velements,"");
        std::sort(velements.begin(),velements.end());velements.erase( std::unique( velements.begin(), velements.end() ), velements.end() );  //MnMnPd is same as MnPd
        if(velements.size()==nary){vinputs.push_back(aurostd::joinWDelimiter(velements,""));}  //ignore MnPd if requested ternaries
        else {
          if(verbose_elimination){
            message << "Ignoring degenerate (duplicate-element) input (" << original_input << ")";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
          }
        }
      }
    } else {  //simple list mode
      aurostd::string2tokens(inputs, tokens_comma, ",");
      for(uint i=0,fl_size_i=tokens_comma.size();i<fl_size_i;i++){
        velements=aurostd::getElements(tokens_comma[i],pp_string,FileMESSAGE,true,true,false,oss);  //clean and sort, do not keep_pp  //CO20190712
        //[CO20190712 - OBSOLETE]velements=pflow::getAlphabeticVectorString(tokens_comma[i], FileMESSAGE,oss);
        nary=velements.size();
        original_input=aurostd::joinWDelimiter(velements,"");
        std::sort(velements.begin(),velements.end());velements.erase( std::unique( velements.begin(), velements.end() ), velements.end() );  //MnMnPd is same as MnPd
        if(velements.size()==nary){vinputs.push_back(aurostd::joinWDelimiter(velements,""));}  //ignore MnPd if requested ternaries
        else {
          if(verbose_elimination){
            message << "Ignoring degenerate (duplicate-element) input (" << original_input << ")";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
          }
        }
      }
    }

    //remove duplicates from vinputs //SILENT
    if(verbose_elimination){
      vector<string> _vinputs=vinputs;vinputs.clear();
      if(_vinputs.size()){vinputs.push_back(_vinputs[0]);}
      for(uint i=1,fl_size_i=_vinputs.size();i<fl_size_i;i++){ //VERBOSE
        if(aurostd::WithinList(vinputs,_vinputs[i])){
          message << "Ignoring duplicate input (" << _vinputs[i] << ")";
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);  
          continue;
        }
        vinputs.push_back(_vinputs[i]);
      }
    } else {std::sort(vinputs.begin(),vinputs.end());vinputs.erase( std::unique( vinputs.begin(), vinputs.end() ), vinputs.end() );}

    message << "Total convex hull inputs: " << vinputs.size();
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_MESSAGE_);

    //////////////////////////////////////////////////////////////////////////////
    // END Gathering hull inputs
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Adding --sc=XX to CHULL::NEGLECT if --output=web
    //////////////////////////////////////////////////////////////////////////////
    //[CO20210315 - using --fake_hull_sc]if(vpflow.flag("CHULL::STABILITY_CRITERION")&&vpflow.flag("CHULL::WEB_DOC")){
    //[CO20210315 - using --fake_hull_sc]  string sc_input=vpflow.getattachedscheme("CHULL::STABILITY_CRITERION");
    //[CO20210315 - using --fake_hull_sc]  if(vpflow.flag("CHULL::NEGLECT")){
    //[CO20210315 - using --fake_hull_sc]    string neglect=vpflow.getattachedscheme("CHULL::NEGLECT");
    //[CO20210315 - using --fake_hull_sc]    if(!neglect.empty()){neglect+=",";}
    //[CO20210315 - using --fake_hull_sc]    neglect+=sc_input;
    //[CO20210315 - using --fake_hull_sc]    vpflow.pop_attached("CHULL::NEGLECT");
    //[CO20210315 - using --fake_hull_sc]    vpflow.push_attached("CHULL::NEGLECT",neglect);
    //[CO20210315 - using --fake_hull_sc]    vpflow.flag("CHULL::NEGLECT",true); //repetita iuvant
    //[CO20210315 - using --fake_hull_sc]  }else{
    //[CO20210315 - using --fake_hull_sc]    vpflow.flag("CHULL::NEGLECT",true);
    //[CO20210315 - using --fake_hull_sc]    vpflow.push_attached("CHULL::NEGLECT",sc_input);
    //[CO20210315 - using --fake_hull_sc]  }
    //[CO20210315 - using --fake_hull_sc]  if(LDEBUG){cerr << soliloquy << " vpflow.getattachedscheme(\"CHULL::NEGLECT\")=" << vpflow.getattachedscheme("CHULL::NEGLECT") << endl;}
    //[CO20210315 - using --fake_hull_sc]}
    //////////////////////////////////////////////////////////////////////////////
    // END Adding --sc=XX to CHULL::NEGLECT if --output=web
    //////////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////////
    // START Looping over hull inputs and creating desired output
    //////////////////////////////////////////////////////////////////////////////
    bool Krun=true;
    string log_name;
    string alloy="";
    for(uint i=0,fl_size_i=vinputs.size();i<fl_size_i;i++) {
      // go through each request
      // create log specific to that request
      velements = aurostd::getElements(vinputs[i],pp_string,FileMESSAGE,true,true,false,oss); //clean and sort, do not keep_pp  //CO20190712
      //[CO20190712 - OBSOLETE]velements = pflow::getAlphabeticVectorString(vinputs[i], FileMESSAGE,oss);
      if(!velements.size()){
        message << "Invalid input (" << vinputs[i] << "), please capitalize element symbols";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
        Krun=false;continue;/*return FALSE;*/
      }
      if(velements.size()<2){
        message << "Trivial input (" << vinputs[i] << "), enter binaries or higher";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
        Krun=false;continue;/*return FALSE;*/
      }
      if(XHOST.vflag_control.flag("WWW")&&velements.size()>6){ //CO20200404 - new web flag
        message << velements.size() << "-dimensional hulls cannot be calculated through the web portal (max=6D), please download the AFLOW binary";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
        Krun=false;continue;/*return FALSE;*/
      }
      alloy=aurostd::joinWDelimiter(velements,"");
      if(vpflow.flag("CHULL::LOG")) {
        log_name = "aflow_" + aurostd::joinWDelimiter(velements,"") + "_hull.log";
        string log_destination = directory + log_name;  // no output before banner //CO20180220
        FileMESSAGE.open(log_destination.c_str());
      }
      // spit out banner for only the first request
      message << aflow::Banner("BANNER_NORMAL");
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_RAW_, true);  //i //no screen, first to be logged
      message << "Starting " << aurostd::joinWDelimiter(velements,"") << " " << pflow::arity_string(velements.size(),false,false) << " convex hull";
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_MESSAGE_);
      getPath(vpflow, FileMESSAGE, oss, false); //CO20180220 - directory stuff for logging
      chull::flagCheck(vpflow, velements, FileMESSAGE, oss, i);  // spit out all flag options

      ////////////////////////////////////////////////////////////////////////////
      // START Stability criterion calculation
      ////////////////////////////////////////////////////////////////////////////
      //if(vpflow.flag("CHULL::STABILITY_CRITERION")) {
      //  message << "Starting stable criterion calculation of " << vpflow.getattachedscheme("CHULL::STABILITY_CRITERION");
      //  message << " on " << vinputs[i] << " hull";
      //  pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_MESSAGE_);
      //  vector<string> vauid;
      //  vector<double> vscriterion;
      //  aurostd::string2tokens(vpflow.getattachedscheme("CHULL::STABILITY_CRITERION"), vauid, ",");
      //  if(!calculateStabilityCriterion(vpflow,velements,vauid,vscriterion,FileMESSAGE,oss)) {Krun=false;continue;/*return FALSE;*/} //HAS to be thermal hull by virtue of input
      //  if(vpflow.flag("CHULL::SCREEN_ONLY")){
      //    if(vpflow.flag("CHULL::TEXT_DOC")){
      //      for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
      //        message << vauid[ia] << ": " << chull::convertUnits(vscriterion[ia], (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_)) << endl;
      //      }
      //      oss << message.str();
      //    } else if(vpflow.flag("CHULL::JSON_DOC")){
      //      vector<string> vmes;
      //      stringstream dummy;
      //      for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
      //        dummy << "\"" <<vauid[ia] << "\":" << chull::convertUnits(vscriterion[ia], (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_));
      //        vmes.push_back(dummy.str()); dummy.str("");
      //      }
      //      oss << aurostd::wrapString(aurostd::joinWDelimiter(vmes,","),"{","}");
      //    } else { //.log only, but obsolete now anyway since it defaults to json
      //      message << "Unknown print option, only --print=text or --print=json available";
      //      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
      //      if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
      //      Krun=false;continue;/*return FALSE;*/
      //    }
      //  } else {
      //    for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
      //      if(!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {
      //        message << vauid[ia] << " criterion = " << chull::convertUnits(vscriterion[ia], _m_) << " (meV/atom)";
      //        if(std::signbit(vscriterion[ia])) {  //-4e-13 is still negative!
      //          message << ", may NOT be on the hull (negative value)";
      //          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
      //        } else {pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_COMPLETE_);}
      //      } else {
      //        message << vauid[ia] << " criterion = " << vscriterion[ia] << " (K)";
      //        if(!std::signbit(vscriterion[ia])) {
      //          message << ", may NOT be on the hull (positive value)";
      //          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
      //        } else {pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_COMPLETE_);}
      //      }
      //    }
      //  }
      //  continue;
      //}
      ////////////////////////////////////////////////////////////////////////////
      // END Stability criterion calculation
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START Jupyter notebook writing files
      ////////////////////////////////////////////////////////////////////////////
      //MB20190301: For generating Jupyter notebook
      if(vpflow.flag("CHULL::WRITE_JUPYTER2") || vpflow.flag("CHULL::WRITE_JUPYTER3")){

        string aflow_chull_jupyter_json=AFLOW_CHULL_JUPYTER_JSON;
        string aflow_chull_jupyter_subdir = "AFLOW_CHULL_JUPYTER";
        string jupyter_directory=directory + aflow_chull_jupyter_subdir;
        aurostd::DirectoryMake(jupyter_directory);
        aurostd::StringSubst(aflow_chull_jupyter_json,"AFLOW_ALLOY_INSERT_HERE",alloy);
        string ver = (vpflow.flag("CHULL::WRITE_JUPYTER3")) ? "3" : "2";
        string full_ver = (vpflow.flag("CHULL::WRITE_JUPYTER3")) ? "3" : "2";
        aurostd::StringSubst(aflow_chull_jupyter_json,"<ver>",ver);
        aurostd::StringSubst(aflow_chull_jupyter_json,"<full ver>",full_ver);	

        stringstream output;
        output << aflow_chull_jupyter_json;
        aurostd::stringstream2file(output,jupyter_directory+'/'+"notebook.ipynb");

        stringstream output2; 
        string aflow_chull_jupyter_plotter_py=AFLOW_CHULL_JUPYTER_PLOTTER_PY;
        output2 << aflow_chull_jupyter_plotter_py;
        aurostd::stringstream2file(output2,jupyter_directory+'/'+"aflow_chull_plotter.py");

        stringstream output3;
        string aflow_chull_python_py=AFLOW_CHULL_PYTHON_PY;
        output3 << aflow_chull_python_py;
        aurostd::stringstream2file(output3,jupyter_directory+'/'+"aflow_chull.py");	

        stringstream output4;
        string aflow_chull_requirements_txt=AFLOW_CHULL_JUPYTER_REQUIREMENTS_TXT;
        output4 << aflow_chull_requirements_txt;
        aurostd::stringstream2file(output4,jupyter_directory+'/'+"requirements.txt");	

        message << "Created " << aflow_chull_jupyter_subdir << " directory for " << vinputs[i] << " hull";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_COMPLETE_);

        continue;
      }     

      ////////////////////////////////////////////////////////////////////////////
      // STOP Jupyter notebook writing files
      ////////////////////////////////////////////////////////////////////////////

      //speed ups for command line options
      if(vpflow.flag("CHULL::DIST2HULL") || vpflow.flag("CHULL::STABILITY_CRITERION") || vpflow.flag("CHULL::N+1_ENTHALPY_GAIN") || vpflow.flag("CHULL::HULL_FORMATION_ENTHALPY")) {
        vpflow.flag("CHULL::SKIP_THERMO_PROPERTIES_EXTRACTION",true);
        message << "Skipping thermodynamic properties extraction";pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_MESSAGE_);
      }

      //skip calculating all of the lower dimensional hulls
      //this works if you are finding the hull_energy somewhere in the middle of the hull
      //the edges are problematic (lower dimensional hulls)
      //so only skip calculating these hulls if you are calculating hull_energy of the ND hull
      if(0){  //not actually faster, lower dimensional hulls reduce number of points in ND hull, tested 7D-hull: 45 mins vs. 1 hr
        if(vpflow.flag("CHULL::HULL_FORMATION_ENTHALPY")){
          vector<double> _coords;
          aurostd::string2tokens<double>(vpflow.getattachedscheme("CHULL::HULL_FORMATION_ENTHALPY"), _coords, ",");
          if(_coords.size()==velements.size()-1||_coords.size()==velements.size()){
            bool at_edge=false;
            double sum=0.0;
            for(uint ia=0;ia<(velements.size()-1)&&ia<_coords.size();ia++){
              if(abs(_coords[ia])<ZERO_COEF_TOL||abs(1.0-_coords[ia])<ZERO_COEF_TOL){at_edge=true;}
              sum+=_coords[ia];
            }
            double coord_last=1.0-sum;
            at_edge=(at_edge || (abs(coord_last)<ZERO_COEF_TOL||abs(1.0-coord_last)<ZERO_COEF_TOL));
            if(LDEBUG){
              cerr << soliloquy << " coords=" << aurostd::joinWDelimiter(aurostd::vecDouble2vecString(_coords,4),",") << endl;
              cerr << soliloquy << " sum=" << sum << endl;
              cerr << soliloquy << " coord_last=" << coord_last << endl;
              cerr << soliloquy << " at_edge=" << at_edge << endl;
            }
            if(at_edge==false){
              vpflow.flag("CHULL::CALCULATE_HIGHEST_DIMENSION_ONLY",true);
              message << "Calculating the highest dimensional hull ONLY";pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_MESSAGE_);
            }
          }
        }
      }

      ////////////////////////////////////////////////////////////////////////////
      // START Hull initialization
      ////////////////////////////////////////////////////////////////////////////

      ConvexHull hull(vpflow,velements,FileMESSAGE,oss);
      if(!hull.m_initialized) {
        message << "Hull was not created successfully";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
        if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
        if(vpflow.flag("CHULL::SCREEN_ONLY")&&vpflow.flag("CHULL::JSON_DOC")){oss << "{}";}
        Krun=false;continue;/*return FALSE;*/
      }
      uint dimension = hull.getDim();
      if(!dimension) {
        message << "Hull has no dimensions";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
        if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
        Krun=false;continue;/*return FALSE;*/
      }
      if(dimension < 2) {
        message << "Unable to calculate hulls with dimensions less than 2";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
        if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
        Krun=false;continue;/*return FALSE;*/
      }
      if(dimension != velements.size()) {
        message << "Dimension of hull does not reflect the number of elements";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
        if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
        Krun=false;continue;/*return FALSE;*/
      }

      ////////////////////////////////////////////////////////////////////////////
      // END Hull initialization
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START Distance to hull calculation
      ////////////////////////////////////////////////////////////////////////////
      if(vpflow.flag("CHULL::DIST2HULL")) {
        message << "Starting distance to hull calculation of " << vpflow.getattachedscheme("CHULL::DIST2HULL");
        message << " on " << vinputs[i] << " hull";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_MESSAGE_);
        vector<string> vauid;
        aurostd::string2tokens(vpflow.getattachedscheme("CHULL::DIST2HULL"), vauid, ",");
        vector<double> vdist2hull;
        //NB: to anyone who is using the convex hull object
        //outside of declaration/initialization, all functions should be wrapped
        //in try/catch's to avoid hard exits
        //proceed otherwise at your own risk
        try{vdist2hull=hull.getDistancesToHull(vauid);}
        catch(aurostd::xerror& err){
          pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
          if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
          if(vpflow.flag("CHULL::SCREEN_ONLY")&&vpflow.flag("CHULL::JSON_DOC")){oss << "{}";} //so JSON-reader doesn't bomb
          return false;
        }

        //set correct sign convention
        //since this SHOULD be a positive distance (inside hull), we will negate for formation_energy_hull
        //for (uint ia = 0; ia < vauid.size(); ia++) {
        //  if(!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {vdist2hull[ia]=abs(vdist2hull[ia]);}
        //}

        for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
          if(!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {message << vauid[ia] << " dist2hull = " << chull::convertUnits(vdist2hull[ia], _m_) << " (meV/atom)";}
          else {message << vauid[ia] << " dist2hull = " << vdist2hull[ia] << " (K)";}
          if(zeroWithinTol(vdist2hull[ia])) {  //do not issue a warning either way, it's simply the distance
            message << ", may be on the hull";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_COMPLETE_);
          } else {pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_COMPLETE_);}
          //if(0&&!std::signbit(vdist2hull[ia])) {  //do not issue a warning either way, it's simply the distance
          //  message << ", may NOT be off the hull (positive value)";
          //  pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
          //} else {pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_COMPLETE_);}
        }

        if(vpflow.flag("CHULL::SCREEN_ONLY")){
          if(vpflow.flag("CHULL::TEXT_DOC")){
            for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
              message << vauid[ia] << ": " << chull::convertUnits(vdist2hull[ia], (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_)) << endl;
            }
            oss << message.str();
          } else if(vpflow.flag("CHULL::JSON_DOC")){
            vector<string> vmes;
            stringstream dummy;
            for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
              dummy << "\"" <<vauid[ia] << "\":" << chull::convertUnits(vdist2hull[ia], (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_));
              vmes.push_back(dummy.str()); dummy.str("");
            }
            oss << aurostd::wrapString(aurostd::joinWDelimiter(vmes,","),"{","}");
          } else { //.log only, but obsolete now anyway since it defaults to json
            message << "Unknown print option, only --print=text or --print=json available";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
            if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
            Krun=false;continue;/*return FALSE;*/
          }
        }
        continue;
      }
      ////////////////////////////////////////////////////////////////////////////
      // END Distance to hull calculation
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START Stability criterion calculation
      ////////////////////////////////////////////////////////////////////////////
      if(vpflow.flag("CHULL::STABILITY_CRITERION")) { //CO20210201 - chull-web SS plotter //&&(!vpflow.flag("CHULL::WEB_DOC"))
        message << "Starting stable criterion calculation of " << vpflow.getattachedscheme("CHULL::STABILITY_CRITERION");
        message << " on " << vinputs[i] << " hull";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_MESSAGE_);
        vector<string> vauid;
        aurostd::string2tokens(vpflow.getattachedscheme("CHULL::STABILITY_CRITERION"), vauid, ",");
        vector<double> vscriterion;
        //NB: to anyone who is using the convex hull object
        //outside of declaration/initialization, all functions should be wrapped
        //in try/catch's to avoid hard exits
        //proceed otherwise at your own risk
        try{vscriterion=hull.getStabilityCriterion(vauid);}
        catch(aurostd::xerror& err){
          pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
          if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
          if(vpflow.flag("CHULL::SCREEN_ONLY")&&vpflow.flag("CHULL::JSON_DOC")){oss << "{}";} //so JSON-reader doesn't bomb
          return false;
        }

        ////set correct sign convention
        ////since this SHOULD be a negative distance (outside hull), we will negate for formation_energy_hull
        //for (uint ia = 0; ia < vauid.size(); ia++) {
        //  if(!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {vscriterion[ia]=-vscriterion[ia];}
        //}

        for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
          if(!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {message << vauid[ia] << " criterion = " << chull::convertUnits(vscriterion[ia], _m_) << " (meV/atom)";}
          else {message << vauid[ia] << " criterion = " << vscriterion[ia] << " (K)";}
          if(std::signbit(vscriterion[ia])) {
            message << ", may NOT be on the hull (negative value)";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
          } else {pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_COMPLETE_);}
        }

        if(vpflow.flag("CHULL::SCREEN_ONLY")){
          if(vpflow.flag("CHULL::TEXT_DOC")){
            for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
              message << vauid[ia] << ": " << chull::convertUnits(vscriterion[ia], (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_)) << endl;
            }
            oss << message.str();
          } else if(vpflow.flag("CHULL::JSON_DOC")){
            vector<string> vmes;
            stringstream dummy;
            for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
              dummy << "\"" <<vauid[ia] << "\":" << chull::convertUnits(vscriterion[ia], (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_));
              vmes.push_back(dummy.str()); dummy.str("");
            }
            oss << aurostd::wrapString(aurostd::joinWDelimiter(vmes,","),"{","}");
          } else { //.log only, but obsolete now anyway since it defaults to json
            message << "Unknown print option, only --print=text or --print=json available";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
            if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
            Krun=false;continue;/*return FALSE;*/
          }
        }
        continue;
      }
      ////////////////////////////////////////////////////////////////////////////
      // END Stability criterion calculation
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START N+1 enthalpy gain calculation
      ////////////////////////////////////////////////////////////////////////////
      if(vpflow.flag("CHULL::N+1_ENTHALPY_GAIN")) {
        message << "Starting N+1 enthalpy gain calculation of " << vpflow.getattachedscheme("CHULL::N+1_ENTHALPY_GAIN");
        message << " on " << vinputs[i] << " hull";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_MESSAGE_);
        vector<string> vauid;
        aurostd::string2tokens(vpflow.getattachedscheme("CHULL::N+1_ENTHALPY_GAIN"), vauid, ",");
        vector<double> vn1egain;
        //NB: to anyone who is using the convex hull object
        //outside of declaration/initialization, all functions should be wrapped
        //in try/catch's to avoid hard exits
        //proceed otherwise at your own risk
        try{vn1egain=hull.getNPlus1EnthalpyGain(vauid);}
        catch(aurostd::xerror& err){
          pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
          if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
          if(vpflow.flag("CHULL::SCREEN_ONLY")&&vpflow.flag("CHULL::JSON_DOC")){oss << "{}";} //so JSON-reader doesn't bomb
          return false;
        }

        ////set correct sign convention
        ////since this SHOULD be a negative distance (outside hull), we will negate for formation_energy_hull
        //for (uint ia = 0; ia < vauid.size(); ia++) {
        //  if(!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {vn1egain[ia]=-vn1egain[ia];}
        //}

        for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
          if(!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {message << vauid[ia] << " n+1_enthalpy_gain = " << chull::convertUnits(vn1egain[ia], _m_) << " (meV/atom)";}
          else {message << vauid[ia] << " n+1_enthalpy_gain = " << vn1egain[ia] << " (K)";}
          if(std::signbit(vn1egain[ia])) {
            message << ", may NOT be on the hull (negative value)";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
          } else {pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_COMPLETE_);}
        }

        if(vpflow.flag("CHULL::SCREEN_ONLY")){
          if(vpflow.flag("CHULL::TEXT_DOC")){
            for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
              message << vauid[ia] << ": " << chull::convertUnits(vn1egain[ia], (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_)) << endl;
            }
            oss << message.str();
          } else if(vpflow.flag("CHULL::JSON_DOC")){
            vector<string> vmes;
            stringstream dummy;
            for(uint ia=0,fl_size_ia=vauid.size();ia<fl_size_ia;ia++) {
              dummy << "\"" <<vauid[ia] << "\":" << chull::convertUnits(vn1egain[ia], (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_));
              vmes.push_back(dummy.str()); dummy.str("");
            }
            oss << aurostd::wrapString(aurostd::joinWDelimiter(vmes,","),"{","}");
          } else { //.log only, but obsolete now anyway since it defaults to json
            message << "Unknown print option, only --print=text or --print=json available";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
            if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
            Krun=false;continue;/*return FALSE;*/
          }
        }
        continue;
      }
      ////////////////////////////////////////////////////////////////////////////
      // END N+1 enthalpy gain calculation
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START Hull formation enthalpy calculation
      ////////////////////////////////////////////////////////////////////////////
      if(vpflow.flag("CHULL::HULL_FORMATION_ENTHALPY")) {
        message << "Starting calculation of the formation enthalpy at " << vpflow.getattachedscheme("CHULL::HULL_FORMATION_ENTHALPY");
        message << " on " << vinputs[i] << " hull";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_MESSAGE_);
        vector<double> _coords;
        xvector<double> coords(dimension);
        aurostd::string2tokens<double>(vpflow.getattachedscheme("CHULL::HULL_FORMATION_ENTHALPY"), _coords, ",");
        for(uint j=0,fl_size_j=_coords.size();j<fl_size_j&&j<dimension;j++){coords[j+coords.lrows]=_coords[j];}
        if(LDEBUG) {cerr << soliloquy << " coords=" << coords << endl;}
        double dist2hull=0.0;
        //NB: to anyone who is using the convex hull object
        //outside of declaration/initialization, all functions should be wrapped
        //in try/catch's to avoid hard exits
        //proceed otherwise at your own risk
        try{
          ChullPoint cp(coords,FileMESSAGE,oss,hull.m_has_stoich_coords,hull.m_formation_energy_hull,false);  //not a real point
          dist2hull=hull.getDistanceToHull(cp,false,true);  //do not redo, get signed distance (this is energy)
          bool should_be_positive=!hull.m_lower_hull;
          bool correct_sign_vertical_distance=chull::correctSignVerticalDistance(dist2hull,should_be_positive);
          if(LDEBUG){
            cerr << soliloquy << " dist2hull=" << dist2hull << endl;
            cerr << soliloquy << " correct_sign_vertical_distance=" << correct_sign_vertical_distance << endl;
          }
          if(!correct_sign_vertical_distance){dist2hull*=-1.0;}
        }
        catch(aurostd::xerror& err){
          pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), aflags, FileMESSAGE, oss, _LOGGER_ERROR_);
          if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
          if(vpflow.flag("CHULL::SCREEN_ONLY")&&vpflow.flag("CHULL::JSON_DOC")){oss << "{}";} //so JSON-reader doesn't bomb
          return false;
        }

        if(vpflow.flag("CHULL::SCREEN_ONLY")){
          uint precision=COEF_PRECISION;
          double roundoff_tol=5.0*pow(10,-((int)precision)-1);
          stringstream hull_energy_ss;
          hull_energy_ss << "\"hull_energy";
          hull_energy_ss << aurostd::wrapString(aurostd::joinWDelimiter(xvecDouble2vecString(coords,precision,true,roundoff_tol,FIXED_STREAM),","),"[","]");
          hull_energy_ss << "\": ";
          hull_energy_ss << chull::convertUnits(dist2hull, (!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")?_m_:_std_));
          oss << aurostd::wrapString(hull_energy_ss.str(),"{","}");
        } else {
          //[CO20190801 - OBSOLETE]message << "hull_energy[coords=" << aurostd::joinWDelimiter(coords,",");
          //[CO20190801 - OBSOLETE]for(int j=coords.lrows;j<=coords.urows;j++){
          //[CO20190801 - OBSOLETE]  message << coords[j];
          //[CO20190801 - OBSOLETE]  if(j!=((int)dimension)-1){message << ",";}
          //[CO20190801 - OBSOLETE]}
          //[CO20190801 - OBSOLETE]message << "] = ";
          uint precision=COEF_PRECISION;
          double roundoff_tol=5.0*pow(10,-((int)precision)-1);
          message << "hull_energy" << aurostd::wrapString("coords="+aurostd::joinWDelimiter(xvecDouble2vecString(coords,precision,true,roundoff_tol,FIXED_STREAM),","),"[","]");
          message << " = ";
          if(!vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {message << chull::convertUnits(dist2hull, _m_) << " (meV/atom)";}
          else {message << dist2hull << " (K)";}
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, aflags, FileMESSAGE, oss, _LOGGER_COMPLETE_);
        }
        continue;
      }
      ////////////////////////////////////////////////////////////////////////////
      // END Hull formation enthalpy calculation
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START outputs
      ////////////////////////////////////////////////////////////////////////////

      if(vpflow.flag("CHULL::TEXT_DOC")) {if(!hull.write(txt_ft)) {if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();} Krun=false;continue;/*return FALSE;*/}} // text doc
      if(vpflow.flag("CHULL::JSON_DOC")) {if(!hull.write(json_ft)) {if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();} Krun=false;continue;/*return FALSE;*/}} // json doc
      if(vpflow.flag("CHULL::WEB_DOC")) {if(!hull.write(chull_web_ft)) {if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();} Krun=false;continue;/*return FALSE;*/}} // web-specific json doc
      if(vpflow.flag("CHULL::LATEX_DOC")||vpflow.flag("CHULL::PNG_IMAGE")) {if(!hull.write(latex_ft)) {if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();} Krun=false;continue;/*return FALSE;*/}} // latex doc, keep last as it will trip on useless plots

      ////////////////////////////////////////////////////////////////////////////
      // END outputs
      ////////////////////////////////////////////////////////////////////////////

      // close input specific log
      if(vpflow.flag("CHULL::LOG")) {FileMESSAGE.close();}
    }
    //////////////////////////////////////////////////////////////////////////////
    // END Looping over hull inputs and creating desired output
    //////////////////////////////////////////////////////////////////////////////
    return Krun;/*TRUE;*/
  }
} // namespace chull

namespace chull {
  //***************************************************************************//
  // chull::getPath(aurostd::xoption& vpflow,const bool& silent,ostringstream&
  // oss,ofstream& FileMESSAGE)
  //***************************************************************************//
  // gets path to redirect output
  string getPath(bool add_backslash) {return aurostd::getPWD() + (add_backslash?string("/"):string(""));} //[CO20191112 - OBSOLETE]aurostd::execute2string(XHOST.command("pwd"))
  string getPath(const aurostd::xoption& vpflow, ostream& oss, bool silent) {  // overload
    ofstream FileMESSAGE;
    return getPath(vpflow, FileMESSAGE, oss, silent);
  }
  string getPath(const aurostd::xoption& vpflow, ofstream& FileMESSAGE, ostream& oss, bool silent) {  // main function
    string soliloquy=XPID+"chull::getPath():";
    stringstream message;
    if(!vpflow.flag("CHULL::PATH")) {
      string pwd = getPath();
      if(!silent){
        message << "Directing output to current directory: " << pwd;
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, FileMESSAGE, oss, _LOGGER_OPTION_); //, silent);  //CO20180220 - silent now means print AT ALL
      }
      return pwd;
    }
    return getPath(vpflow.getattachedscheme("CHULL::PATH"), FileMESSAGE, oss, silent);
  }
  //***************************************************************************//
  // chull::getPath(string _path,const bool& silent,ostream& oss,ofstream&
  // FileMESSAGE)
  //***************************************************************************//
  // gets path to redirect output
  string getPath(string _path, ostream& oss, bool silent) {  // overload
    ofstream FileMESSAGE;
    return getPath(_path, FileMESSAGE, oss, silent);
  }
  string getPath(string _path, ofstream& FileMESSAGE, ostream& oss, bool silent) {  // main function
    string soliloquy=XPID+"chull::getPath():";
    stringstream message;
    string pwd = getPath(false);
    string home = XHOST.home; //aurostd::execute2string(XHOST.command("echo") + " $HOME");
    string path;
    // add '/' if _path doesn't already have it
    if(_path[_path.length() - 1] != '/') {
      _path += "/";
    }
    // remove ./ for relative paths
    if(_path[0] == '.') {
      _path = _path.substr(1, _path.length());
      if(!_path.empty() && _path[0] == '/') {
        _path = _path.substr(1, _path.length());
      }
    }
    // home doesn't have last '/'
    if(!_path.empty() && _path[0] == '~') {
      _path = _path.substr(1, _path.length());
      if(!_path.empty() && _path[0] == '/') {
        _path = _path.substr(1, _path.length());
      }
      _path = home + "/" + _path;
    }
    // if not root path (starting with '/'), it's a relative path, add it to pwd,
    // pwd doesn't have last '/'
    if(_path.empty() || (!_path.empty() && _path[0] != '/')) {
      path = pwd + "/";
      path += _path;
    } else {
      path = _path;
    }

    //test of stupidity
    if(!aurostd::IsDirectory(path)){
      message << path << " does not seem to be a viable directory, changing to pwd=" << pwd;
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, FileMESSAGE, oss, _LOGGER_WARNING_);
      path=pwd+"/";
    }

    if(!silent){
      message << "Directing output to " << path;
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, FileMESSAGE, oss, _LOGGER_OPTION_); //, silent);  //CO20180220 - silent now means print AT AL
    }
    return path;
  }
} // namespace chull

namespace chull {
  //***************************************************************************//
  // chull::flagCheck(aurostd::xoption& vpflow,bool silent,ostringstream& oss,ofstream& FileMESSAGE)
  //***************************************************************************//
  // logs which flags are on
  void flagCheck(aurostd::xoption& vpflow, const vector<string>& velements, ostream& oss, bool silent) {  // overload
    ofstream FileMESSAGE;
    flagCheck(vpflow, velements, FileMESSAGE, oss, silent);
  }
  void flagCheck(aurostd::xoption& vpflow, const vector<string>& velements, ofstream& FileMESSAGE, ostream& oss, bool silent) {  // main function
    string soliloquy=XPID+"chull::flagCheck():";
    stringstream message;
    string directory=getPath(vpflow,FileMESSAGE,oss);
    _aflags aflags; aflags.Directory=directory;
    if(vpflow.flag("CHULL::TEXT_DOC")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::TEXT_DOC set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::JSON_DOC")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::JSON_DOC set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::WEB_DOC")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::WEB_DOC set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::LATEX_DOC")||vpflow.flag("CHULL::PNG_IMAGE")) {
      if(vpflow.flag("CHULL::LATEX_DOC")){
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::LATEX_DOC set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
      if(vpflow.flag("CHULL::PNG_IMAGE")){
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::PNG_IMAGE set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
      if(vpflow.flag("CHULL::IMAGE_ONLY")) {
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::IMAGE_ONLY set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
      if(vpflow.flag("CHULL::NO_DOC")) {
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::NO_DOC set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
      if(vpflow.flag("CHULL::DOC_ONLY")) {
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::DOC_ONLY set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
      if(vpflow.flag("CHULL::KEEP_TEX")) {
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::KEEP_TEX set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
      if(vpflow.flag("CHULL::LATEX_OUTPUT")) {
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::LATEX_OUTPUT set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
      if(vpflow.flag("CHULL::LATEX_INTERACTIVE")) {
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::LATEX_INTERACTIVE set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
      if(vpflow.flag("CHULL::LIGHT_CONTRAST")) {
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::LIGHT_CONTRAST set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
      if(vpflow.flag("CHULL::LARGE_FONT")) {
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::LARGE_FONT set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
      if(vpflow.flag("CHULL::PLOT_ISO_MAX_LATENT_HEAT")) {
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::PLOT_ISO_MAX_LATENT_HEAT set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
    }
    if(vpflow.flag("CHULL::SCREEN_ONLY")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::SCREEN_ONLY set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::LOG")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::LOG set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    string lib_count_string,load_lib_flag_name;
    for(uint lib=1,fl_size_lib=velements.size();lib<=fl_size_lib && lib<=_AFLOW_LIB_MAX_;lib++) {
      lib_count_string=aurostd::utype2string(lib);
      load_lib_flag_name="PFLOW::LOAD_ENTRIES_LOAD_LIB"+lib_count_string;
      if(vpflow.flag(load_lib_flag_name)) {
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, load_lib_flag_name+" set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
      }
    }
    if(vpflow.flag("PFLOW::LOAD_ENTRIES_NARIES_MINUS_ONE")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "PFLOW::LOAD_ENTRIES_NARIES_MINUS_ONE set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("PFLOW::LOAD_ENTRIES_LOAD_ICSD")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "PFLOW::LOAD_ENTRIES_LOAD_ICSD set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("PFLOW::LOAD_API")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "PFLOW::LOAD_API set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("PFLOW::LOAD_ENTRIES_ENTRY_OUTPUT")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "PFLOW::LOAD_ENTRIES_ENTRY_OUTPUT set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::NEGLECT")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::NEGLECT set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::SEE_NEGLECT")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::SEE_NEGLECT set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::CALCULATE_FAKE_HULL_STABILITY_CRITERION")) { //CO20210315
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::CALCULATE_FAKE_HULL_STABILITY_CRITERION set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent); 
    }
    if(vpflow.flag("CHULL::CALCULATE_FAKE_HULL_N+1_ENTHALPY_GAIN")) { //SK20200327
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::CALCULATE_FAKE_HULL_N+1_ENTHALPY_GAIN set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent); 
    }
    if(vpflow.flag("CHULL::REMOVE_EXTREMA")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::REMOVE_EXTREMA set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::ENTROPIC_TEMPERATURE")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::ENTROPIC_TEMPERATURE set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::INCLUDE_PAW_GGA")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::INCLUDE_PAW_GGA set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::DIST2HULL")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::DIST2HULL set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::STABILITY_CRITERION")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::STABILITY_CRITERION set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::HULL_FORMATION_ENTHALPY")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::HULL_FORMATION_ENTHALPY set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::SKIP_STRUCTURE_COMPARISON")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::SKIP_STRUCTURE_COMPARISON set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::SKIP_STABILITY_CRITERION_ANALYSIS")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::SKIP_STABILITY_CRITERION_ANALYSIS set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::SKIP_N+1_ENTHALPY_GAIN_ANALYSIS")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::SKIP_N+1_ENTHALPY_GAIN_ANALYSIS set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::INCLUDE_SKEWED_HULLS")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::INCLUDE_SKEWED_HULLS set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::INCLUDE_UNRELIABLE_HULLS")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::INCLUDE_UNRELIABLE_HULLS set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::INCLUDE_OUTLIERS")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::INCLUDE_OUTLIERS set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::STRICT_OUTLIER_ANALYSIS")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::STRICT_OUTLIER_ANALYSIS set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::INCLUDE_ILL_CONVERGED")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::INCLUDE_ILL_CONVERGED set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("CHULL::CALCULATE_HIGHEST_DIMENSION_ONLY")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::CALCULATE_HIGHEST_DIMENSION_ONLY set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
    if(vpflow.flag("FORCE")) {
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "CHULL::FORCE set to TRUE", aflags, FileMESSAGE, oss, _LOGGER_OPTION_, silent);
    }
  }
} // namespace chull

//namespace chull {
//  bool calculateStabilityCriterion(const vector<string>& velements,const string& auid,double& scriterion,ostream& oss){
//    ofstream FileMESSAGE;
//    return calculateStabilityCriterion(velements,auid,scriterion,FileMESSAGE,oss);
//  }
//  bool calculateStabilityCriterion(const vector<string>& velements,const string& auid,double& scriterion,ofstream& FileMESSAGE,ostream& oss){
//    vector<string> vauid;
//    vauid.push_back(auid);
//    vector<double> vscriterion;
//    if(!calculateStabilityCriterion(velements,vauid,vscriterion,FileMESSAGE,oss)) {return FALSE;}
//    scriterion = vscriterion[0];
//    return true;
//  }
//  bool calculateStabilityCriterion(const vector<string>& velements,const vector<string>& vauid,vector<double>& vscriterion,ostream& oss){
//    ofstream FileMESSAGE;
//    return calculateStabilityCriterion(velements,vauid,vscriterion,FileMESSAGE,oss);
//  }
//  bool calculateStabilityCriterion(const vector<string>& velements,const vector<string>& vauid,vector<double>& vscriterion,ofstream& FileMESSAGE,ostream& oss){
//    aurostd::xoption vpflow;
//    pflow::defaultLoadEntriesFlags(vpflow,FileMESSAGE,oss,std::string("A"),false,true);
//    return calculateStabilityCriterion(vpflow,velements,vauid,vscriterion,FileMESSAGE,oss);
//  }
//  bool calculateStabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,double& scriterion,ostream& oss){
//    ofstream FileMESSAGE;
//    return calculateStabilityCriterion(vpflow,velements,scriterion,FileMESSAGE,oss);
//  }
//  bool calculateStabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,double& scriterion,ofstream& FileMESSAGE,ostream& oss){
//    string soliloquy=XPID+"chull::calculateStabilityCriterion():";
//    stringstream message;
//    if(!vpflow.flag("CHULL::NEGLECT")) {
//      pflow::logger(_AFLOW_FILE_NAME_,soliloquy,"CHULL::NEGLECT not set",FileMESSAGE,oss,_LOGGER_ERROR_);
//      return false;
//    }
//    vector<string> points_neglect;
//    aurostd::string2tokens(vpflow.getattachedscheme("CHULL::NEGLECT"),points_neglect,",");
//    if(points_neglect.size()!=1) {
//      message << "Can only handle one AUID at a time, " << points_neglect.size() << " given";
//      pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
//      return FALSE;
//    }
//    return calculateStabilityCriterion(vpflow,velements,points_neglect[0],scriterion,FileMESSAGE,oss);
//  }
//  bool calculateStabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,const string& auid,double& scriterion,ostream& oss){
//    ofstream FileMESSAGE;
//    return calculateStabilityCriterion(vpflow,velements,auid,scriterion,FileMESSAGE,oss);
//  }
//  bool calculateStabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,const string& auid,double& scriterion,ofstream& FileMESSAGE,ostream& oss){
//    vector<string> vauid;
//    vauid.push_back(auid);
//    vector<double> vscriterion;
//    if(!calculateStabilityCriterion(vpflow,velements,vauid,vscriterion,FileMESSAGE,oss)) {return FALSE;}
//    scriterion = vscriterion[0];
//    return true;
//  }
//  bool calculateStabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,vector<double>& vscriterion,ostream& oss){
//    ofstream FileMESSAGE;
//    return calculateStabilityCriterion(vpflow,velements,vscriterion,FileMESSAGE,oss);
//  }
//  bool calculateStabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,vector<double>& vscriterion,ofstream& FileMESSAGE,ostream& oss){
//    string soliloquy=XPID+"chull::calculateStabilityCriterion():";
//    stringstream message;
//    if(!vpflow.flag("CHULL::NEGLECT")) {
//      pflow::logger(_AFLOW_FILE_NAME_,soliloquy,"CHULL::NEGLECT not set",FileMESSAGE,oss,_LOGGER_ERROR_);
//      return FALSE;
//    }
//    vector<string> points_neglect;
//    aurostd::string2tokens(vpflow.getattachedscheme("CHULL::NEGLECT"),points_neglect,",");
//    return calculateStabilityCriterion(vpflow,velements,points_neglect,vscriterion,FileMESSAGE,oss);
//  }
//  bool calculateStabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<string>& vauid,vector<double>& vscriterion,ostream& oss) {
//    ofstream FileMESSAGE;
//    return calculateStabilityCriterion(vpflow,velements,vauid,vscriterion,FileMESSAGE,oss);
//  }
//  bool calculateStabilityCriterion(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<string>& vauid,vector<double>& vscriterion,ofstream& FileMESSAGE,ostream& oss) {
//    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
//    string soliloquy=XPID+"chull::calculateStabilityCriterion():";
//    stringstream message;
//    
//    //don't only remove vauid, but also equivalent gstates
//    //we need organized points, simply initialize dummy hull instead of calculating TWO full hulls
//    ConvexHull dummy(vpflow,FileMESSAGE,oss);
//    try{dummy.initializePoints(velements);}
//    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), FileMESSAGE, oss, _LOGGER_ERROR_);return false;}
//    dummy.m_initialized=true; //hack so we can get at the g-states
//    uint i_point,i_coord_group,g_state;
//    vector<uint> eq_gstates;
//    bool found=false;
//    vector<ChullPoint> points_to_neglect; //follows vauid
//    for(uint i=0,fl_size_i=vauid.size();i<fl_size_i;i++){
//      const string& auid=vauid[i];
//      if(auid.empty()){
//        message << "Empty auid found";
//        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
//        return false;
//      }
//      if(!dummy.findPoint(auid,i_point)){
//        message << "Specified auid not found on hull (auid=" << auid << ")";
//        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
//        return false;
//      }
//      const ChullPoint& point=dummy.m_points[i_point];  //this point may not be on the hull, it may be an equivalent structure, but coordgroup is
//      if(!dummy.getCoordGroupIndex(point,i_coord_group)){
//        message << "Coordgroup index not set (auid=" << auid << ")";
//        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
//        return false;
//      }
//      if(!dummy.m_coord_groups[i_coord_group].m_points.size()){
//        message << "No points found within coordgroup (auid=" << auid << ")";
//        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
//        return false;
//      }
//      //assume user knows what he's doing, we will check for sure later
//      dummy.m_coord_groups[i_coord_group].m_is_on_hull=true;
//      g_state=dummy.m_coord_groups[i_coord_group].m_ref_state;
//      dummy.m_points[g_state].m_is_g_state=true;
//      eq_gstates=dummy.getEquivalentGStates(g_state);
//      if(!eq_gstates.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No equivalent states found (not even self)");}
//      //check to make sure entry with specified auid among gstates
//      found=false;
//      for(uint j=0,fl_size_j=eq_gstates.size();j<fl_size_j;j++){
//        if(dummy.m_points[eq_gstates[j]].m_entry.auid==auid){found=true;}
//        points_to_neglect.push_back(dummy.m_points[eq_gstates[j]]);
//      }
//      if(!found){
//        message << "Point was not found to be an equivalent ground-state structure (auid=" << auid << ")";
//        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
//        return false;
//      }
//    }
//    
//    //////////////////////////////////////////////////////////////////////////////
//    // START Getting entries to be neglected
//    //////////////////////////////////////////////////////////////////////////////
//  
//    vector<ChullPoint> new_points;
//    const vector<ChullPoint>& points=dummy.m_points;
//    for(uint i=0,fl_size_i=points.size();i<fl_size_i;i++){
//      if(points[i].m_is_artificial){continue;}  //they will be added again
//      found=false;
//      for(uint j=0,fl_size_j=points_to_neglect.size();j<fl_size_j&&!found;j++){
//        if(points[i].m_entry.auid==points_to_neglect[j].m_entry.auid){
//          message << "Removing equivalent ground-state (auid=" << points_to_neglect[j].m_entry.auid << ")";
//          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,FileMESSAGE,oss,_LOGGER_MESSAGE_);
//          found=true;
//        }
//      }
//      if(found){continue;}
//      new_points.push_back(points[i]);
//    }
//    
//    //////////////////////////////////////////////////////////////////////////////
//    // END Getting entries to be neglected
//    //////////////////////////////////////////////////////////////////////////////
//    
//    message << "Creating new hull without relevant g-states";
//    pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,FileMESSAGE,oss,_LOGGER_MESSAGE_);
//    aurostd::xoption cflags=vpflow;
//    cflags.flag("CHULL::SKIP_THERMO_PROPERTIES_EXTRACTION",true); //thermo properties NOT needed, just need hull
//    cflags.flag("CHULL::SKIP_STABILITY_CRITERION_ANALYSIS",true); //thermo properties NOT needed, just need hull
//    ConvexHull hull(cflags,new_points,velements,FileMESSAGE,oss,true,true);
//    if(!hull.m_initialized){return false;}
//    //since i_nary and i_alloy don't change, the getDistanceToHull function should work fine (getRelevantFacets())
//    uint i_nary,i_alloy;
//    for(uint i=0,fl_size_i=points_to_neglect.size();i<fl_size_i;i++) {
//      ChullPoint& point=points_to_neglect[i];
//      if(!dummy.getAlloyIndex(point,i_nary,i_alloy)){
//        message << "Alloy index not set (auid=" << point.m_entry.auid << ")";
//        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,FileMESSAGE,oss,_LOGGER_ERROR_);
//        return false;
//      }
//      if(point.isUnary()){point.setHullCoords();} //set to most general coords (m_coords), this reflects relevantFacets()
//      else {
//        xvector<int> elements_present=dummy.m_naries[i_nary].m_alloys[i_alloy].m_elements_present;
//        if(LDEBUG) {cerr << soliloquy << " elements_present=" << elements_present << endl;}
//        point.setHullCoords(elements_present);  //just to be sure
//      }
//      try{vscriterion.push_back(hull.getDistanceToHull(point));}
//      catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), FileMESSAGE, oss, _LOGGER_ERROR_);return false;}
//    }
//
//    return true;
//  }
//} // namespace chull

namespace chull {
  // ***************************************************************************
  // chull::convertUnits(double value,char units)
  // ***************************************************************************
  // returns value in desired units
  double convertUnits(double value, char units) {
    if(units == _m_) {return value * 1e3;}
    return value;
  }
  //these functions are auxiliary - if entry could be passed instead of point, then call these functions
  //otherwise, keep as methods of the ChullPoint class
  double H_f_atom(const ChullPoint& point, char units) {
    if(point.m_has_entry){return H_f_atom(point.m_entry,units);}
    if(point.m_formation_energy_coord){return convertUnits(point.getLastCoord(),units);}
    string soliloquy=XPID+"chull::H_f_atom():";
    throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No formation energy available for ChullPoint",_INPUT_ILLEGAL_);
    return AUROSTD_NAN;
  }
  double H_f_atom(const aflowlib::_aflowlib_entry& entry, char units){
    double d_tmp=entry.enthalpyFormationAtom(0);  //entry.enthalpy_formation_atom - ADDING CCE @ 0K
    if(d_tmp==AUROSTD_NAN){return AUROSTD_NAN;}
    return convertUnits(d_tmp,units);
  }
  double T_S(const ChullPoint& point){
    if(!point.m_has_entry){return AUROSTD_NAN;}
    return T_S(point.m_entry);
  }
  double T_S(const aflowlib::_aflowlib_entry& entry){
    double d_tmp=entry.entropic_temperature;
    if(d_tmp==AUROSTD_NAN){return AUROSTD_NAN;}
    return d_tmp;
  }
  double EFA(const ChullPoint& point, char units){
    if(!point.m_has_entry){return AUROSTD_NAN;}
    return EFA(point.m_entry,units);
  }
  double EFA(const aflowlib::_aflowlib_entry& entry, char units){
    double d_tmp=entry.entropy_forming_ability;
    if(d_tmp==AUROSTD_NAN){return AUROSTD_NAN;}
    return convertUnits(d_tmp,units);
  }
  double isoMaxLatentHeat(const ChullPoint& point, double x, char units){
    if(!point.m_has_entry){return AUROSTD_NAN;}
    return isoMaxLatentHeat(point.m_entry,x,units);
  }
  double isoMaxLatentHeat(const aflowlib::_aflowlib_entry& entry, double x, char units){
    if(T_S(entry)==AUROSTD_NAN){return AUROSTD_NAN;}
    if(x<=0||x>=1.0){return AUROSTD_NAN;} //protect log()
    double d_tmp=((double)KBOLTZEV)*T_S(entry)*(x*log(x)+(1.0-x)*log(1.0-x));
    return convertUnits(d_tmp,units);
  }

  int roundDouble(double doub, int multiple, bool up) {
    // rounds double to the nearest (multiple), choose round up or down
    // http://stackoverflow.com/questions/3407012/c-rounding-up-to-the-nearest-multiple-of-a-number
    // round up - round further from 0 if doub is positive, closer to 0 if doub is negative
    // opposite for round down
    // round up === MORE positive
    // round down === MORE negative
    // a little confusing, but a very powerful way to define for AXES MAX/MIN + INTERVALS
    int numToRound = round(doub);
    if(multiple == 0) {return numToRound;}
    int remainder = abs(numToRound) % multiple;
    if(remainder == 0) {return numToRound;}
    if(up) {
      if(numToRound < 0) {return -(abs(numToRound) - remainder);}
      else {return numToRound + multiple - remainder;}
    } else {  //down
      if(numToRound < 0) {return -(abs(numToRound) + (multiple - remainder));}
      else {return numToRound - remainder;}
    }
  }

  //for stoichiometries and results of an algorithm (distances from hull), use soft cutoff
  //otherwise, for above/below hull (stability from energy), use hard cutoff (per artificial points)
  //bool greaterEqualZero(double val,bool soft_cutoff){return ( soft_cutoff? val>=ZERO_TOL : val>=0.0 );}
  //bool lessEqualZero(double val,bool soft_cutoff){return ( soft_cutoff? val<=-ZERO_TOL : val<=0.0 );}
  bool greaterEqualZero(double val){return (val>=0.0);}
  bool lessEqualZero(double val){return (val<=0.0);}
  bool notPositive(double val,bool soft_cutoff,double tol){return (soft_cutoff? val<=tol : lessEqualZero(val));}
  bool notNegative(double val,bool soft_cutoff,double tol){return (soft_cutoff? val>=-tol : greaterEqualZero(val));}
  bool zeroWithinTol(double val,double tol){return notPositive(abs(val),true,tol);}
  bool nonZeroWithinTol(double val,double tol){return !zeroWithinTol(val,tol);}

  bool subspaceBelongs(const xvector<int>& space,const xvector<int>& subspace){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"chull::subspaceBelongs():";
    if(LDEBUG) {
      cerr << soliloquy << " space=" << space << endl;
      cerr << soliloquy << " subspace=" << subspace << endl;
    }
    if(subspace.rows!=space.rows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between space and subspace");}
    if(sum(subspace)>sum(space)){return false;}  //cannot be of higher dimension
    for(int i=subspace.lrows;i<=subspace.urows;i++){if(subspace[i]==1&&space[i]==0){return false;}}
    if(LDEBUG) {cerr << soliloquy << " is relevant!" << endl;}
    return true;
  }

  bool correctSignVerticalDistance(double dist_2_hull,bool should_be_positive) {
    if( should_be_positive && notPositive(dist_2_hull,true)){return false;}
    if(!should_be_positive && notNegative(dist_2_hull,true)){return false;}
    return true;
  }

  xvector<double> getTruncatedCoords(const xvector<double>& coords,const xvector<int>& elements_present) {
    string soliloquy=XPID+"chull::getTruncatedCoords():";
    if(coords.rows!=elements_present.rows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Reduction invalid, coords mismatch");}
    uint h_dim=sum(elements_present);
    xvector<double> red_coords(coords.lrows,coords.lrows+h_dim-1);
    vector<uint> relevant_indices=getRelevantIndices(elements_present);
    for(uint i=0,fl_size_i=relevant_indices.size();i<fl_size_i;i++){red_coords[i+red_coords.lrows]=coords[relevant_indices[i]];}
    return red_coords;
  }

  vector<uint> getRelevantIndices(const xvector<int>& elements_present) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"chull::getRelevantIndices():";
    vector<uint> relevant_indices;
    for(int i=elements_present.lrows;i<=elements_present.urows;i++){
      if(elements_present[i]==1){relevant_indices.push_back(i);}
    }
    if(LDEBUG) {
      cerr << soliloquy << " relevant indices=";
      for(uint i=0,fl_size_i=relevant_indices.size();i<fl_size_i;i++){cerr << relevant_indices[i] << (i!=relevant_indices.size()-1?",":"");}
      cerr << " (elements_present=" << elements_present << ")" << endl;
    }
    return relevant_indices;
  }

  bool coordsIdentical(const xvector<double>& coords1,const xvector<double>& coords2){return identical(coords1,coords2,ZERO_TOL);}
} // namespace chull

//CO20180420 - moved to xStream (xclasses.cpp)
//namespace chull {
////--------------------------------------------------------------------------------
//// class ChullClassTemplate
////--------------------------------------------------------------------------------
////--------------------------------------------------------------------------------
//// constructor
////--------------------------------------------------------------------------------
//ChullClassTemplate::ChullClassTemplate() : p_FileMESSAGE(NULL),f_new_ofstream(false) {} //{free();}
//ChullClassTemplate::~ChullClassTemplate() {freeAll();}
//void ChullClassTemplate::free() {}
//void ChullClassTemplate::xStream::free() {
//  //if(1){  //keep this OFF. technically, we will have a memory leak, but FacetPoint deletes p_FileMESSAGE prematurely. really, we need shared pointers.
//  p_oss=NULL;
//  if(f_new_ofstream){delete p_FileMESSAGE;}  //first delete, then set to null
//  p_FileMESSAGE=NULL;
//  f_new_ofstream=false;
//  //}
//}
//void ChullClassTemplate::freeAll(){free();xStream::free();}
//void ChullClassTemplate::setOFStream(ofstream& FileMESSAGE){p_FileMESSAGE=&FileMESSAGE;}
//void ChullClassTemplate::setOSS(ostream& oss) {p_oss=&oss;}
//} // namespace chull

namespace chull {
  //--------------------------------------------------------------------------------
  // class ChullPointLight
  //--------------------------------------------------------------------------------
  //--------------------------------------------------------------------------------
  // constructor
  //--------------------------------------------------------------------------------
  ChullPointLight::ChullPointLight(ostream& oss) : xStream(oss),m_initialized(false) {;}
  ChullPointLight::ChullPointLight(ofstream& FileMESSAGE,ostream& oss) : xStream(FileMESSAGE,oss),m_initialized(false) {;}
  ChullPointLight::ChullPointLight(const ChullPointLight& b) : xStream(*b.getOFStream(),*b.getOSS()) {copy(b);} // copy PUBLIC  //upcasting is allowed, works for ChullPointLight and ChullPoint

  ChullPointLight::~ChullPointLight() {xStream::free();free();}

  const ChullPointLight& ChullPointLight::operator=(const ChullPointLight& other) { //upcasting is allowed, works for ChullPointLight and ChullPoint
    if(this!=&other) {copy(other);}
    return *this;
  }
  bool ChullPointLight::operator<(const ChullPointLight& other) const {
    //NB: this is ALWAYS sorted in descending order of stoich, no need to make options for ascending order
    //but, sorts in ascending order for energy
    string soliloquy=XPID+"ChullPointLight::operator<():";
    if(m_coords.lrows!=other.m_coords.lrows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"m_coords.lrows!=other.m_coords.lrows");}
    if(m_coords.rows!=other.m_coords.rows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"m_coords.rows!=other.m_coords.rows");}
    for(int i=m_coords.lrows;i<=m_coords.urows;i++){if(m_coords[i]!=other.m_coords[i]){return (m_coords[i]<other.m_coords[i]);}}
    return false;
  }

  void ChullPointLight::clear() {free();}  //clear PUBLIC
  void ChullPointLight::free() {
    m_initialized=false;
    m_coords.clear();
    m_has_stoich_coords=false;
    m_formation_energy_coord=false;
    m_is_artificial=false;
    m_has_entry=false;
    m_i_nary=AUROSTD_MAX_UINT;
    m_i_alloy=AUROSTD_MAX_UINT;
    h_coords.clear();
  }

  void ChullPointLight::copy(const ChullPointLight& b) {  //copy PRIVATE  //upcasting is allowed, works for ChullPointLight and ChullPoint
    xStream::copy(b);
    m_initialized=b.m_initialized;
    m_coords=b.m_coords;
    m_has_stoich_coords=b.m_has_stoich_coords;
    m_formation_energy_coord=b.m_formation_energy_coord;
    m_is_artificial=b.m_is_artificial;
    m_has_entry=b.m_has_entry;
    m_i_nary=b.m_i_nary;
    m_i_alloy=b.m_i_alloy;
    h_coords=b.h_coords;
  }

  double ChullPointLight::getLastCoord() const {return m_coords[m_coords.urows];}

  //--------------------------------------------------------------------------------
  // class ChullPoint
  //--------------------------------------------------------------------------------
  //--------------------------------------------------------------------------------
  // constructor
  //--------------------------------------------------------------------------------
  ChullPoint::ChullPoint(ostream& oss,bool has_stoich_coords,bool formation_energy_coord,bool is_artificial) : ChullPointLight(oss) {initialize(has_stoich_coords,formation_energy_coord,is_artificial);}
  ChullPoint::ChullPoint(const xvector<double>& coord,ostream& oss,bool has_stoich_coords,bool formation_energy_coord,bool is_artificial) : ChullPointLight(oss) {initialize(coord,has_stoich_coords,formation_energy_coord,is_artificial);}
  ChullPoint::ChullPoint(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,ostream& oss,bool formation_energy_coord) : ChullPointLight(oss) {initialize(velements,entry,formation_energy_coord);}
  ChullPoint::ChullPoint(ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool formation_energy_coord,bool is_artificial) : ChullPointLight(FileMESSAGE,oss) {initialize(has_stoich_coords,formation_energy_coord,is_artificial);}
  ChullPoint::ChullPoint(const xvector<double>& coord,ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool formation_energy_coord,bool is_artificial) : ChullPointLight(FileMESSAGE,oss) {initialize(coord,has_stoich_coords,formation_energy_coord,is_artificial);}
  ChullPoint::ChullPoint(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,ofstream& FileMESSAGE,ostream& oss,bool formation_energy_coord) : ChullPointLight(FileMESSAGE,oss) {initialize(velements,entry,formation_energy_coord);}
  ChullPoint::ChullPoint(const ChullPoint& b) : xStream(*b.getOFStream(),*b.getOSS()),ChullPointLight(b) {copy(b);} // copy PUBLIC

  ChullPoint::~ChullPoint() {xStream::free();free();}

  const ChullPoint& ChullPoint::operator=(const ChullPoint& other) {
    if(this!=&other) {copy(other);}
    return *this;
  }

  void ChullPoint::clear() {free();}  //clear PUBLIC
  void ChullPoint::free() {
    ChullPointLight::free();
    m_entry.clear(); if(m_entry.vsg.size()==0){m_entry.vsg.push_back(NOSG);} if(m_entry.vsg2.size()==0){m_entry.vsg2.push_back(NOSG);}  //hack so it doesn't break with front(),back(),[0]
    s_coords.clear();
    c_coords.clear();
    m_elements_present.clear();
    cleanPointForHullTransfer();
  }

  void ChullPoint::copy(const ChullPoint& b) {  //copy PRIVATE
    //xStream::copy(b); //done inside ChullPointLight::copy()
    ChullPointLight::copy(b);
    m_entry=b.m_entry; if(m_entry.vsg.size()==0){m_entry.vsg.push_back(NOSG);} if(m_entry.vsg2.size()==0){m_entry.vsg2.push_back(NOSG);}  //hack so it doesn't break with front(),back(),[0]
    m_i_coord_group=b.m_i_coord_group;
    s_coords=b.s_coords;
    c_coords=b.c_coords;
    m_elements_present=b.m_elements_present;
    m_is_on_hull=b.m_is_on_hull;
    m_is_g_state=b.m_is_g_state;
    m_is_equivalent_g_state=b.m_is_equivalent_g_state;
    m_is_sym_equivalent_g_state=b.m_is_sym_equivalent_g_state;
    m_dist_2_hull=b.m_dist_2_hull;
    //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]m_decomp_coefs=b.m_decomp_coefs;
    m_stability_criterion=b.m_stability_criterion;
    m_n_plus_1_enthalpy_gain=b.m_n_plus_1_enthalpy_gain;
  }

  bool ChullPoint::initialize(ostream& oss,bool has_stoich_coords,bool formation_energy_coord,bool is_artificial) {
    xStream::initialize(oss);
    return initialize(has_stoich_coords,formation_energy_coord,is_artificial);
  }

  bool ChullPoint::initialize(const xvector<double>& coord,ostream& oss,bool has_stoich_coords,bool formation_energy_coord,bool is_artificial) {
    xStream::initialize(oss);
    return initialize(coord,has_stoich_coords,formation_energy_coord,is_artificial);
  }

  bool ChullPoint::initialize(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,ostream& oss,bool formation_energy_coord) {
    xStream::initialize(oss);
    return initialize(velements,entry,formation_energy_coord);
  }

  bool ChullPoint::initialize(ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool formation_energy_coord,bool is_artificial) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(has_stoich_coords,formation_energy_coord,is_artificial);
  }

  bool ChullPoint::initialize(const xvector<double>& coord,ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool formation_energy_coord,bool is_artificial) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(coord,has_stoich_coords,formation_energy_coord,is_artificial);
  }

  bool ChullPoint::initialize(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,ofstream& FileMESSAGE,ostream& oss,bool formation_energy_coord) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(velements,entry,formation_energy_coord);
  }

  bool ChullPoint::initialize(bool has_stoich_coords,bool formation_energy_coord,bool is_artificial) {
    free();
    m_has_stoich_coords=has_stoich_coords;
    m_formation_energy_coord=formation_energy_coord;
    m_is_artificial=is_artificial;
    m_initialized=false;  //no point
    return m_initialized;
  }

  bool ChullPoint::initialize(const xvector<double>& coord,bool has_stoich_coords,bool formation_energy_coord,bool is_artificial) {
    //we start by setting the most general coords, m_coords, relating to highest d-hull
    //then, if we can, we derive stoich and composition coords
    //it may seem "backwards", as stoich and composition are most accesible to entries, but
    //this code is GENERAL (any type of coords, not just energy/stoich)
    free();
    initializeCoords(coord,formation_energy_coord);
    m_has_stoich_coords=has_stoich_coords;
    if(m_has_stoich_coords){setStoichCoords();}
    m_is_artificial=is_artificial;
    m_initialized=true;
    return m_initialized;
  }

  bool ChullPoint::initialize(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,bool formation_energy_coord) {
    //we start by setting the most general coords, m_coords, relating to highest d-hull
    //then, if we can, we derive stoich and composition coords
    //it may seem "backwards", as stoich and composition are most accesible to entries, but
    //this code is GENERAL (any type of coords, not just energy/stoich)
    free();
    initializeCoords(velements,entry,formation_energy_coord);
    m_has_stoich_coords=true;
    setStoichCoords();
    m_is_artificial=false;
    m_initialized=true;
    return m_initialized;
  }

  //use hard cutoff here
  bool ChullPoint::isWithinHalfHull(bool lower_hull) const {return (lower_hull ? lessEqualZero(getLastCoord()) : greaterEqualZero(getLastCoord()) );}

  bool ChullPoint::isGState() const {
    string soliloquy=XPID+"ChullPoint::isGState():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    return m_is_on_hull || m_is_g_state || m_is_equivalent_g_state;
  }

  xvector<double> ChullPoint::getStoichiometricCoords() const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::getStoichiometricCoords():";
    if(LDEBUG){cerr << soliloquy << " BEGIN" << endl;}
    if(m_coords.rows==1){ //trivial unary hull
      if(LDEBUG){cerr << soliloquy << " m_coords.rows==1: generating null xvector" << endl;}
      if(!isUnary()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Found non-unary point on unary hull",_INPUT_UNKNOWN_);}
      xvector<double> r_coords=aurostd::null_xv<double>(); //get null vector //(m_coords.lrows,m_coords.lrows);  //just return vector length 1 with 0 inside
      if(LDEBUG){cerr << soliloquy << " r_coords=" << r_coords << endl;}
      return r_coords;
    }
    xvector<double> r_coords(m_coords.lrows,m_coords.urows-1);
    for(int i=m_coords.lrows;i<=m_coords.urows-1;i++){r_coords[i]=m_coords[i];}
    if(LDEBUG){cerr << soliloquy << " r_coords=" << r_coords << endl;}
    return r_coords;
  }

  xvector<double> ChullPoint::getTruncatedReducedCoords(const xvector<int>& elements_present,vector_reduction_type vred) const {
    string soliloquy=XPID+"ChullPoint::getTruncatedReducedCoords():";
    if(vred==frac_vrt || vred==no_vrt){return getTruncatedSCoords(elements_present);}
    else if(vred==gcd_vrt){return getTruncatedCCoords(elements_present,true);}
    else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown reduce mode",_INPUT_UNKNOWN_);}
    xvector<double> out;return out;
  }

  xvector<double> ChullPoint::getTruncatedSCoords(const xvector<int>& elements_present) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::getTruncatedSCoords():";
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    xvector<double> coords=getTruncatedCoords(s_coords,elements_present);
    if(LDEBUG) {cerr << soliloquy << " truncated stoich for " << s_coords << " is " << coords << " (elements_present=" << elements_present << ")" << endl;}
    return coords;
  }

  xvector<double> ChullPoint::getTruncatedCCoords(const xvector<int>& elements_present,bool reduce) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::getTruncatedCCoords():";
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    xvector<double> coords=getTruncatedCoords(c_coords,elements_present);
    //DX20191125 [OBSOLETE] if(reduce){coords=aurostd::reduceByGCD(coords);}
    //DX20191125 [OBSOLETE] if(LDEBUG) {cerr << soliloquy << " truncated " << (reduce?"reduced":"") << " comp for " << c_coords << " is " << coords << " (elements_present=" << elements_present << ")" << endl;}
    //DX20191125 [OBSOLETE] return coords;
    xvector<double> final_coords=coords; //DX20191125
    if(reduce){ aurostd::reduceByGCD(coords, final_coords);} //DX20191125 - new form of function
    if(LDEBUG) {cerr << soliloquy << " truncated " << (reduce?"reduced":"") << " comp for " << c_coords << " is " << final_coords << " (elements_present=" << elements_present << ")" << endl;} //DX20191125 - changed coords to final_coords
    return final_coords; //DX20191125 - changed coords to final_coords
  }

  xvector<double> ChullPoint::getReducedCCoords() const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::getReducedCCoords():";
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    xvector<double> coords; aurostd::reduceByGCD(c_coords,coords,ZERO_TOL); //DX20191125 - new form of function
    if(LDEBUG) {cerr << soliloquy << " reduced comp for " << c_coords << " is " << coords << endl;}
    return coords;
  }

  uint ChullPoint::loadXstructures(bool relaxed_only) {  //load relaxed only
    if(m_entry.prototype.find("POCC")!=string::npos){return false;} //POCC entries have no composition
    if(!pflow::loadXstructures(m_entry,*p_FileMESSAGE,*p_oss,relaxed_only)){return false;}
    return m_entry.vstr.size();
  }

  bool ChullPoint::getMostRelaxedXstructure(xstructure& xstr) const { //this is const!
    if(m_entry.prototype.find("POCC")!=string::npos){return false;} //POCC entries have no composition
    aflowlib::_aflowlib_entry entry; entry.auid=m_entry.auid; entry.aurl=m_entry.aurl;  //fast copy
    if(!pflow::loadXstructures(entry,*p_FileMESSAGE,*p_oss,true)){return false;}
    if(entry.vstr.size()==1){xstr=entry.vstr[0]; return true;}
    return false;
  }

  //small get()'s of fundamental types get copies, otherwise const&
  uint ChullPoint::getDim() const {return m_coords.rows;}
  bool ChullPoint::isUnary() const {return m_i_nary==0;}
  double ChullPoint::getFormationEnthalpy() const {return H_f_atom(*this,_std_);} //m_entry.enthalpy_formation_atom;
  double ChullPoint::getEntropicTemperature() const {return T_S(*this);} //m_entry.entropic_temperature;
  double ChullPoint::getEntropyFormingAbility() const {return EFA(*this,_std_);} //m_entry.entropic_temperature;
  const vector<string>& ChullPoint::getVSG() const {return m_entry.vsg2;}
  const string& ChullPoint::getSG() const {return getVSG().back();}  //tight tolerance fine!  //vsg === LOOSE //vsg2 === TIGHT // doesn't make sense
  double ChullPoint::getDist2Hull(char units) const {
    if(m_dist_2_hull==AUROSTD_MAX_DOUBLE){return AUROSTD_MAX_DOUBLE;}
    if(m_formation_energy_coord){return convertUnits(m_dist_2_hull,units);}
    else {return m_dist_2_hull;}  //no unit conversions coded yet here
  }
  double ChullPoint::getStabilityCriterion(char units) const {
    if(m_stability_criterion==AUROSTD_MAX_DOUBLE){return AUROSTD_MAX_DOUBLE;}
    if(m_formation_energy_coord){return convertUnits(m_stability_criterion,units);}
    else {return m_stability_criterion;}  //no unit conversions coded yet here
  }
  double ChullPoint::getRelativeStabilityCriterion() const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::getRelativeStabilityCriterion():";
    if(m_stability_criterion==AUROSTD_MAX_DOUBLE){return AUROSTD_MAX_DOUBLE;}
    if(aurostd::identical(getLastCoord(),0.0,ZERO_TOL)){return 0.0;}
    if(LDEBUG) {
      cerr << soliloquy << " m_stability_criterion=" << m_stability_criterion << endl;
      cerr << soliloquy << " getLastCoord()=" << getLastCoord() << endl;
    }
    return abs(m_stability_criterion/getLastCoord()); //abs() because they are generally opposite signs //delivers as decimal, show as percentage
  }
  double ChullPoint::getNPlus1EnthalpyGain(char units) const {
    if(m_n_plus_1_enthalpy_gain==AUROSTD_MAX_DOUBLE){return AUROSTD_MAX_DOUBLE;}
    if(m_formation_energy_coord){return convertUnits(m_n_plus_1_enthalpy_gain,units);}
    else {return m_n_plus_1_enthalpy_gain;}  //no unit conversions coded yet here
  }
  double ChullPoint::getEntropyStabilizationCoefficient(char units) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::getEntropyStabilizationCoefficient():";
    if(getDist2Hull()==AUROSTD_MAX_DOUBLE){return AUROSTD_MAX_DOUBLE;}
    if(getEntropyFormingAbility()==AUROSTD_NAN){return AUROSTD_MAX_DOUBLE;}
    if(zeroWithinTol(getEntropyFormingAbility())){return 0.0;} //protect from division by zero
    if(LDEBUG) {
      cerr << soliloquy << " dist2hull=" << getDist2Hull() << endl;
      cerr << soliloquy << " EFA=" << getEntropyFormingAbility() << endl;
    }
    return convertUnits(sqrt(getDist2Hull() / getEntropyFormingAbility()),units);
  }


  /// \brief sort the vertex indexes based on their angle around a central normal vector
  /// \param facet list of vertex indexes forming the facet
  /// \param facet_id id of one of the original facets (to use its already calculated normal vector)
  ///
  /// Sorting the vertex indexes avoid crossing lines when drawing or calculating the area or volume later.
  void ConvexHull::sortFacetVertices(vector<uint> &facet, const uint &facet_id){//HE20210510
    xvector<double> center(3,1);
    const uint num_points = facet.size();
    xvector<uint> index_list(num_points,1);
    xvector<double> angle_list(num_points,1);
    for (std::vector<uint>::const_iterator p_id = facet.begin(); p_id != facet.end(); ++p_id) center += m_points[*p_id].m_coords;

    center /= num_points;
    const xvector<double> start_vector = m_points[facet[0]].m_coords - center;
    const xvector<double> normal = m_facets[facet_id].m_normal;

    // first index is used for the start_vector, therefore the angle is set to 0.0
    angle_list[1] = 0;
    index_list[1] = facet[0];
    for (uint i=1; i<num_points; i++){
      const xvector<double> next_vector = m_points[facet[i]].m_coords - center;
      const double dot = aurostd::scalar_product(start_vector, next_vector);
      const double det = start_vector[1]*next_vector[2]*normal[3] + next_vector[1]*normal[2]*start_vector[3] + normal[1]*start_vector[2]*next_vector[3]
        - start_vector[3]*next_vector[2]*normal[1] - next_vector[3]*normal[2]*start_vector[1] - normal[3]*start_vector[2]*next_vector[1];
      angle_list[i+1] = atan2(det, dot);
      index_list[i+1] = facet[i];
    }
    aurostd::quicksort2(num_points, angle_list, index_list);
    for (uint i=0; i<num_points; i++) facet[i] = index_list[i+1];
  }

  /// @brief generates list of facets, if two neighboring facets are coplanar join them
  /// @param facet_collection output vector containing lists of vertex indexes
  /// @param angle_threshold max angle between two facts in radian to be still considered coplanar
  /// @note the facets contain only vertices
  void ConvexHull::getJoinedFacets(vector<vector<uint> > &facet_collection, const double angle_threshold) {//HE20210510
    bool LDEBUG=(false || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getJoinedFacets():";

    if (m_dim != 3) throw aurostd::xerror(_AFLOW_FILE_NAME_, soliloquy, "facet joining is just available in 3D", _VALUE_RANGE_);
    vector <vector<uint> > raw_facets;
    vector<xvector<double> > normals;
    std::map<uint, vector<uint> >  point_neighbors;
    std::list<std::pair<uint, uint> > raw_join_list;
    vector<vector<uint> > join_list;
    vector<uint> remove_facet;
    vector<vector<uint> > raw_facet_collection;
    std::map<uint, uint> corner_check;

    // Collect information on each facet
    for (std::vector<ChullFacet>::const_iterator facet = h_facets.begin(); facet != h_facets.end(); ++facet){

      vector <uint> vertices;

      // Represent facet based on the vertices indexes
      for(std::vector<chull::FacetPoint>::const_iterator vert = facet->m_vertices.begin(); vert != facet->m_vertices.end(); ++vert){
        vertices.push_back(vert->ch_index);
      }
      raw_facets.push_back(vertices);
      normals.push_back(facet->m_normal);
    }


    // Build lookup for neighboring points
    // (Base point is included to make a check easier)
    for (std::vector<vector<uint> >::const_iterator facet = raw_facets.begin(); facet != raw_facets.end(); ++facet){
      for (std::vector<uint>::const_iterator ind = facet->begin(); ind != facet->end(); ++ind){
        std::copy(facet->begin(),facet->end(), std::inserter(point_neighbors[*ind],point_neighbors[*ind].end()));
      }
    }

    // Ensure that point_neighbors is unique
    for (std::map<uint, vector<uint> >::iterator point_neighbors_entry = point_neighbors.begin();
        point_neighbors_entry != point_neighbors.end(); ++point_neighbors_entry){
      std::sort(point_neighbors_entry->second.begin(),point_neighbors_entry->second.end());
      point_neighbors_entry->second.erase( std::unique( point_neighbors_entry->second.begin(), point_neighbors_entry->second.end() ), point_neighbors_entry->second.end() );
    }

    uint raw_facets_size = raw_facets.size();
    // Check for each facet, if their neighbors have an equivalent normal vector
    if (LDEBUG) cerr << soliloquy << " coplanar | angle | facets | n1 | n2" << endl;
    for (uint i1=0; i1<raw_facets_size; i1++){
      const vector<uint> base_facet = raw_facets[i1];
      for (uint i2=i1+1; i2<raw_facets_size; i2++){
        uint check=0;
        const vector<uint> compare_facet = raw_facets[i2];
        for (uint k=0; k<3; k++) {
          for (uint j=0; j<3; j++) {
            if (base_facet[k]==compare_facet[j]) check++;
          }
        }
        // neighbor share two vertices
        if (check != 2) continue;
        double check_angle = aurostd::angle(normals[i1], normals[i2]);
        if (check_angle<angle_threshold){
          if(LDEBUG) cerr << soliloquy << " YES | ";
          raw_join_list.push_back(std::make_pair(i1, i2));
          remove_facet.push_back(i1);
          remove_facet.push_back(i2);
        }
        else {
          if (LDEBUG) cerr << soliloquy << " NO  | ";
        }
        if (LDEBUG) {
          cerr << check_angle << " | ";
          cerr << i1 << ", " << i2 << " | ";
          for (uint k=1; k<4; k++) cerr << normals[i1][k] << ", ";
          cerr << "| ";
          for (uint k=1; k<4; k++) cerr << normals[i2][k] << ", ";
          cerr << endl;
        }
      }
    }

    // Combine the joined pairs into complete facets
    while (raw_join_list.size()){
      std::pair<uint, uint> start=*raw_join_list.begin();
      vector<uint> new_facet;
      new_facet.push_back(start.first); new_facet.push_back(start.second);
      raw_join_list.erase(std::find(raw_join_list.begin(), raw_join_list.end(), start));
      std::vector<std::pair<uint, uint> > to_delete;
      uint found = 1;
      while (found){
        found = 0;
        to_delete.clear();
        for (std::list< std::pair<uint, uint> >::const_iterator next_ptr = raw_join_list.begin(); next_ptr != raw_join_list.end(); ++next_ptr) {
          std::pair<uint, uint> next = *next_ptr;
          if (std::find(new_facet.begin(), new_facet.end(), next.first) != new_facet.end()) {
            found ++;
            new_facet.push_back(next.second);
            to_delete.push_back(next);
          }
          else if (std::find(new_facet.begin(), new_facet.end(), next.second) != new_facet.end())  {
            found ++;
            new_facet.push_back(next.first);
            to_delete.push_back(next);
          }
        }
        for (std::vector<std::pair<uint, uint> >::const_iterator next = to_delete.begin(); next != to_delete.end(); ++next) {
          raw_join_list.erase(std::find(raw_join_list.begin(), raw_join_list.end(), *next));
        }
      }
      join_list.push_back(new_facet);
    }

    // Build the raw facet collection
    //HE20220319 sorting needed for consistent 3D rendering (the order defines the facet normal)
    for (uint i=0; i<raw_facets_size; i++){
      sortFacetVertices(raw_facets[i], i);
      if (std::find(remove_facet.begin(), remove_facet.end(), i) == remove_facet.end()) raw_facet_collection.push_back(raw_facets[i]);
    }
    // Add joined facets
    for (std::vector<vector<uint> >::const_iterator to_join = join_list.begin(); to_join != join_list.end(); ++to_join) {
      vector<uint> vertices;
      for (vector<uint>::const_iterator f_id = to_join->begin(); f_id != to_join->end(); ++f_id) {
        for (std::vector<uint>::const_iterator p_id = raw_facets[*f_id].begin(); p_id != raw_facets[*f_id].end(); ++p_id) {
          if (std::find(vertices.begin(), vertices.end(), *p_id) == vertices.end()) vertices.push_back(*p_id); // ensure vertices vector is unique
        }
      }
      // sort the vertices for std::set_difference(); point_neighbors are already sorted
      std::sort(vertices.begin(), vertices.end());

      // If a vertex has no outside neighbor it is removed
      vector<uint> vertices_to_remove;
      for (vector<uint>::const_iterator p_id = vertices.begin(); p_id != vertices.end(); ++p_id){
        std::vector<uint> diff_result;
        std::set_difference(point_neighbors[*p_id].begin(), point_neighbors[*p_id].end(), vertices.begin(), vertices.end(), std::inserter(diff_result, diff_result.end()));
        if (!diff_result.size()) vertices_to_remove.push_back(*p_id);
      }
      for (std::vector<uint>::const_iterator p_id = vertices_to_remove.begin(); p_id != vertices_to_remove.end(); ++p_id) {
        vertices.erase(std::find(vertices.begin(), vertices.end(), *p_id));
      }
      //HE20220319 never add facet with less than three vertices
      if (vertices.size()>=3) {
        sortFacetVertices(vertices, *to_join->begin());
        raw_facet_collection.push_back(vertices);
      }
    }

    // remove points that are on an edge and not a corner
    for (uint i_facet = 0; i_facet < raw_facet_collection.size(); i_facet++) {
      for (uint i_vert = 0; i_vert < raw_facet_collection[i_facet].size(); i_vert++) {
        corner_check[raw_facet_collection[i_facet][i_vert]]++;
      }
    }

    for (uint i_facet = 0; i_facet < raw_facet_collection.size(); i_facet++) {
      vector<uint> vec_vertices;
      for (uint i_vert = 0; i_vert < raw_facet_collection[i_facet].size(); i_vert++) {
        if (corner_check[raw_facet_collection[i_facet][i_vert]]>2)  vec_vertices.push_back(raw_facet_collection[i_facet][i_vert]);
      }
      facet_collection.push_back(vec_vertices);
    }
    //HE20220413 START
    // Check for ghost facets with less than 3 vertices
    // (they can be created when joining facets that are not perfectly coplanar)
    // start with the largest index when removing, as vector will shrink and indexes would change
    for (uint i_facet=facet_collection.size()-1; i_facet > 0; i_facet--){
      if (facet_collection[i_facet].size() <= 2) {
        facet_collection.erase(facet_collection.begin() + i_facet);
      }
    }
    //HE20220413 END
  }
  //since we don't check ALL attributes of entry, then we weed out MORE
  //entries existing in different catalogs will not be strictly identical
  //avoid this by comparing only the most pertinent information
  bool ChullPoint::entryIdentical(const aflowlib::_aflowlib_entry& other) const {
    return (m_entry.compound==other.compound) && 
      (m_entry.prototype==other.prototype) && //believe it or not, compound + prototype is PROBABLY enough, but let's be sure
      (aurostd::identical(H_f_atom(m_entry,_std_),H_f_atom(other,_std_),ENERGY_TOL)); //&&
    //[UNRELIABLE BECAUSE OF TOLERANCE](m_entry.vsg2==other.vsg2);
  }

  void ChullPoint::initializeCoords(const xvector<double>& coord,bool formation_energy_coord) {
    setGenCoords(coord,formation_energy_coord);
    setHullCoords();  //default, will change later with increasing dims
  }

  void ChullPoint::initializeCoords(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,bool formation_energy_coord) {
    addEntry(entry);
    setGenCoords(velements,m_entry,formation_energy_coord);
    setHullCoords();  //default, will change later with increasing dims
    m_has_entry=true;
  }

  void ChullPoint::addEntry(const aflowlib::_aflowlib_entry& entry) {
    m_entry=entry;
    if(CORRECT_BAD_DATABASE){m_entry.correctBadDatabase(*p_FileMESSAGE,true,*p_oss);} //verbose //carried over from apennsy (SC)
  }

  void ChullPoint::setGenCoords(const xvector<double>& coord,bool formation_energy_coord) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::setGenCoords():";
    m_coords=coord;//aurostd::shiftlrows(m_coords,0);
    m_formation_energy_coord=formation_energy_coord;
    if(LDEBUG) {cerr << soliloquy << " m_within_half_hull=" << isWithinHalfHull(m_formation_energy_coord) << endl;}  //m_formation_energy_coord===lower_hull
  }

  void ChullPoint::setGenCoords(const vector<string>& velements,const aflowlib::_aflowlib_entry& entry,bool formation_energy_coord) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::setGenCoords():";
    if(entry.vcomposition.size()==0&&entry.vstoichiometry.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No vcomposition or vstoichiometry found for entry.auid="+entry.auid,_RUNTIME_ERROR_);}
    xvector<double> coord(velements.size());
    bool found=false; //not necessary, we already check in entryValid()
    double c_sum=0.0;
    if(entry.vcomposition.size()>0){
      for(uint i=0,fl_size_i=entry.vcomposition.size();i<fl_size_i;i++){c_sum+=entry.vcomposition[i];}  //derive stoich exactly!
      if(c_sum==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"c_sum==0 (entry.auid="+entry.auid+",entry.aurl="+entry.aurl+")",_RUNTIME_ERROR_);}
      for(uint i=0,fl_size_i=velements.size();i<fl_size_i-1;i++){
        found=false;
        for(uint j=0,fl_size_j=entry.vspecies.size();j<fl_size_j && !found;j++){
          if(velements[i]==entry.vspecies[j]){
            coord[i+coord.lrows]=entry.vcomposition[j]/c_sum;
            found=true;
          }
        }
        //[might be from lower hull]if(!found){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"element not found: "+velements[i],_RUNTIME_ERROR_);}
      }
    }else{  //pocc structures have no vcomposition, only vstoichiometry
      //get exact fraction
      int numerator=0,denominator=0;
      double stoich=0.0;
      vector<double> vstoich;
      if(LDEBUG){cerr << soliloquy << " converting stoich[aurl=" << entry.aurl << "]=" << aurostd::joinWDelimiter(aurostd::vecDouble2vecString(entry.vstoichiometry),",") << " to fractions" << endl;}
      for(uint i=0,fl_size_i=entry.vstoichiometry.size();i<fl_size_i;i++){  //derive stoich exactly!
        aurostd::double2fraction(entry.vstoichiometry[i],numerator,denominator,DEFAULT_POCC_STOICH_TOL);  //ZERO_TOL*10 is preferred, but due to buy in GetStoich(), use DEFAULT_POCC_STOICH_TOL instead (for now) //ZERO_TOL=1e-8, make slightly looser than what's written to aflowlib.out
        stoich=(double)numerator/(double)denominator;
        c_sum+=stoich;
        vstoich.push_back(stoich);
      }
      if(c_sum==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"c_sum==0 (entry.auid="+entry.auid+",entry.aurl="+entry.aurl+")",_RUNTIME_ERROR_);}
      if(!aurostd::identical(c_sum,1.0,ZERO_TOL)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"c_sum!=1 (entry.auid="+entry.auid+",entry.aurl="+entry.aurl+")",_RUNTIME_ERROR_);}
      for(uint i=0,fl_size_i=velements.size();i<fl_size_i-1;i++){
        found=false;
        for(uint j=0,fl_size_j=entry.vspecies.size();j<fl_size_j && !found;j++){
          if(velements[i]==entry.vspecies[j]){
            coord[i+coord.lrows]=vstoich[j]/c_sum;
            found=true;
          }
        }
        //[might be from lower hull]if(!found){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"element not found: "+velements[i],_RUNTIME_ERROR_);}
      }
      if(0){  //entry.vstoichiometry has write round-offs, better to derive fraction exactly
        for(uint i=0,fl_size_i=entry.vstoichiometry.size();i<fl_size_i;i++){c_sum+=entry.vstoichiometry[i];}  //derive stoich exactly!
        if(c_sum==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"c_sum==0 (entry.auid="+entry.auid+",entry.aurl="+entry.aurl+")",_RUNTIME_ERROR_);}
        for(uint i=0,fl_size_i=velements.size();i<fl_size_i-1;i++){
          found=false;
          for(uint j=0,fl_size_j=entry.vspecies.size();j<fl_size_j && !found;j++){
            if(velements[i]==entry.vspecies[j]){
              coord[i+coord.lrows]=entry.vstoichiometry[j]/c_sum;
              found=true;
            }
          }
          //[might be from lower hull]if(!found){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"element not found: "+velements[i],_RUNTIME_ERROR_);}
        }
      }
    }
    if(formation_energy_coord){coord[coord.urows]=H_f_atom(entry);} //entry.enthalpy_formation_atom
    else {coord[coord.urows]=entry.entropic_temperature;}  //entropic temperature is positive for stable compounds (we want upper half convex-hull)
    setGenCoords(coord,formation_energy_coord);
  }

  vector<uint> ChullPoint::getRelevantIndices(const xvector<int>& elements_present) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::getRelevantIndices():";
    if(LDEBUG){cerr << soliloquy << " BEGIN" << endl;}
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    if(elements_present.rows!=s_coords.rows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between point and elements_present");}
    for(int i=elements_present.lrows;i<=elements_present.urows;i++){
      if(elements_present[i]==0 && nonZeroWithinTol(s_coords[i])){
        stringstream message;
        message << "Attempting to reduce non-zero coord (i=" << i << ",s_coords=" << s_coords << "), ";
        message << "elements_present=" << elements_present;
        throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);
      }
    }
    return chull::getRelevantIndices(elements_present);
  }

  void ChullPoint::setStoichCoords() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::setStoichCoords():";
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates: aurl="+m_entry.aurl);}
    double c_sum=0.0; //concentration sum
    xvector<double> stoich(m_coords.urows,m_coords.lrows);
    xvector<int> elements_present(m_coords.urows,m_coords.lrows);
    if(LDEBUG) {cerr << soliloquy << " m_coords=" << m_coords << endl;}
    for(int j=m_coords.lrows;j<=m_coords.urows-1;j++){
      if(std::signbit(m_coords[j])){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Negative stoich coordinate found: aurl="+m_entry.aurl);} //no negative numbers in stoich coordinates, only energy
      stoich[j]=m_coords[j];
      if(nonZeroWithinTol(m_coords[j])){elements_present[j]=1;}
      c_sum+=m_coords[j];
    }
    stoich[stoich.urows]=(1.0-c_sum); //hidden dimension
    if(std::signbit(stoich[stoich.urows])){
      //necessary check now because POCC entries have no composition, only stoich, so write-out errors will be prevalent
      if(zeroWithinTol(stoich[stoich.urows])){stoich[stoich.urows]=0.0;}  //only zero out for the last coord, as it's derived from the subtraction of the others
      else{throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Negative stoich coordinate found: aurl="+m_entry.aurl);}
    }  //no negative numbers
    if(nonZeroWithinTol(stoich[stoich.urows])){elements_present[elements_present.urows]=1;}   //check if nary++
    s_coords=stoich;
    c_coords=s_coords;
    if(m_has_entry){
      c_sum=0.0;
      for(uint i=0,fl_size_i=m_entry.vcomposition.size();i<fl_size_i;i++){c_sum+=m_entry.vcomposition[i];}  //essentially UNDO s_coords calculation
      c_coords*=c_sum;
    }
    m_elements_present=elements_present;
    m_i_nary=sum(elements_present)-1;
    setHullCoords(elements_present);  //default, will change later with increasing dims
  }

  void ChullPoint::setHullCoords() {setHullCoords(m_coords);}  //default to m_coords
  void ChullPoint::setHullCoords(const xvector<double>& coords) {h_coords=coords;}
  void ChullPoint::setHullCoords(const xvector<int>& elements_present) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::setHullCoords():";
    if(LDEBUG) {
      cerr << soliloquy << " elements_present=" << elements_present << endl;
      cerr << soliloquy << " s_coords=" << s_coords << endl;
      cerr << soliloquy << " c_coords=" << c_coords << endl;
    }
    xvector<double> coords=chull::getTruncatedCoords(m_coords,elements_present);
    //vector<uint> relevant_indices=getRelevantIndices(elements_present);
    //for(uint i=0,fl_size_i=relevant_indices.size();i<fl_size_i;i++){coords[i+coords.lrows]=m_coords[relevant_indices[i]];}
    coords[coords.urows]=getLastCoord(); //overwrite last coord appropriately
    if(LDEBUG) {cerr << soliloquy << " setting h_coords=" << coords << endl;}
    setHullCoords(coords);
  }

  void ChullPoint::reduceCoords(const xvector<int>& elements_present) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullPoint::reduceCoords():";

    //redoing a bit of ChullPoint::initialize()
    if(LDEBUG){cerr << soliloquy << " m_coords(pre )=" << m_coords << endl;}
    xvector<double> coords=chull::getTruncatedCoords(m_coords,elements_present);
    coords[coords.urows]=getLastCoord(); //overwrite last coord appropriately
    initializeCoords(coords,m_formation_energy_coord);
    if(LDEBUG){cerr << soliloquy << " m_coords(post)=" << m_coords << endl;}
    if(m_has_stoich_coords){setStoichCoords();}
  }

  void ChullPoint::cleanPointForHullCalc() {h_coords.clear();}
  void ChullPoint::cleanPointForHullTransfer() {
    m_i_alloy=AUROSTD_MAX_UINT;
    m_i_coord_group=AUROSTD_MAX_UINT;
    m_is_on_hull=false;
    m_is_g_state=false;
    m_is_equivalent_g_state=false;
    m_is_sym_equivalent_g_state=false;
    m_dist_2_hull=AUROSTD_MAX_DOUBLE;
    //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]m_decomp_coefs.clear();
    m_stability_criterion=AUROSTD_MAX_DOUBLE;
    m_n_plus_1_enthalpy_gain=AUROSTD_MAX_DOUBLE;
    cleanPointForHullCalc();
  }
} // namespace chull

namespace chull {
  //--------------------------------------------------------------------------------
  // constructor
  //--------------------------------------------------------------------------------
  FacetPoint::FacetPoint() {free();}
  FacetPoint::FacetPoint(const ChullPointLight& point,uint index){initialize(point,index);}  //need BOTH point and index, otherwise, just use point/index independently
  FacetPoint::FacetPoint(const FacetPoint& b) {copy(b);}  // copy PUBLIC
  FacetPoint::~FacetPoint() {free();}

  const FacetPoint& FacetPoint::operator=(const FacetPoint& other) {
    if(this!=&other) {copy(other);}
    return *this;
  }

  //simple sort, so ONLY sort facets from the same hull
  bool FacetPoint::operator<(const FacetPoint& other) const {return ch_index<other.ch_index;}
  void FacetPoint::clear() {FacetPoint a;copy(a);} //clear PUBLIC
  void FacetPoint::free() {
    m_initialized=false;
    ch_index=AUROSTD_MAX_UINT;
    ch_point.clear();
  }

  void FacetPoint::copy(const FacetPoint& b) { //copy PRIVATE
    m_initialized=b.m_initialized;
    ch_index=b.ch_index;
    ch_point=b.ch_point;
  }

  void FacetPoint::initialize(const ChullPointLight& point,uint index) {
    ch_point=point;
    ch_index=index;
    m_initialized=true;
  }
} // namespace chull

//nice sorters for points we know sit on a thermo hull (stoich coords + energy dimension)
namespace chull {
  bool sortThermoPoints::operator() (const FacetPoint& fpi,const FacetPoint& fpj) const{
    string soliloquy=XPID+"chull::sortThermoPoints::operator():";
    const ChullPointLight& ci=fpi.ch_point;
    const ChullPointLight& cj=fpj.ch_point;
    return (*this).operator()(ci,cj);
  }

  bool sortThermoPoints::operator() (const ChullPointLight& ci,const ChullPointLight& cj) const{  //upcasting is allowed, works for ChullPointLight and ChullPoint
    string soliloquy=XPID+"chull::sortThermoPoints::operator():";
    if(!(ci.m_initialized && cj.m_initialized)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Points not initialized");}
    //do not first sort binaries from ternaries, screws up facet sorting
    //keep sorting based on concentration of elements in relative order
    //if(ci.m_has_stoich_coords&&cj.m_has_stoich_coords){
    //  if(ci.m_i_nary!=cj.m_i_nary){return ci.m_i_nary<cj.m_i_nary;} //binaries before ternaries
    //}
    if(ci.m_coords.rows!=cj.m_coords.rows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch among points");}
    else {
      for(int i=ci.m_coords.lrows;i<=ci.m_coords.urows-1;i++){
        if(ci.m_coords[i]!=cj.m_coords[i]){
          return m_sort_stoich_ascending ? (ci.m_coords[i]<cj.m_coords[i]) : (ci.m_coords[i]>cj.m_coords[i]);
        }
      }
      if(ci.getLastCoord()!=cj.getLastCoord()){
        return m_sort_energy_ascending ? (ci.getLastCoord()<cj.getLastCoord()) : (ci.getLastCoord()>cj.getLastCoord());
      }
      return false; //true; //breaks if true
    }
  }
} //namespace chull

namespace chull {
  //--------------------------------------------------------------------------------
  // class ChullFacet
  //--------------------------------------------------------------------------------
  //--------------------------------------------------------------------------------
  // constructor
  //--------------------------------------------------------------------------------
  ChullFacet::ChullFacet(ostream& oss) : xStream(oss),m_initialized(false) {free();}
  ChullFacet::ChullFacet(ofstream& FileMESSAGE,ostream& oss) : xStream(FileMESSAGE,oss),m_initialized(false) {free();}
  ChullFacet::ChullFacet(const ChullFacet& b) : xStream(*b.getOFStream(),*b.getOSS()) {copy(b);} // copy PUBLIC
  ChullFacet::~ChullFacet() {xStream::free();free();}

  const ChullFacet& ChullFacet::operator=(const ChullFacet& other) {
    if(this!=&other) {copy(other);}
    return *this;
  }

  bool ChullFacet::operator<(const ChullFacet& other) const {
    string soliloquy=XPID+"ChullFacet::operator<():";
    if(m_vertices.size()!=other.m_vertices.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between facet points");}

    //simply sort by m_point (indices)
    for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){
      if(!(m_vertices[i].m_initialized && other.m_vertices[i].m_initialized)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized facetpoint");}
      if(m_vertices[i].ch_index!=other.m_vertices[i].ch_index){return m_vertices[i].ch_index<other.m_vertices[i].ch_index;}
    }
    return false;
  }

  void ChullFacet::clear() {ChullFacet a;copy(a);}  //clear PRIVATE
  void ChullFacet::free() {
    m_initialized=false;
    m_vertices.clear();
    m_dim=AUROSTD_MAX_UINT;
    m_has_stoich_coords=false;
    m_formation_energy_coord=false;
    m_content=AUROSTD_MAX_DOUBLE;
    m_directive_vectors.clear();
    m_normal.clear();
    m_offset=AUROSTD_MAX_DOUBLE;
    m_facet_centroid.clear();
    m_hull_reference.clear();
    m_hypercollinear=false;
    m_is_vertical=false;
    m_is_artificial=false;
    m_in_lower_hemisphere=false;
    m_ridges.clear();
    //see xStream::free()
    //p_oss=NULL;
    //p_FileMESSAGE=NULL;
    //f_new_ofstream=false;
    cleanFacet();
  }

  void ChullFacet::copy(const ChullFacet& b) {  //copy PRIVATE
    xStream::copy(b);
    m_initialized=b.m_initialized;
    m_vertices.clear(); for(uint i=0,fl_size_i=b.m_vertices.size();i<fl_size_i;i++){m_vertices.push_back(b.m_vertices[i]);}
    m_dim=b.m_dim;
    m_has_stoich_coords=b.m_has_stoich_coords;
    m_formation_energy_coord=b.m_formation_energy_coord;
    m_content=b.m_content;
    m_directive_vectors.clear(); for(uint i=0,fl_size_i=b.m_directive_vectors.size();i<fl_size_i;i++){m_directive_vectors.push_back(b.m_directive_vectors[i]);}
    m_normal=b.m_normal;
    m_offset=b.m_offset;
    m_facet_centroid=b.m_facet_centroid;
    m_hull_reference=b.m_hull_reference;
    m_hypercollinear=b.m_hypercollinear;
    m_is_vertical=b.m_is_vertical;
    m_is_artificial=b.m_is_artificial;
    m_in_lower_hemisphere=b.m_in_lower_hemisphere;
    f_visited=b.f_visited;
    f_outside_set.clear(); for(uint i=0,fl_size_i=b.f_outside_set.size();i<fl_size_i;i++){f_outside_set.push_back(b.f_outside_set[i]);}
    f_furthest_point=b.f_furthest_point;
    m_ridges.clear(); for(uint i=0,fl_size_i=b.m_ridges.size();i<fl_size_i;i++){m_ridges.push_back(b.m_ridges[i]);}
    f_neighbors.clear(); for(uint i=0,fl_size_i=b.f_neighbors.size();i<fl_size_i;i++){f_neighbors.push_back(b.f_neighbors[i]);}
  }

  bool ChullFacet::shareRidge(const ChullFacet& other) const{
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::shareRidge():";
    bool match;
    for(uint i=0,fl_size_i=m_ridges.size();i<fl_size_i;i++){
      const vector<uint>& ridge_indices1=m_ridges[i].getCHIndices();
      for(uint j=0,fl_size_j=other.m_ridges.size();j<fl_size_j;j++){
        const vector<uint>& ridge_indices2=other.m_ridges[j].getCHIndices();
        if(LDEBUG) {
          cerr << soliloquy << " comparing ";
          for(uint ri=0,fl_size_ri=ridge_indices1.size();ri<fl_size_ri;ri++){cerr << ridge_indices1[ri] << " ";}
          cerr << " vs. ";
          for(uint rj=0,fl_size_rj=ridge_indices1.size();rj<fl_size_rj;rj++){cerr << ridge_indices2[rj] << " ";}
        }
        match=(ridge_indices1==ridge_indices2);
        if(LDEBUG) {cerr << (match?"MATCH":"NO") << endl;}
        if(match){return true;}
      }
    }
    return false;
  }

  bool ChullFacet::isPointOnFacet(const FacetPoint& fp) const {
    string soliloquy=XPID+"ChullFacet::isPointOnFacet():";
    if(!fp.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized facetpoint");}
    return isPointOnFacet(fp.ch_index);
  }

  bool ChullFacet::isPointOnFacet(uint i_point) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::isPointOnFacet():";
    if(m_vertices.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Facet has no vertices");}
    //if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized facet");}
    if(LDEBUG) {cerr << soliloquy << " checking if point[" << i_point << "] is on this facet" << endl;}
    for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){
      if(LDEBUG) {cerr << soliloquy << " m_vertices[i].ch_index==" << m_vertices[i].ch_index << " ?= i_point==" << i_point << endl;}
      if(m_vertices[i].ch_index==i_point){return true;}
    }
    if(LDEBUG) {cerr << soliloquy << " point[" << i_point << "] is not on this facet" << endl;}
    return false;
  }

  bool ChullFacet::isPointOutside(const FacetPoint& f_point) const {
    string soliloquy=XPID+"ChullFacet::isPointOutside():";
    if(!f_point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized facetpoint");}
    if(isPointOnFacet(f_point)){return false;}
    return isPointOutside(f_point.ch_point);
  }

  bool ChullFacet::isPointOutside(const ChullPointLight& point) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::isPointOutside():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Facet not initialized");}
    double dist_point=getSignedPointPlaneDistance(point);
    bool is_outside=false;
    //special case no longer needed, but we keep here just in case
    //if(m_is_vertical){
    //  if(LDEBUG) {cerr << soliloquy << " performing special VERTICAL facet check for outside-ness" << endl;}
    //  xvector<double> ref=m_hull_reference;
    //  for(int i=ref.lrows;i<=ref.urows-1;i++){ref[i]=1.0/m_dim;}
    //  if(LDEBUG) {cerr << soliloquy << " ref=" << ref << endl;}
    //  double dist_ref=getSignedPointPlaneDistance(point);
    //  is_outside=(std::signbit(dist_point)!=std::signbit(dist_ref) && nonZeroWithinTol(dist_point,true));
    //  if(LDEBUG) {cerr << soliloquy << " sign of distance indicates point is " << (is_outside?"OUTSIDE":"INSIDE") << " hull" << endl;}
    //  return is_outside;
    //}
    //if(LDEBUG) {cerr << soliloquy << " performing normal check for outside-ness (not vertical facet)" << endl;}
    if(LDEBUG) {
      cerr << soliloquy << " looking at facet with vertices: ";
      for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){
        cerr << m_vertices[i].ch_point.m_coords << " | ";
      }
      cerr << "m_normal=" << m_normal << endl;
      cerr << soliloquy << " checking if point[h_coords=" << point.h_coords << "] is on this facet" << endl;
      cerr << soliloquy << " dist=" << dist_point << endl;
    }     
    //point is on facet
    if(zeroWithinTol(dist_point)){
      if(LDEBUG) {cerr << soliloquy << " point appears to be right on top of facet" << endl;}
      return false;
    }
    is_outside=(std::signbit(dist_point));
    if(LDEBUG) {cerr << soliloquy << " sign of distance indicates point is " << (is_outside?"OUTSIDE":"INSIDE") << " hull" << endl;}
    return is_outside;                //shortcut with inward-aligned normal
  }

  //sign depends on normal, if normal vector and point are in the same half-space, point-plane distance is positive, negative otherwise
  double ChullFacet::getSignedPointPlaneDistance(const ChullPointLight& point) const {return getSignedPointPlaneDistance(point.h_coords);}
  double ChullFacet::getSignedPointPlaneDistance(const xvector<double>& point) const {
    string soliloquy=XPID+"ChullFacet::getSignedPointPlaneDistance():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Facet not initialized");}
    if(point.rows!=m_vertices[0].ch_point.h_coords.rows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between point and facet");}
    xvector<double> diff=point-m_vertices[0].ch_point.h_coords;
    return scalar_product(m_normal,diff);
  }

  double ChullFacet::getSignedVerticalDistanceToZero(const ChullPointLight& point) const {
    //get energy of facet at stoichiometry of input (point)
    string soliloquy=XPID+"ChullFacet::getSignedVerticalDistanceToZero():";
    return getSignedVerticalDistanceToZero(point.h_coords);
  }

  double ChullFacet::getSignedVerticalDistanceToZero(const xvector<double>& point) const {
    //get energy of facet at stoichiometry of input (point)
    //distance from 0 to point on facet (vertical projection)
    //negative for projections BELOW 0, positive for projections ABOVE 0
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::getSignedVerticalDistanceToZero():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized facet");}
    if(m_normal.rows!=point.rows){
      if(LDEBUG) {
        cerr << soliloquy << " normal=" << m_normal << endl;
        cerr << soliloquy << " point=" << point << endl;
      }
      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between facet["+aurostd::utype2string(m_normal.rows)+"] and point["+aurostd::utype2string(point.rows)+"]");
    }
    double dist=-m_offset;
    for(int i=point.lrows;i<=point.urows-1;i++){dist-=m_normal[i]*point[i];} //note that we don't go to rows (because we assume it is zero)
    dist/=m_normal[m_normal.urows];
    if(LDEBUG) {
      cerr << soliloquy << " point=" << point << " projected onto facet with normal=" << m_normal << " and offset=" << m_offset << endl;
      cerr << soliloquy << " dist=" << dist << endl;
    }
    return dist;
  }

  double ChullFacet::getSignedVerticalDistance(const ChullPointLight& point) const {
    string soliloquy=XPID+"ChullFacet::getSignedVerticalDistance():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized facet");}
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    return getSignedVerticalDistance(point.h_coords);
  }

  double ChullFacet::getSignedVerticalDistance(const xvector<double>& point) const {
    //NB: we approximate the facet to be a hyperplane
    //also, this is the vertical distance, not the shortest (vertical is chemically meaningful)
    //to find the true distance between point and facet, must use quadratic programming
    //https://www.mathworks.com/matlabcentral/answers/107595-how-can-i-find-the-minimum-distance-from-convex-boundary
    //https://stackoverflow.com/questions/18230259/computing-distance-from-a-point-to-a-triangulation-in-3d-with-matlab
    //this is H_hull - H_f, which is negative for points on top of the hull (lower hull)
    string soliloquy=XPID+"ChullFacet::getSignedVerticalDistance():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized facet");}
    double dist=getSignedVerticalDistanceToZero(point);
    //[OBSOLETE CO20180828]if(zero_point_projection_only){return dist;}
    //sign of distance:
    //independent of lower/upper hull:  above hull is negative, below hull is positive
    dist-=point[point.urows];
    return dist;
  }

  vector<uint> ChullFacet::getCHIndices() const {
    string soliloquy=XPID+"ChullFacet::getCHIndices():";
    if(!m_vertices.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No vertices found");}
    vector<uint> vi;
    for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){vi.push_back(m_vertices[i].ch_index);}
    return vi;
  }

  //[CO20200508 - OBSOLETE]void ChullFacet::create(ostream& oss) { //this it NOT an initialization, as we do this piece by piece
  //[CO20200508 - OBSOLETE]  xStream::free();
  //[CO20200508 - OBSOLETE]  ofstream* _p_FileMESSAGE=new ofstream();f_new_ofstream=true;
  //[CO20200508 - OBSOLETE]  create(*_p_FileMESSAGE,oss);
  //[CO20200508 - OBSOLETE]  f_new_ofstream=true;  //override
  //[CO20200508 - OBSOLETE]}

  //[CO20200508 - OBSOLETE]void ChullFacet::create(ofstream& FileMESSAGE,ostream& oss) { //this it NOT an initialization, as we do this piece by piece
  //[CO20200508 - OBSOLETE]  xStream::free();
  //[CO20200508 - OBSOLETE]  setOFStream(FileMESSAGE); f_new_ofstream=false;
  //[CO20200508 - OBSOLETE]  setOSS(oss);
  //[CO20200508 - OBSOLETE]}

  //MOVED TO xStream
  //void ChullFacet::setOFStream(ofstream& FileMESSAGE){p_FileMESSAGE=&FileMESSAGE;}
  //void ChullFacet::setOSS(ostream& oss) {p_oss=&oss;}

  void ChullFacet::addVertex(const ChullPointLight& point,uint index) {FacetPoint fp(point,index);return addVertex(fp);} //no need for full copy
  void ChullFacet::addVertex(const FacetPoint& fp){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    stringstream message;
    string soliloquy=XPID+"ChullFacet::addVertex():";
    if(!fp.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized facetpoint");}
    const ChullPointLight& point=fp.ch_point;
    if(m_vertices.size()==0){
      m_has_stoich_coords=point.m_has_stoich_coords;
      m_formation_energy_coord=point.m_formation_energy_coord;
      if(LDEBUG) {
        cerr << soliloquy << " setting has_stoich_coords=" << m_has_stoich_coords << endl;
        cerr << soliloquy << " setting formation_energy_coord=" << m_formation_energy_coord << endl;
      }
    }
    else {
      //if(m_has_stoich_coords && !point.m_has_stoich_coords)
      if(m_has_stoich_coords != point.m_has_stoich_coords) //spit warning for either mismatch
      { //CO20200106 - patching for auto-indenting
        message << "Mismatch among coord types (stoich vs. non-stoich coords), assuming non-stoich coords";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        m_has_stoich_coords=false; //(m_has_stoich_coords && point.m_has_stoich_coords);
        if(LDEBUG) {
          cerr << soliloquy << " facet.m_has_stoich_coords=" << m_has_stoich_coords << endl;
          for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){
            cerr << soliloquy << " m_vertices[" << i << "].ch_point.m_has_stoich_coords=" << m_vertices[i].ch_point.m_has_stoich_coords;
            cerr << ", h_coords=" << m_vertices[i].ch_point.h_coords << endl;
          }
          cerr << soliloquy << " point.m_has_stoich_coords=" << point.m_has_stoich_coords << endl;
        }
      }
      //if(m_formation_energy_coord && !point.m_formation_energy_coord)
      if(m_formation_energy_coord != point.m_formation_energy_coord) //spit warning for either mismatch
      { //CO20200106 - patching for auto-indenting
        message << "Mismatch among coord types (formation_energy vs. non-formation_energy), assuming non-formation_energy coords";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        m_formation_energy_coord=false; //(m_formation_energy_coord && point.m_formation_energy_coord);
        if(LDEBUG) {
          cerr << soliloquy << " facet.m_formation_energy_coord=" << m_formation_energy_coord << endl;
          for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){
            cerr << soliloquy << " m_vertices[" << i << "].ch_point.m_formation_energy_coord=" << m_vertices[i].ch_point.m_formation_energy_coord;
            cerr << ", h_coords=" << m_vertices[i].ch_point.h_coords << endl;
          }
          cerr << soliloquy << " point.m_formation_energy_coord=" << point.m_formation_energy_coord << endl;
        }
      }
    }
    m_vertices.push_back(fp);
  }

  void ChullFacet::initialize(const xvector<double>& ref,uint h_dim,bool check_validity){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::initialize():";
    if(LDEBUG) {
      cerr << soliloquy << " initialize facet with points: " << endl;
      for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){cerr << "    " << m_vertices[i].ch_point.h_coords << endl;}
    }
    m_dim=h_dim;
    m_hull_reference=ref;
    setDirectiveVectors(check_validity);
    setNormal(check_validity);
    setOffset();  //FIX after normal alignment
    setCentroid();
    alignNormalInward(); //hull centroid
    setVertical();
    setArtificial();
    setHemisphere();
    setRidges();
    m_initialized=true;
  }

  bool ChullFacet::hasValidPoints(string& error){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::hasValidPoints():";
    error.clear();
    if(!m_vertices.size()){error="Facet has no defining points";return false;}
    for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){if(!m_vertices[i].m_initialized){error="Uninitialized facetpoint";}}
    if((uint)m_vertices[0].ch_point.h_coords.rows!=m_vertices.size()){
      if(LDEBUG) {
        cerr << soliloquy << " m_vertices[0].ch_point.h_coords.rows=" << m_vertices[0].ch_point.h_coords.rows;
        cerr << " vs. m_vertices.size()=" << m_vertices.size() << endl;
      }
      error="Dimension mismatch among points and coordinates";return false;
    }
    for(uint i=1,fl_size_i=m_vertices.size();i<fl_size_i;i++){
      if(LDEBUG) {
        cerr << soliloquy << " " << m_vertices[i].ch_index << "  h_coords=" << m_vertices[i].ch_point.h_coords << endl;
        cerr << soliloquy << " m_vertices[i].ch_point.h_coords.rows=" << m_vertices[i].ch_point.h_coords.rows << " vs. m_vertices[0].ch_point.h_coords.rows=" << m_vertices[0].ch_point.h_coords.rows << endl;
      }
      if(m_vertices[i].ch_point.h_coords.rows!=m_vertices[0].ch_point.h_coords.rows){error="Dimension mismatch among facet points";return false;}
    }
    for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++) {
      for(uint j=i+1,fl_size_j=m_vertices.size();j<fl_size_j;j++) {
        if(m_vertices[i].ch_index==m_vertices[j].ch_index){error="Facet points are degenerate";return false;}
      }
    }
    if(m_vertices.size()!=(uint)m_vertices[0].ch_point.h_coords.rows){error="Facet has wrong number of defining points given dimension";return false;}
    return true;
  }

  void ChullFacet::setContent(){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::setContent():";
    m_content=AUROSTD_MAX_DOUBLE;
    m_hypercollinear=true;
    string error; if(!hasValidPoints(error)){return;}
    m_content=0.0;  //if we don't set later, it's because it's really zero
    xmatrix<double> B(m_vertices.size(),m_vertices.size(),1,1); //for determinant
    for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){
      for(uint k=0,fl_size_k=m_vertices.size();k<fl_size_k;k++){
        if(LDEBUG) {
          cerr << soliloquy << "B(" << i << "+1," << k << "+1)=";
          cerr << "aurostd::modulussquare([" << m_vertices[i].ch_point.h_coords << "] - [" << m_vertices[k].ch_point.h_coords << "])" << endl;
        }
        B(i+1,k+1)=aurostd::modulussquare(m_vertices[i].ch_point.h_coords-m_vertices[k].ch_point.h_coords);
      }
    }
    if(LDEBUG) {cerr << soliloquy << " B=" << endl; cerr << B << endl;}
    double CMdetB=aurostd::CMdet(B);
    if(LDEBUG) {cerr << soliloquy << " m_has_stoich_coords=" << std::boolalpha << m_has_stoich_coords << ", m_formation_energy_coord=" << std::boolalpha << m_formation_energy_coord << endl;}
    //tolerance is CRITICAL, because we could accidentally skip a facet and get the wrong decomposition coefficients (negative sign)
    //tolerance should scale with dimension, i.e., if we are measuring length of line, use TOL, area of triangle, use TOL^2, volume of tetrahedron, use TOL^3
    //it is not clear to me what TOL should be, but I believe it is related to ZERO_COEF_TOL
    //heuristically, ZERO_COEF_TOL works well for lengths and areas (chull paper)
    //since ZERO_COEF_TOL^2 is ZERO_TOL, make this a simple if/else
    //double tol=(m_has_stoich_coords&&m_formation_energy_coord ? ZERO_COEF_TOL : ZERO_TOL);  //1e-4 if stoich coords
    double tol=ZERO_TOL;
    if((m_dim<4) && m_has_stoich_coords && m_formation_energy_coord){tol=ZERO_COEF_TOL;}
    if(LDEBUG) {cerr << soliloquy << " CMdet(B)=" << CMdetB << endl;}
    //the coef will ONLY decrease the content (fraction)
    //if we don't check CMdetB before multiplying the coef, we might get -nan
    //therefore, use tol for both CHdetB and content
    if(zeroWithinTol(CMdetB,tol)){return;} //error="CMdet(B) is zero, shows hyper-collinearity";
    double j=m_vertices.size()-1; //two vertices == line segment == 1-simplex
    double coef=pow(-1.0,j+1.0)/(pow(2.0,j)*pow(aurostd::factorial(j),2));
    if(LDEBUG) {
      cerr << soliloquy << " j=" << j << endl;
      cerr << soliloquy << " coef=" << coef << endl;
    }
    m_content=sqrt(coef*CMdetB);
    if(LDEBUG) {cerr << soliloquy << " content=" << m_content << endl;}
    if(zeroWithinTol(m_content,tol)){return;} //error="simplex content is zero, shows hyper-collinearity";
    m_hypercollinear=false;
  }

  void ChullFacet::setDirectiveVectors(bool check_validity){  //perhaps we already checked...
    string soliloquy=XPID+"ChullFacet::setDirectiveVectors():";
    m_directive_vectors.clear();
    string error;
    if(check_validity && !hasValidPoints(error)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,error);}

    std::sort(m_vertices.begin(),m_vertices.end());
    for(uint i=1,fl_size_i=m_vertices.size();i<fl_size_i;i++){
      m_directive_vectors.push_back( m_vertices[i].ch_point.h_coords - m_vertices[0].ch_point.h_coords );
    }
  }

  bool ChullFacet::pointsMatchDirectiveVectors(string& error){
    error.clear();
    //now we can define 
    if(m_directive_vectors.size()!=m_vertices.size()-1){error="Dimension mismatch among directive vectors and points";return false;}
    if((uint)m_directive_vectors[0].rows!=m_vertices.size()){error="Dimension mismatch among directive vectors coordinates and points";return false;}
    return true;
  }

  bool ChullFacet::hasValidDirectiveVectors(string& error){
    error.clear();
    if(!m_directive_vectors.size()){error="No directive vectors found";return false;}
    for(uint i=1,fl_size_i=m_directive_vectors.size();i<fl_size_i;i++){
      if(m_directive_vectors[i].rows!=m_directive_vectors[0].rows){error="Dimension mismatch among directive vectors coordinates";return false;}
    }
    for(uint i=0,fl_size_i=m_directive_vectors.size();i<fl_size_i;i++){if(zeroWithinTol(modulus(m_directive_vectors[i]))){error="Ill-defined directive vectors";return false;}}
    return true;
  }

  bool ChullFacet::hasCollinearVectors(bool check_validity){  //perhaps we already checked...
    string soliloquy=XPID+"ChullFacet::hasCollinearVectors():";
    string error;
    if(check_validity && !pointsMatchDirectiveVectors(error)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,error);}
    if(check_validity && !hasValidDirectiveVectors(error)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,error);}
    for(uint i=0,fl_size_i=m_directive_vectors.size();i<(fl_size_i-1);i++) {
      for(uint j=i+1,fl_size_j=m_directive_vectors.size();j<fl_size_j;j++) {
        if(aurostd::isCollinear(m_directive_vectors[i],m_directive_vectors[j],ZERO_TOL)){return true;}
      }
    }
    return false;
  }

  bool ChullFacet::isValid(string& error) {
    //technically, facets that show hyper-collinearity, i.e., three points on a line, four points on a plane, etc., are not really facets
    //we detect these specifically by checking collinearity in directive_vectors (2D) or, more generally in N dimensions, by checking
    //content (volume) of simplex
    //but by removing these facets, we screw up the neighboring determination, and hence create gaps in the hull
    //so keep them
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::isValid():";
    error.clear();
    if(!hasValidPoints(error)){return false;}
    setContent(); //we need to preserve neighbors, so do not kill these pseudo-facets
    setDirectiveVectors(false);
    if(!pointsMatchDirectiveVectors(error)){return false;}
    if(!hasValidDirectiveVectors(error)){return false;} //we need to preserve neighbors, so do not kill these pseudo-facets
    if(0&&hasCollinearVectors(false)){  //we need to preserve neighbors, so do not kill these pseudo-facets
      if(LDEBUG) {cerr << soliloquy << " shows collinarity" << endl;}
      error="Directive vectors are collinear";return false;
    }
    return true;
  }

  void ChullFacet::setNormal(bool check_validity){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::setNormal():";
    m_normal.clear();
    string error;
    if(check_validity && !isValid(error)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,error);}
    if(LDEBUG) {
      for(uint i=0,fl_size_i=m_directive_vectors.size();i<fl_size_i;i++){
        cerr << soliloquy << " directive_vector[" << i << "]=" << m_directive_vectors[i] << endl;
      }
    }
    if(!m_directive_vectors.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No directive vectors calculated");}
    m_normal=aurostd::getGeneralNormal(m_directive_vectors);
    if(zeroWithinTol(aurostd::modulus(m_normal))){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid normal calculated");}
    if(LDEBUG) {cerr << soliloquy << " normal=" << m_normal << endl;}
  }

  void ChullFacet::setOffset(){
    string soliloquy=XPID+"ChullFacet::setOffset():";
    if(!m_vertices.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Facet has not been defined");}
    const xvector<double>& plane_point=m_vertices[0].ch_point.h_coords;
    if(m_normal.rows!=plane_point.rows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between normal and point");}
    m_offset=-scalar_product(m_normal,plane_point);
  }

  void ChullFacet::setCentroid() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::setCentroid():";
    vector<xvector<double> > points;
    for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){points.push_back(m_vertices[i].ch_point.h_coords);}
    m_facet_centroid=aurostd::getCentroid(points);
    if(LDEBUG) {cerr << soliloquy << " centroid: " << m_facet_centroid << endl;}
  }

  //_AFLOW_CHULL_VERTICAL_PLANE_TOLERANCE_ = 1e-4 for H_f_atom, else 1e-9 for T_S
  void ChullFacet::setVertical(){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::setVertical():";
    if(LDEBUG) {cerr << soliloquy << " looking if vertical hull: normal=" << m_normal << endl;}
    double tol=(m_has_stoich_coords&&m_formation_energy_coord ? ZERO_COEF_TOL : ZERO_TOL);  //1e-4 if stoich coords
    m_is_vertical=zeroWithinTol(m_normal[m_normal.urows],tol); //simple
  }

  void ChullFacet::setArtificial(){  //in half hulls, this finds the facet of all artificial points
    string soliloquy=XPID+"ChullFacet::setArtificial():";
    for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){if(!m_vertices[i].ch_point.m_is_artificial){m_is_artificial=false;return;}}
    m_is_artificial=true;return;
  }

  void ChullFacet::alignNormalInward() { 
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::alignNormalInward():";
    //we want normal pointing inward
    double dist=scalar_product(m_normal,m_hull_reference)+m_offset;  //point-plane distance formula without normalization
    if(LDEBUG) {
      cerr << soliloquy << " m_normal=" << m_normal << endl;
      cerr << soliloquy << " h_reference=" << m_hull_reference << endl;
      cerr << soliloquy << " dist=" << dist << endl;
    }
    bool negate=std::signbit(dist);
    if(negate){
      if(LDEBUG) {cerr << soliloquy << " NEGATING" << endl;}
      m_normal=-m_normal; 
      m_offset=-m_offset; //flips sign of offset
    }
    if(LDEBUG) {cerr << soliloquy << " aligned normal=" << m_normal << endl;}
  }

  void ChullFacet::setHemisphere() {
    string soliloquy=XPID+"ChullFacet::alignNormalInward():";
    //vertical facets are NOT considered lower_hemisphere
    m_in_lower_hemisphere=(!m_is_vertical && !std::signbit(m_normal[m_normal.urows])); //not flat and upward pointed normal
  }

  void ChullFacet::setFurthestPoint(){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::setFurthestPoint():";
    f_furthest_point.clear();
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Facet not initialized");}
    if(!f_outside_set.size()){return;}
    if(LDEBUG) {cerr << soliloquy << " getting furthest point for facet with normal " << m_normal << " (is_artificial=" << m_is_artificial << ")" << endl;}
    double dist=AUROSTD_MAX_DOUBLE,max_dist=0;
    for(uint i=0,fl_size_i=f_outside_set.size();i<fl_size_i;i++){
      dist=abs(getSignedPointPlaneDistance(f_outside_set[i].ch_point.h_coords)); //we only care about magnitude here
      if(LDEBUG) {cerr << soliloquy << " point=" << f_outside_set[i].ch_point.h_coords << " is " << dist << " from facet" << endl;}
      if(dist>max_dist){
        max_dist=dist;
        f_furthest_point=f_outside_set[i];
      }
    }
    if(LDEBUG) {
      cerr << soliloquy << " furthest point from facet:" << endl;
      for(uint i=0,fl_size_i=m_vertices.size();i<fl_size_i;i++){cerr << "       point[" << m_vertices[i].ch_index << "]=" << m_vertices[i].ch_point.h_coords << endl;}
      cerr << "    is point[" << f_furthest_point.ch_index << "]=" << f_furthest_point.ch_point.h_coords << endl;
    }
  }

  void ChullFacet::setRidges(){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ChullFacet::setRidges():";
    m_ridges.clear();
    if(!m_vertices.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Facet has no vertices");}
    for(uint fl_size_i=m_vertices.size(),i=(fl_size_i-1);i<fl_size_i;i--){  //wrap around to HUGE number
      m_ridges.push_back(ChullFacet(*p_FileMESSAGE,*p_oss));  //CO20180305
      for(uint j=0,fl_size_j=m_vertices.size();j<fl_size_j;j++){
        if(i!=j){m_ridges.back().addVertex(m_vertices[j]);}
      }
      if(m_ridges.back().m_vertices.size()!=m_dim-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Ridge vertex count and facet dimension mismatch");}
      std::sort(m_ridges.back().m_vertices.begin(),m_ridges.back().m_vertices.end());
    }
    std::sort(m_ridges.begin(),m_ridges.end());

    if(LDEBUG) {
      for(uint i=0,fl_size_i=m_ridges.size();i<fl_size_i;i++){
        cerr << soliloquy << " ridges[" << i << "]: ";
        for(uint j=0,fl_size_j=m_ridges[i].m_vertices.size();j<fl_size_j;j++){
          cerr << m_ridges[i].m_vertices[j].ch_index << " " ;
        }
        cerr << endl;
      }
    }
  }

  void ChullFacet::cleanFacet() {
    f_visited=false;
    f_outside_set.clear();
    f_furthest_point.clear();
    f_neighbors.clear();
  }
} // namespace chull

namespace chull {
  //--------------------------------------------------------------------------------
  // constructor
  //--------------------------------------------------------------------------------
  CoordGroup::CoordGroup() {free();}
  CoordGroup::CoordGroup(const xvector<double>& coord,bool has_stoich_coords) {initialize(coord,has_stoich_coords);}
  CoordGroup::CoordGroup(const CoordGroup& b) {copy(b);}  // copy PUBLIC
  CoordGroup::~CoordGroup() {free();}

  const CoordGroup& CoordGroup::operator=(const CoordGroup& other) {
    if(this!=&other) {copy(other);}
    return *this;
  }

  bool CoordGroup::operator<(const CoordGroup& other) const {
    // safety, so it doesn't break, but it's outside scope of function
    string soliloquy=XPID+"CoordGroup::operator<():";
    if(m_coords.rows!=other.m_coords.rows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between stoichiometries");} //return (m_coords.rows<other.m_coords.rows);
    for(int i=m_coords.lrows;i<=m_coords.urows;i++) {
      if(m_coords(i)!=other.m_coords(i)) {return (m_coords(i)<other.m_coords(i));}
    }
    return false;
  }

  void CoordGroup::clear() {CoordGroup a;copy(a);} //clear PUBLIC
  void CoordGroup::free() {
    m_initialized=false;
    m_coords.clear();
    m_points.clear();
    m_has_stoich_coords=false;
    m_has_artificial_unary=false;
    m_is_on_hull=false;
    m_hull_member=AUROSTD_MAX_UINT;
    m_ref_state=AUROSTD_MAX_UINT;
    m_candidate_hull_points.clear();
    m_i_nary=AUROSTD_MAX_UINT;
    m_i_alloy=AUROSTD_MAX_UINT;
    m_nearest_facet=AUROSTD_MAX_UINT;
    m_nearest_distance=AUROSTD_MAX_DOUBLE;
    m_decomp_phases.clear();
    m_decomp_coefs.clear();
    m_equilibrium_phases.clear();
    m_calculated_equivalent_g_states=false;
    m_equivalent_g_states.clear();
    m_sym_equivalent_g_states.clear();
    m_stability_criterion=AUROSTD_MAX_DOUBLE;
    m_n_plus_1_enthalpy_gain=AUROSTD_MAX_DOUBLE;
    m_icsd_g_state=false;
    m_i_canonical_icsd=AUROSTD_MAX_UINT;
  }

  void CoordGroup::copy(const CoordGroup& b) {
    m_initialized=b.m_initialized;
    m_coords=b.m_coords;
    m_points.clear(); for(uint i=0,fl_size_i=b.m_points.size();i<fl_size_i;i++){m_points.push_back(b.m_points[i]);}
    m_has_stoich_coords=b.m_has_stoich_coords;
    m_has_artificial_unary=b.m_has_artificial_unary;
    m_is_on_hull=b.m_is_on_hull;
    m_hull_member=b.m_hull_member;
    m_ref_state=b.m_ref_state;
    m_candidate_hull_points.clear(); for(uint i=0,fl_size_i=b.m_candidate_hull_points.size();i<fl_size_i;i++){m_candidate_hull_points.push_back(b.m_candidate_hull_points[i]);}
    m_i_nary=b.m_i_nary;
    m_i_alloy=b.m_i_alloy;
    m_nearest_facet=b.m_nearest_facet;
    m_nearest_distance=b.m_nearest_distance;
    m_decomp_phases.clear(); for(uint i=0,fl_size_i=b.m_decomp_phases.size();i<fl_size_i;i++){m_decomp_phases.push_back(b.m_decomp_phases[i]);}
    m_decomp_coefs=b.m_decomp_coefs;
    for(uint i=0,fl_size_i=m_equilibrium_phases.size();i<fl_size_i;i++){m_equilibrium_phases.clear();} m_equilibrium_phases.clear(); for(uint i=0;i<b.m_equilibrium_phases.size();i++){m_equilibrium_phases.push_back(b.m_equilibrium_phases[i]);}
    m_calculated_equivalent_g_states=b.m_calculated_equivalent_g_states;
    m_equivalent_g_states.clear(); for(uint i=0,fl_size_i=b.m_equivalent_g_states.size();i<fl_size_i;i++){m_equivalent_g_states.push_back(b.m_equivalent_g_states[i]);}
    m_sym_equivalent_g_states.clear(); for(uint i=0,fl_size_i=b.m_sym_equivalent_g_states.size();i<fl_size_i;i++){m_sym_equivalent_g_states.push_back(b.m_sym_equivalent_g_states[i]);}
    m_stability_criterion=b.m_stability_criterion;
    m_n_plus_1_enthalpy_gain=b.m_n_plus_1_enthalpy_gain;
    m_icsd_g_state=b.m_icsd_g_state;
    m_i_canonical_icsd=b.m_i_canonical_icsd;
  }

  void CoordGroup::initialize(const xvector<double>& coord,bool has_stoich_coords) {
    free();
    m_coords=coord;
    m_has_stoich_coords=has_stoich_coords;
    m_has_artificial_unary=false;
    m_initialized=true;
  }

  xvector<int> CoordGroup::getElementsPresent() const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"CoordGroup::getElementsPresent():";
    if(LDEBUG){cerr << soliloquy << " BEGIN" << endl;}
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
    if(LDEBUG){cerr << soliloquy << " m_coords=" << m_coords << endl;}
    for(int i=m_coords.lrows;i<=m_coords.urows;i++){
      if(std::signbit(m_coords[i]) || m_coords[i]>1.0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coord("+aurostd::utype2string(i)+") is outside of [0,1] range of a generalized stoichiometry coordinate");}
    }
    double hid_dim=1.0-sum(m_coords);
    if(LDEBUG) {cerr << soliloquy << " hid_dim=" << hid_dim << endl;}
    if(std::signbit(hid_dim) || hid_dim>1.0) {
      if(zeroWithinTol(hid_dim)){hid_dim=0.0;}  //only zero out for the last coord, as it's derived from the subtraction of the others
      else{throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coord("+aurostd::utype2string(m_coords.rows)+") is outside of [0,1] range of a generalized stoichiometry coordinate");}
    }

    xvector<int> elements_present(m_coords.lrows,m_coords.urows+1);
    for(int i=m_coords.lrows;i<=m_coords.urows;i++){if(nonZeroWithinTol(m_coords[i])){elements_present[i]=1;}}
    if(nonZeroWithinTol(hid_dim)){elements_present[elements_present.urows]=1;}

    if(LDEBUG) {cerr << soliloquy << " elements_present=" << elements_present << endl;}
    return elements_present;
  }

  uint CoordGroup::getDim() const {
    if(!m_initialized){
      string soliloquy=XPID+"CoordGroup::getDim():";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");
    }
    return sum(getElementsPresent());
  }

} // namespace chull

namespace chull {
  //--------------------------------------------------------------------------------
  // constructor
  //--------------------------------------------------------------------------------
  Alloy::Alloy() {free();}
  Alloy::Alloy(const xvector<int>& elements_present) {initialize(elements_present);}
  Alloy::Alloy(const Alloy& b) {copy(b);}
  Alloy::~Alloy() {free();}

  const Alloy& Alloy::operator=(const Alloy& other) {
    if(this!=&other) {copy(other);}
    return *this;
  }

  bool Alloy::operator<(const Alloy& other) const {
    // safety, so it doesn't break, but it's outside scope of function
    string soliloquy=XPID+"Alloy::operator<():";
    if(m_elements_present.rows!=other.m_elements_present.rows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between alloys");} //return (m_elements_present.rows<other.m_elements_present.rows);
    for(int i=m_elements_present.lrows;i<=m_elements_present.urows;i++) {
      if(m_elements_present[i]!=other.m_elements_present[i]) {return (m_elements_present[i]<other.m_elements_present[i]);}
    }
    return false;
  }

  void Alloy::clear() {Alloy a;copy(a);} //clear PUBLIC
  void Alloy::free() { 
    m_initialized=false;
    m_elements_present.clear();
    m_dim=AUROSTD_MAX_UINT;
    m_coord_groups.clear();
    m_facets.clear();
  }

  void Alloy::copy(const Alloy& b) {
    m_initialized=b.m_initialized;
    m_elements_present=b.m_elements_present;
    m_dim=b.m_dim;
    m_coord_groups.clear(); for(uint i=0,fl_size_i=b.m_coord_groups.size();i<fl_size_i;i++){m_coord_groups.push_back(b.m_coord_groups[i]);}
    m_facets.clear(); for(uint i=0,fl_size_i=b.m_facets.size();i<fl_size_i;i++){m_facets.push_back(b.m_facets[i]);}
  }

  void Alloy::initialize(const xvector<int>& elements_present){
    free();
    m_elements_present=elements_present;
    m_dim=sum(elements_present);
    m_initialized=true;
  }

  bool Alloy::belongs2Hull(const xvector<int>& elements_present_hull) const {return subspaceBelongs(elements_present_hull,m_elements_present);}
} // namespace chull

namespace chull {
  //--------------------------------------------------------------------------------
  // constructor
  //--------------------------------------------------------------------------------
  Nary::Nary() {free();}
  Nary::Nary(uint dim) {initialize(dim);}
  Nary::Nary(const Nary& b) {copy(b);}
  Nary::~Nary() {free();}

  const Nary& Nary::operator=(const Nary& other) {
    if(this!=&other) {copy(other);}
    return *this;
  }

  bool Nary::operator<(const Nary& other) const {return (nary<other.nary);}

  void Nary::clear() {Nary a;copy(a);}
  void Nary::free() {
    m_initialized=false;
    nary=AUROSTD_MAX_UINT;
    m_alloys.clear();
  }

  void Nary::copy(const Nary& b) {
    m_initialized=b.m_initialized;
    nary=b.nary;
    m_alloys.clear(); for(uint i=0,fl_size_i=b.m_alloys.size();i<fl_size_i;i++){m_alloys.push_back(b.m_alloys[i]);}
  }

  void Nary::initialize(uint dim) {
    free();
    nary=dim;
    m_initialized=true;
  }
} // namespace chull

namespace chull {
  //--------------------------------------------------------------------------------
  // class ConvexHull
  //--------------------------------------------------------------------------------
  //--------------------------------------------------------------------------------
  // constructor
  //--------------------------------------------------------------------------------
  ConvexHull::ConvexHull(ostream& oss) : xStream(oss),m_initialized(false) {initialize();}
  ConvexHull::ConvexHull(const string& alloy,ostream& oss) : xStream(oss),m_initialized(false) {initialize(alloy);}
  ConvexHull::ConvexHull(const vector<string>& velements,ostream& oss) : xStream(oss),m_initialized(false) {initialize(velements);}
  ConvexHull::ConvexHull(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ostream& oss) : xStream(oss),m_initialized(false) {initialize(velements,entries);}
  ConvexHull::ConvexHull(const vector<xvector<double> >& vcoords,ostream& oss,bool has_stoich_coords,bool formation_energy_hull,bool add_artificial_unaries) : xStream(oss),m_initialized(false) {initialize(vcoords,has_stoich_coords,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const vector<ChullPoint>& vpoints,ostream& oss,bool formation_energy_hull,bool add_artificial_unaries) : xStream(oss),m_initialized(false) {initialize(vpoints,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const vector<ChullPoint>& vpoints,const vector<string>& velements,ostream& oss,bool formation_energy_hull,bool add_artificial_unaries) : xStream(oss),m_initialized(false) {initialize(vpoints,velements,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(ofstream& FileMESSAGE,ostream& oss) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize();}
  ConvexHull::ConvexHull(const string& alloy,ofstream& FileMESSAGE,ostream& oss) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(alloy);}
  ConvexHull::ConvexHull(const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(velements);}
  ConvexHull::ConvexHull(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ofstream& FileMESSAGE,ostream& oss) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(velements,entries);}
  ConvexHull::ConvexHull(const vector<xvector<double> >& vcoords,ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool formation_energy_hull,bool add_artificial_unaries) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(vcoords,has_stoich_coords,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const vector<ChullPoint>& vpoints,ofstream& FileMESSAGE,ostream& oss,bool formation_energy_hull,bool add_artificial_unaries) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(vpoints,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const vector<ChullPoint>& vpoints,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss,bool formation_energy_hull,bool add_artificial_unaries) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(vpoints,velements,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,ostream& oss) : xStream(oss),m_initialized(false) {initialize(vpflow);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const string& alloy,ostream& oss) : xStream(oss),m_initialized(false) {initialize(vpflow,alloy);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<string>& velements,ostream& oss) : xStream(oss),m_initialized(false) {initialize(vpflow,velements);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ostream& oss) : xStream(oss),m_initialized(false) {initialize(vpflow,velements,entries);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<xvector<double> >& vcoords,ostream& oss,bool has_stoich_coords,bool formation_energy_hull,bool add_artificial_unaries) : xStream(oss),m_initialized(false) {initialize(vpflow,vcoords,has_stoich_coords,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,ostream& oss,bool formation_energy_hull,bool add_artificial_unaries) : xStream(oss),m_initialized(false) {initialize(vpflow,vpoints,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,const vector<string>& velements,ostream& oss,bool formation_energy_hull,bool add_artificial_unaries) : xStream(oss),m_initialized(false) {initialize(vpflow,vpoints,velements,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,ofstream& FileMESSAGE,ostream& oss) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(vpflow);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const string& alloy,ofstream& FileMESSAGE,ostream& oss) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(vpflow,alloy);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(vpflow,velements);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ofstream& FileMESSAGE,ostream& oss) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(vpflow,velements,entries);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<xvector<double> >& vcoords,ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool formation_energy_hull,bool add_artificial_unaries) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(vpflow,vcoords,has_stoich_coords,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,ofstream& FileMESSAGE,ostream& oss,bool formation_energy_hull,bool add_artificial_unaries) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(vpflow,vpoints,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss,bool formation_energy_hull,bool add_artificial_unaries) : xStream(FileMESSAGE,oss),m_initialized(false) {initialize(vpflow,vpoints,velements,formation_energy_hull,add_artificial_unaries);}
  ConvexHull::ConvexHull(const ConvexHull& b) : xStream(*b.getOFStream(),*b.getOSS()) {copy(b);}

  ConvexHull::~ConvexHull() {
    xStream::free();
    free();
    m_allowed_dft_types.clear();
  }

  const ConvexHull& ConvexHull::operator=(const ConvexHull& other) {
    if(this!=&other) {copy(other);}
    return *this;
  }

  void ConvexHull::clear() {ConvexHull a;copy(a);}  //clear PRIVATE
  void ConvexHull::free() {
    m_initialized=false;
    m_velements.clear();
    m_icsd_entries.clear();
    m_points.clear();
    m_naries.clear();
    m_coord_groups.clear();
    m_dim=AUROSTD_MAX_UINT;
    m_half_hull=false;
    m_lower_hull=false;
    m_has_stoich_coords=false;
    m_add_artificial_unaries=false;
    m_thermo_hull=false;
    m_formation_energy_hull=false;
    m_facets.clear();
    m_i_facets.clear();
    m_sort_energy_ascending=true;
    m_cflags.clear();
    m_aflags.clear();
    //see xStream::free()
    //p_oss=NULL;
    //p_FileMESSAGE=NULL;
    //f_new_ofstream=false;
    m_allow_all_formation_energies=DEFAULT_CHULL_ALLOW_ALL_FORMATION_ENERGIES;
    aurostd::string2tokens(DEFAULT_CHULL_ALLOWED_DFT_TYPES,m_allowed_dft_types,",");
    if(!m_allowed_dft_types.size()){m_allowed_dft_types.push_back("PAW_PBE");}
    cleanHull();
  }

  void ConvexHull::copy(const ConvexHull& b) {  //copy PRIVATE
    xStream::copy(b);
    m_initialized=b.m_initialized;
    m_velements.clear(); for(uint i=0,fl_size_i=b.m_velements.size();i<fl_size_i;i++){m_velements.push_back(b.m_velements[i]);}
    m_icsd_entries.clear(); for(uint i=0,fl_size_i=b.m_icsd_entries.size();i<fl_size_i;i++){m_icsd_entries.push_back(b.m_icsd_entries[i]);}
    m_points.clear(); for(uint i=0,fl_size_i=b.m_points.size();i<fl_size_i;i++){m_points.push_back(b.m_points[i]);}
    m_naries.clear(); for(uint i=0,fl_size_i=b.m_naries.size();i<fl_size_i;i++){m_naries.push_back(b.m_naries[i]);}
    m_coord_groups.clear(); for(uint i=0,fl_size_i=b.m_coord_groups.size();i<fl_size_i;i++){m_coord_groups.push_back(b.m_coord_groups[i]);}
    m_dim=b.m_dim;
    m_half_hull=b.m_half_hull;
    m_lower_hull=b.m_lower_hull;
    m_has_stoich_coords=b.m_has_stoich_coords;
    m_add_artificial_unaries=b.m_add_artificial_unaries;
    m_thermo_hull=b.m_thermo_hull;
    m_formation_energy_hull=b.m_formation_energy_hull;
    m_facets.clear(); for(uint i=0,fl_size_i=b.m_facets.size();i<fl_size_i;i++){m_facets.push_back(b.m_facets[i]);}
    m_i_facets.clear(); for(uint i=0,fl_size_i=b.m_i_facets.size();i<fl_size_i;i++){m_i_facets.push_back(b.m_i_facets[i]);}
    m_sort_energy_ascending=b.m_sort_energy_ascending;
    m_cflags=b.m_cflags;
    m_aflags=b.m_aflags;
    m_allow_all_formation_energies=b.m_allow_all_formation_energies;
    m_allowed_dft_types.clear(); for(uint i=0,fl_size_i=b.m_allowed_dft_types.size();i<fl_size_i;i++){m_allowed_dft_types.push_back(b.m_allowed_dft_types[i]);}
    h_dim=b.h_dim;
    m_elements_present=b.m_elements_present;
    h_points.clear(); for(uint i=0,fl_size_i=b.h_points.size();i<fl_size_i;i++){h_points.push_back(b.h_points[i]);}
    h_centroid=b.h_centroid;
    h_reference=b.h_reference;
    h_facets.clear(); for(uint i=0,fl_size_i=b.h_facets.size();i<fl_size_i;i++){h_facets.push_back(b.h_facets[i]);}
    h_visible_facets.clear(); for(uint i=0,fl_size_i=b.h_visible_facets.size();i<fl_size_i;i++){h_visible_facets.push_back(b.h_visible_facets[i]);}
    h_horizon_ridges.clear(); for(uint i=0,fl_size_i=b.h_horizon_ridges.size();i<fl_size_i;i++){h_horizon_ridges.push_back(b.h_horizon_ridges[i]);}
  }

  bool ConvexHull::initialize(ostream& oss) {
    xStream::initialize(oss);
    return initialize();
  }

  bool ConvexHull::initialize(const string& alloy,ostream& oss) {
    xStream::initialize(oss);
    return initialize(alloy);
  }

  bool ConvexHull::initialize(const vector<string>& velements,ostream& oss) {
    xStream::initialize(oss);
    return initialize(velements);
  }

  bool ConvexHull::initialize(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ostream& oss) {
    xStream::initialize(oss);
    return initialize(velements,entries);
  }

  bool ConvexHull::initialize(const vector<xvector<double> >& vcoords,ostream& oss,bool has_stoich_coords,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(oss);
    return initialize(vcoords,has_stoich_coords,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const vector<ChullPoint>& vpoints,ostream& oss,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(oss);
    return initialize(vpoints,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const vector<ChullPoint>& vpoints,const vector<string>& velements,ostream& oss,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(oss);
    return initialize(vpoints,velements,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(ofstream& FileMESSAGE,ostream& oss) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize();
  }

  bool ConvexHull::initialize(const string& alloy,ofstream& FileMESSAGE,ostream& oss) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(alloy);
  }

  bool ConvexHull::initialize(const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(velements);
  }

  bool ConvexHull::initialize(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ofstream& FileMESSAGE,ostream& oss) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(velements,entries);
  }

  bool ConvexHull::initialize(const vector<xvector<double> >& vcoords,ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(vcoords,has_stoich_coords,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const vector<ChullPoint>& vpoints,ofstream& FileMESSAGE,ostream& oss,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(vpoints,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const vector<ChullPoint>& vpoints,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(vpoints,velements,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize() {
    free();
    try{
      setDefaultCFlags();
      setDirectory();
      m_initialized=false;  //no points
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return m_initialized;
  }

  bool ConvexHull::initialize(const string& alloy) {
    free();
    try{
      setDefaultCFlags();
      setDirectory();
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return createHull(alloy);
  }

  bool ConvexHull::initialize(const vector<string>& velements) {
    free();
    try{
      setDefaultCFlags();
      setDirectory();
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return createHull(velements);
  }

  bool ConvexHull::initialize(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries) {
    free();
    try{
      setDefaultCFlags();
      setDirectory();
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return createHull(velements,entries);
  }

  bool ConvexHull::initialize(const vector<xvector<double> >& vcoords,bool has_stoich_coords,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    free();
    try{
      setDefaultCFlags();
      setDirectory();
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return createHull(vcoords,has_stoich_coords,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const vector<ChullPoint>& vpoints,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    free();
    try{
      setDefaultCFlags();
      setDirectory();
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return createHull(vpoints,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const vector<ChullPoint>& vpoints,const vector<string>& velements,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    free();
    try{
      setDefaultCFlags();
      setDirectory();
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return createHull(vpoints,velements,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,ostream& oss) {
    xStream::initialize(oss);
    return initialize(vpflow);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const string& alloy,ostream& oss) {
    xStream::initialize(oss);
    return initialize(vpflow,alloy);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<string>& velements,ostream& oss) {
    xStream::initialize(oss);
    return initialize(vpflow,velements);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ostream& oss) {
    xStream::initialize(oss);
    return initialize(vpflow,velements,entries);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<xvector<double> >& vcoords,ostream& oss,bool has_stoich_coords,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(oss);
    return initialize(vpflow,vcoords,has_stoich_coords,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,ostream& oss,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(oss);
    return initialize(vpflow,vpoints,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,const vector<string>& velements,ostream& oss,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(oss);
    return initialize(vpflow,vpoints,velements,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,ofstream& FileMESSAGE,ostream& oss) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(vpflow);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const string& alloy,ofstream& FileMESSAGE,ostream& oss) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(vpflow,alloy);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(vpflow,velements);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries,ofstream& FileMESSAGE,ostream& oss) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(vpflow,velements,entries);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<xvector<double> >& vcoords,ofstream& FileMESSAGE,ostream& oss,bool has_stoich_coords,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(vpflow,vcoords,has_stoich_coords,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,ofstream& FileMESSAGE,ostream& oss,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(vpflow,vpoints,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,const vector<string>& velements,ofstream& FileMESSAGE,ostream& oss,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    xStream::initialize(FileMESSAGE,oss);
    return initialize(vpflow,vpoints,velements,formation_enthalpy_hull,add_artificial_unaries);
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow) {
    free();
    try{
      setCFlags(vpflow);
      setDirectory();
      m_initialized=false;  //no points
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return m_initialized;
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const string& alloy) {
    free();
    try{
      setCFlags(vpflow);
      setDirectory();
      m_initialized=createHull(alloy);
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return m_initialized;
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<string>& velements) {
    free();
    try{
      setCFlags(vpflow);
      setDirectory();
      m_initialized=createHull(velements);
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return m_initialized;
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries) {
    free();
    try{
      setCFlags(vpflow);
      setDirectory();
      m_initialized=createHull(velements,entries);
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return m_initialized;
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<xvector<double> >& vcoords,bool has_stoich_coords,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    free();
    try{
      setCFlags(vpflow);
      setDirectory();
      m_initialized=createHull(vcoords,has_stoich_coords,formation_enthalpy_hull,add_artificial_unaries);
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return m_initialized;
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    free();
    try{
      setCFlags(vpflow);
      setDirectory();
      m_initialized=createHull(vpoints,formation_enthalpy_hull,add_artificial_unaries);
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return m_initialized;
  }

  bool ConvexHull::initialize(const aurostd::xoption& vpflow,const vector<ChullPoint>& vpoints,const vector<string>& velements,bool formation_enthalpy_hull,bool add_artificial_unaries) {
    free();
    try{
      setCFlags(vpflow);
      setDirectory();
      m_initialized=createHull(vpoints,velements,formation_enthalpy_hull,add_artificial_unaries);
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return m_initialized;
  }

  void ConvexHull::initializePoints(const string& alloy){
    loadPoints(alloy);
    structurePoints();
  }

  void ConvexHull::initializePoints(const vector<string>& velements){
    loadPoints(velements);
    structurePoints();
  }

  void ConvexHull::initializePoints(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries){
    loadPoints(velements,entries);
    structurePoints();
  }

  void ConvexHull::initializePoints(const vector<xvector<double> >& vcoords,bool has_stoich_coords,bool formation_enthalpy_hull,bool add_artificial_unaries){
    loadPoints(vcoords,has_stoich_coords,formation_enthalpy_hull,add_artificial_unaries);
    structurePoints();
  }

  void ConvexHull::initializePoints(const vector<ChullPoint>& vpoints,bool formation_enthalpy_hull,bool add_artificial_unaries){
    loadPoints(vpoints,formation_enthalpy_hull,add_artificial_unaries);
    structurePoints();
  }

  void ConvexHull::initializePoints(const vector<ChullPoint>& vpoints,const vector<string>& velements,bool formation_enthalpy_hull,bool add_artificial_unaries){
    loadPoints(vpoints,velements,formation_enthalpy_hull,add_artificial_unaries);
    structurePoints();
  }

  uint ConvexHull::getDim() const {return m_dim;}
  uint ConvexHull::getEntriesCount(bool only_within_half_hull) const {
    string soliloquy=XPID+"ConvexHull::getEntriesCount():";
    uint i_point=AUROSTD_MAX_UINT,count=0;
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] is not initialized");}
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        if(m_points[i_point].m_is_artificial){continue;}
        if(only_within_half_hull&&m_half_hull){
          if(m_points[i_point].isWithinHalfHull(m_lower_hull)){count++;}
        } else {count++;}
      }
    }
    return count;
  }

  uint ConvexHull::getEntriesCount(uint i_nary,bool only_within_half_hull) const {
    string soliloquy=XPID+"ConvexHull::getEntriesCount():";
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    uint count=0;
    if(i_nary>m_naries.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){count+=getEntriesCount(i_nary,i_alloy,only_within_half_hull);}
    return count;
  }

  uint ConvexHull::getEntriesCount(uint i_nary,uint i_alloy,bool only_within_half_hull) const {
    string soliloquy=XPID+"ConvexHull::getEntriesCount():";
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    uint i_point=AUROSTD_MAX_UINT,count=0,i_coord_group=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i<fl_size_i;i++){
      i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] is not initialized");}
      for(uint j=0,fl_size_j=m_coord_groups[i_coord_group].m_points.size();j<fl_size_j;j++){
        i_point=m_coord_groups[i_coord_group].m_points[j];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        if(m_points[i_point].m_is_artificial){continue;}
        if(only_within_half_hull&&m_half_hull){
          if(m_points[i_point].isWithinHalfHull(m_lower_hull)){count++;}
        } else {count++;}
      }
    }
    return count;
  }

  vector<vector<uint> > ConvexHull::getHullSizes(bool only_within_half_hull) const {
    vector<vector<uint> > counts;
    for(uint i_nary1=0,fl_size_i_nary1=m_naries.size();i_nary1<fl_size_i_nary1;i_nary1++){
      counts.push_back(vector<uint>(0));
      for(uint i_alloy1=0,fl_size_i_alloy1=m_naries[i_nary1].m_alloys.size();i_alloy1<fl_size_i_alloy1;i_alloy1++){
        counts[i_nary1].push_back(0);
      }
    }
    for(uint i_nary1=0,fl_size_i_nary1=m_naries.size();i_nary1<fl_size_i_nary1;i_nary1++){
      for(uint i_alloy1=0,fl_size_i_alloy1=m_naries[i_nary1].m_alloys.size();i_alloy1<fl_size_i_alloy1;i_alloy1++){
        //m_naries[i_nary1].m_alloys[i_alloy1].m_elements_present is relevant hull dimensions
        const xvector<int>& elements_present_hull=m_naries[i_nary1].m_alloys[i_alloy1].m_elements_present;
        for(uint i_nary2=0;i_nary2<=i_nary1;i_nary2++){ //up to i_nary1
          for(uint i_alloy2=0,fl_size_i_alloy2=m_naries[i_nary2].m_alloys.size();i_alloy2<fl_size_i_alloy2;i_alloy2++){
            //space==m_naries[i_nary1].m_alloys[i_alloy1].m_elements_present, subspace==m_naries[i_nary2].m_alloys[i_alloy2].m_elements_present
            if(subspaceBelongs(elements_present_hull,m_naries[i_nary2].m_alloys[i_alloy2].m_elements_present)){
              counts[i_nary1][i_alloy1]+=getEntriesCount(i_nary2,i_alloy2,only_within_half_hull);
            }
          }
        }
      }
    }
    return counts;
  }

  uint ConvexHull::getGStateCount() const {
    string soliloquy=XPID+"ConvexHull::getGStateCount():";
    uint i_point=AUROSTD_MAX_UINT,count=0;
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        if(m_points[i_point].m_is_g_state){count++;}
      }
    }
    return count;
  }

  uint ConvexHull::getGStateCount(uint i_nary) const {
    string soliloquy=XPID+"ConvexHull::getGStateCount():";
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    uint i_point=AUROSTD_MAX_UINT,i_coord_group=AUROSTD_MAX_UINT,count=0;
    for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
      for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i<fl_size_i;i++){
        i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
        if(!m_coord_groups[i_coord_group].m_is_on_hull){continue;}  //if it's not on the hull, definitely won't contain gstates
        for(uint j=0,fl_size_j=m_coord_groups[i_coord_group].m_points.size();j<fl_size_j;j++){
          i_point=m_coord_groups[i_coord_group].m_points[j];
          if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
          if(m_points[i_point].m_is_g_state){count++;}
        }
      }
    }
    return count;
  }

  vector<uint> ConvexHull::getHullPoints(bool sort_stoich_ascending) const { //pure hull-members, not equivalent ones too
    string soliloquy=XPID+"ConvexHull::getHullPoints():";
    vector<uint> hull_points;
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        if(m_points[i_point].m_is_on_hull){hull_points.push_back(i_point);}
      }
    }
    std::sort(hull_points.begin(),hull_points.end(),sortCHullPoints(m_points,sort_stoich_ascending,true));
    return hull_points;
  }

  vector<uint> ConvexHull::getGStates(bool include_unaries,bool sort_stoich_ascending) const { //pure g_states, not equivalent ones too
    string soliloquy=XPID+"ConvexHull::getGStates():";
    vector<uint> g_states;
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
      if(m_coord_groups[i_coord_group].m_is_on_hull){
        if(!isViablePoint(m_coord_groups[i_coord_group].m_hull_member)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No hull member set for m_coord_group["+aurostd::utype2string(i_coord_group)+"]");}
        i_point=artificialMap(m_coord_groups[i_coord_group].m_hull_member);
        if(!isViableGState(i_point)){continue;}  //could be legitimately missing g-state unary
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        if(!m_points[i_point].m_is_g_state){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Mis-identified ground-state structure");}
        if(!(!include_unaries && m_points[i_point].isUnary())){g_states.push_back(i_point);}
      }
    }
    std::sort(g_states.begin(),g_states.end(),sortCHullPoints(m_points,sort_stoich_ascending,true));
    return g_states;
  }

  uint ConvexHull::getUnaryGState(uint i_alloy) const {
    string soliloquy=XPID+"ConvexHull::getUnaryGState():";
    uint i_nary=0;
    if(i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within alloys");}
    uint g_state=AUROSTD_MAX_UINT;
    if(m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size()!=1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unexpected count of coordgroups for unaries, should only be 1");}
    uint i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[0];
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
      i_point=m_coord_groups[i_coord_group].m_points[i];
      if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
      if(m_points[i_point].m_is_g_state){
        g_state=i_point;
        return g_state;
      }
    }
    return g_state;
  }

  bool ConvexHull::isViablePoint(uint i_point) const {return i_point<m_points.size();}
  bool ConvexHull::isViableGState(uint g_state) const {return isViablePoint(g_state) && m_points[g_state].m_has_entry;}

  bool ConvexHull::findPoint(const string& auid,uint& i_point) const{
    uint _i_point;
    //do NOT go through m_points, this may include some duplicates we previously excluded (now not duplicates since we are removing points: AlFe hull)
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        _i_point=m_coord_groups[i_coord_group].m_points[i];
        if(!m_points[_i_point].m_has_entry){continue;}
        if(m_points[_i_point].m_entry.auid==auid){i_point=_i_point;return true;}
      }
    }
    return false;
  }

  bool ConvexHull::findPoint(const xvector<double>& coords,uint& i_point) const{
    uint _i_point;
    //do NOT go through m_points, this may include some duplicates we previously excluded (now not duplicates since we are removing points: AlFe hull)
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        _i_point=m_coord_groups[i_coord_group].m_points[i];
        if(aurostd::identical(m_points[_i_point].m_coords,coords,ZERO_TOL)){i_point=_i_point;return true;}
      }
    }
    return false;
  }

  bool ConvexHull::getNariesIndex(uint i_point,uint& i_nary,uint& i_alloy,uint& i_coord_group,bool redo) const{
    string soliloquy=XPID+"ConvexHull::getNariesIndex():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    return getNariesIndex(m_points[i_point],i_nary,i_alloy,i_coord_group,redo);
  }

  bool ConvexHull::getNariesIndex(const ChullPoint& point,uint& i_nary,uint& i_alloy,uint& i_coord_group,bool redo) const{
    string soliloquy=XPID+"ConvexHull::getNariesIndex():";
    if(!point.m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point does not have stoich coordinates");}
    return (getAlloyIndex(point,i_nary,i_alloy,redo) && getCoordGroupIndex(point,i_coord_group,redo));
  }

  bool ConvexHull::getCoordGroupIndex(uint i_point,uint& i_coord_group,bool redo) const {
    string soliloquy=XPID+"ConvexHull::getCoordGroupIndex():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    return getCoordGroupIndex(m_points[i_point],i_coord_group,redo);
  }

  bool ConvexHull::getCoordGroupIndex(const ChullPoint& point,uint& i_coord_group,bool redo) const {
    string soliloquy=XPID+"ConvexHull::getCoordGroupIndex():";
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized chullpoint");}
    if(!redo){
      i_coord_group=point.m_i_coord_group;
      if(i_coord_group<m_coord_groups.size()){return true;}
    }
    return getCoordGroupIndex(point.getStoichiometricCoords(),i_coord_group);
  }

  bool ConvexHull::getCoordGroupIndex(const xvector<double>& r_coords,uint& i_coord_group) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getCoordGroupIndex():";
    if(LDEBUG){
      cerr << soliloquy << " r_coords=" << r_coords << endl;
      cerr << soliloquy << " m_coord_groups.size()=" << m_coord_groups.size() << endl;
      for(uint i=0,fl_size_i=m_coord_groups.size();i<fl_size_i;i++){
        cerr << soliloquy << " m_coord_groups[i=" << i << "].m_coords=" << m_coord_groups[i].m_coords << endl;
      }
    }
    for(uint i=0,fl_size_i=m_coord_groups.size();i<fl_size_i;i++){
      if(!m_coord_groups[i].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
      if(coordsIdentical(m_coord_groups[i].m_coords,r_coords)){
        i_coord_group=i;
        return true;
      }
      if(LDEBUG){cerr << soliloquy << " m_coord_groups[i=" << i << "].m_coords=" << m_coord_groups[i].m_coords << " != " << "r_coords=" << r_coords << endl;}
    }
    if(LDEBUG){cerr << soliloquy << " no coord_group index found for r_coords=" << r_coords << endl;}
    return false;
  }

  bool ConvexHull::getAlloyIndex(const ChullPoint& point,uint& i_nary,uint& i_alloy,bool redo) const {
    string soliloquy=XPID+"ConvexHull::getAlloyIndex():";
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized chullpoint");}
    if(!point.m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point does not have stoich coordinates");}
    if(!redo){
      i_nary=point.m_i_nary;
      i_alloy=point.m_i_alloy;
      if(i_nary<m_naries.size() && i_alloy<m_naries[i_nary].m_alloys.size()){return true;}
    }
    return getAlloyIndex(point.m_elements_present,i_nary,i_alloy);
  }

  bool ConvexHull::getAlloyIndex(const CoordGroup& cg,uint& i_nary,uint& i_alloy,bool redo) const {
    string soliloquy=XPID+"ConvexHull::getAlloyIndex():";
    if(!cg.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
    if(!cg.m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup does not have stoich coordinates");}
    if(!cg.m_points.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup has no points");}
    if(!redo){
      i_nary=cg.m_i_nary;
      i_alloy=cg.m_i_alloy;
      if(i_nary<m_naries.size() && i_alloy<m_naries[i_nary].m_alloys.size()){return true;}
    }
    return getAlloyIndex(cg.getElementsPresent(),i_nary,i_alloy);
  }

  bool ConvexHull::getAlloyIndex(const xvector<int>& elements_present,uint& i_nary,uint& i_alloy) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getAlloyIndex():";
    if(LDEBUG) {cerr << soliloquy << " BEGIN" << endl;}
    i_nary=sum(elements_present)-1;
    if(i_nary>m_naries.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(LDEBUG) {cerr << soliloquy << " elements_present=" << elements_present << endl;}
    for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys.size();i<fl_size_i;i++){
      if(!m_naries[i_nary].m_alloys[i].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
      if(LDEBUG){cerr << soliloquy << " m_naries[i_nary=" << i_nary << "].m_alloys[i=" << i << "].m_elements_present=" << m_naries[i_nary].m_alloys[i].m_elements_present << endl;}
      if(m_naries[i_nary].m_alloys[i].m_elements_present==elements_present){
        i_alloy=i;
        return true;
      }
    }
    return false;
  }

  uint ConvexHull::artificialMap(uint i_point) const{
    string soliloquy=XPID+"ConvexHull::artificialMap():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_points");}
    if(!m_points[i_point].m_is_artificial){return i_point;}
    //we found an artificial point, but was it supposed to be here?
    if(!m_add_artificial_unaries){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid artificial point, not sure how to handle mapping");}

    const ChullPoint& art_point=m_points[i_point];
    uint i_coord_group=AUROSTD_MAX_UINT;
    if(!getCoordGroupIndex(art_point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
    if(m_coord_groups[i_coord_group].m_points.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}

    uint i_point_new=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
      i_point_new=m_coord_groups[i_coord_group].m_points[i];
      if(!m_points[i_point_new].m_is_artificial){return i_point_new;}
    }

    //if we get here, there are no viable replacements, simply return artificial point
    if(m_coord_groups[i_coord_group].m_points.size()==1){if(m_coord_groups[i_coord_group].m_points[0]==i_point){return i_point;}}

    //really bad if we get here
    throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Cannot determine artificial point mapping");
  }

  bool ConvexHull::write(filetype ftype) const {
    bool written=false;
    try{
      if(ftype==chull_apool_ft){writeAPool();written=true;}
      else if(ftype==json_ft||ftype==txt_ft){writeText(ftype);written=true;}
      else if(ftype==latex_ft){writeLatex();written=true;}
      else if(ftype==chull_web_ft){writeWebApp();written=true;}
    }
    catch(aurostd::xerror& err){pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);}
    return written;
  }

  void ConvexHull::setDefaultCFlags() {pflow::defaultLoadEntriesFlags(m_cflags, *p_FileMESSAGE, *p_oss, std::string("A"), false, true);}
  void ConvexHull::setCFlags(const aurostd::xoption& vpflow) {m_cflags=vpflow;}
  void ConvexHull::setDirectory() {m_aflags.Directory=getPath(m_cflags,*p_FileMESSAGE,*p_oss);}
  //MOVED TO xStream
  //void ConvexHull::setOFStream(ofstream& FileMESSAGE){p_FileMESSAGE=&FileMESSAGE;}
  //void ConvexHull::setOSS(ostream& oss) {p_oss=&oss;}

  bool ConvexHull::createHull(const string& alloy) {
    try{
      initializePoints(alloy);
      checkStructurePoints(); //some nice checks that everything checks out
      calculate();
      m_initialized=true;
      //hull must be initialized for these analyses
      thermodynamicsPostProcessing(); // will return if not m_thermo_hull
    }
    catch(aurostd::xerror& err){
      pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
      clear();
    }
    return m_initialized;
  }

  bool ConvexHull::createHull(const vector<string>& velements) {
    try{
      initializePoints(velements);
      checkStructurePoints(); //some nice checks that everything checks out
      calculate();
      m_initialized=true;
      //hull must be initialized for these analyses
      thermodynamicsPostProcessing(); // will return if not m_thermo_hull
    }
    catch(aurostd::xerror& err){
      pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
      clear();
    }
    return m_initialized;
  }

  bool ConvexHull::createHull(const vector<string>& velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries) {
    try{
      initializePoints(velements,entries);
      checkStructurePoints(); //some nice checks that everything checks out
      calculate();
      m_initialized=true;
      //hull must be initialized for these analyses
      thermodynamicsPostProcessing(); // will return if not m_thermo_hull
    }
    catch(aurostd::xerror& err){
      pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
      clear();
    }
    return m_initialized;
  }

  bool ConvexHull::createHull(const vector<xvector<double> >& vcoords,bool has_stoich_coords,bool formation_energy_hull,bool add_artificial_unaries) {
    try{
      initializePoints(vcoords,has_stoich_coords,formation_energy_hull,add_artificial_unaries);
      checkStructurePoints(); //some nice checks that everything checks out
      calculate();
      m_initialized=true;
      //hull must be initialized for these analyses
      thermodynamicsPostProcessing(); // will return if not m_thermo_hull
    }
    catch(aurostd::xerror& err){
      pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
      clear();
    }
    return m_initialized;
  }

  bool ConvexHull::createHull(const vector<ChullPoint>& vpoints,bool formation_energy_hull,bool add_artificial_unaries) {
    try{
      initializePoints(vpoints,formation_energy_hull,add_artificial_unaries);
      checkStructurePoints(); //some nice checks that everything checks out
      calculate();
      m_initialized=true;
      //hull must be initialized for these analyses
      thermodynamicsPostProcessing(); // will return if not m_thermo_hull
    }
    catch(aurostd::xerror& err){
      pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
      clear();
    }
    return m_initialized;
  }

  bool ConvexHull::createHull(const vector<ChullPoint>& vpoints,const vector<string>& velements,bool formation_energy_hull,bool add_artificial_unaries) {
    try{
      initializePoints(vpoints,velements,formation_energy_hull,add_artificial_unaries);
      checkStructurePoints(); //some nice checks that everything checks out
      calculate();
      m_initialized=true;
      //hull must be initialized for these analyses
      thermodynamicsPostProcessing(); // will return if not m_thermo_hull
    }
    catch(aurostd::xerror& err){
      pflow::logger(err.whereFileName(), err.whereFunction(), err.what(), m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_ERROR_);
      clear();
    }
    return m_initialized;
  }

  bool ConvexHull::entryValid(const aflowlib::_aflowlib_entry& entry,bool ignore_bad_database) const {
    string reason;
    return entryValid(entry,reason,ignore_bad_database);
  }

  bool ConvexHull::entryValid(const aflowlib::_aflowlib_entry& entry,string& reason,bool ignore_bad_database) const {
    char LOGGER_TYPE=_LOGGER_OPTION_;
    return entryValid(entry,reason,LOGGER_TYPE,ignore_bad_database);
  }

  bool ConvexHull::entryValid(const aflowlib::_aflowlib_entry& entry,string& reason,char& LOGGER_TYPE,bool ignore_bad_database) const {
    string soliloquy=XPID+"ConvexHull::entryValid():";
    reason="";
    LOGGER_TYPE=_LOGGER_OPTION_;
    //tests of stupidity
    if(entry.vspecies.size()!=entry.vcomposition.size()){
      if(entry.prototype.find("POCC")==string::npos){ //POCC entries have no composition
        //throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Bad entry ("+entry.auid+") - vspecies.size!=vcomposition.size()"); //let's not break the code for one bad entry
        reason="Entry (auid="+entry.auid+") is ill-defined: vspecies.size()!=vcomposition.size()";
        reason+=" (please report on AFLOW Forum: aflow.org/forum)";
        LOGGER_TYPE=_LOGGER_WARNING_;
        return false;
      }
    }
    bool found=false;
    for(uint j=0,fl_size_j=entry.vspecies.size();j<fl_size_j;j++){
      found=false;
      for(uint i=0,fl_size_i=m_velements.size();i<fl_size_i && !found;i++){if(m_velements[i]==entry.vspecies[j]){found=true;}}
      if(!found){
        reason="Entry (auid="+entry.auid+") contains "+entry.vspecies[j]+" and does not belong to hull";
        reason+=" (please report on AFLOW Forum: aflow.org/forum)";
        LOGGER_TYPE=_LOGGER_WARNING_;
        return false;
      }
    }
    if(!entry.ldau_TLUJ.empty()){
      reason="calculated with +U parameters";
      return false;
    }
    //mimic SC's approach from aflow_apennsy_gndstate.cpp
    //if(aurostd::substring2bool(entry.entry,"LDAU")){  //should be redundant, but less exclusive than looking for ldau_TLUJ
    //  reason="calculated with +U parameters";
    //  return false;
    //}
    //improved with aflowrc dft_type banning below
    //this helps with BSm, which was run mostly with PAW_GGA
    //if(entry.dft_type!="PAW_PBE" && !((ADD_SC_BSm_EXCEPTION)&&(entry.dft_type=="PAW_GGA" && aurostd::substring2bool(entry.entry,"B_hSm_3")))){ //SC exception
    //  reason="not calculated with PAW_PBE (dft_type=="+entry.dft_type+")";
    //  return false;
    //}
    //filters must be wide to narrow
    if(!m_allow_all_formation_energies){
      if(!aurostd::WithinList(m_allowed_dft_types,entry.dft_type)){
        reason="not calculated with allowed DFT-type: dft_type=="+entry.dft_type+" (allowed="+aurostd::joinWDelimiter(m_allowed_dft_types,",")+")";
        return false;
      }
    }
    if(aurostd::substring2bool(entry.entry,"NUPDOWN")){
      reason="calculated with manual NUPDOWN, thus E-fermi is NOT adjusted for spin-up"; //as explained in ovasp
      return false;
    }
    if(H_f_atom(entry)==AUROSTD_NAN || entry.entropic_temperature==AUROSTD_NAN){  //entry.enthalpy_formation_atom
      reason="enthalpy_formation_atom/entropic_temperature not calculated";
      return false;
    }
    if(ignore_bad_database && entry.ignoreBadDatabase(reason)){return false;}
    //otherwise return true
    return true;
  }

  void ConvexHull::addArtificialUnaries(uint dim){
    //points are really dim+1 dimensional (hidden dimension)
    //really, dim specifies within s_coords unless dim == s_coords.size()
    //then it's the last coord
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::addArtificialUnaries():";
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    if(dim>m_dim-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid dimension requested");}
    xvector<double> dummy(m_dim);
    if(dim!=m_dim-1){dummy[dim+dummy.lrows]=1;}
    m_points.push_back(ChullPoint(dummy,*p_FileMESSAGE,*p_oss,m_has_stoich_coords,m_formation_energy_hull,true));
    if(LDEBUG) {cerr << soliloquy << " new artificial point=" << m_points.back().m_coords << endl;}
  }

  void ConvexHull::addArtificialUnaries(){for(uint i=0;i<m_dim;i++){addArtificialUnaries(i);}}

  bool ConvexHull::entryUnique(const vector<uint>& unique_entries,const aflowlib::_aflowlib_entry& entry,string& canonical_auid) const {
    //points have already been created, determined to be unique
    //hack, go backwards, as the way entries are ordered, duplicates occur near each other
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    canonical_auid="";
    string soliloquy=XPID+"ConvexHull::entryUnique():";
    for(uint fl_size_i=unique_entries.size(),i=fl_size_i-1;i<fl_size_i;i--){
      const ChullPoint& point=m_points[unique_entries[i]];
      if(point.entryIdentical(entry)){
        if(LDEBUG) {
          cerr << soliloquy << " entry[auid=" << point.m_entry.auid << ",compound=" << point.m_entry.compound << ",prototype=" << point.m_entry.prototype << "] == ";
          cerr << "entry[auid=" << entry.auid << ",compound=" << entry.compound << ",prototype=" << entry.prototype << "]" << endl;
        }
        canonical_auid=point.m_entry.auid;
        return false;
      }
    }
    return true;
  }

  void ConvexHull::loadPoints(const string& alloy) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::loadPoints():";
    if(LDEBUG) {cerr << soliloquy << " initializing alloy, compound=" << alloy << endl;}
    vector<string> velements = aurostd::getElements(alloy, pp_string, *p_FileMESSAGE, true, true, false, *p_oss); //clean and sort, do not keep_pp  //CO20190712
    //[CO20190712 - OBSOLETE]vector<string> velements = pflow::getAlphabeticVectorString(alloy, *p_FileMESSAGE, *p_oss);
    return loadPoints(velements);
  }

  void ConvexHull::loadPoints(const vector<string>& _velements) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::loadPoints():";

    vector<string> velements; 
    for(uint i=0,fl_size_i=_velements.size();i<fl_size_i;i++){velements.push_back(_velements[i]);}
    std::sort(velements.begin(),velements.end()); //safe

    if(LDEBUG) {cerr << soliloquy << " initializing velements, velements=" << aurostd::joinWDelimiter(velements,",") << endl;}

    vector<vector<vector<aflowlib::_aflowlib_entry> > > entries;
    pflow::loadEntries(m_cflags,velements,entries,*p_FileMESSAGE,*p_oss);
    return loadPoints(velements,entries);
  }

  void ConvexHull::loadPoints(const vector<string>& _velements,const vector<vector<vector<aflowlib::_aflowlib_entry> > >& entries) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::loadPoints():";
    stringstream message;

    vector<string> velements;
    velements.clear(); for(uint i=0,fl_size_i=_velements.size();i<fl_size_i;i++){velements.push_back(_velements[i]);}
    std::sort(velements.begin(),velements.end()); //safe

    if(LDEBUG) {cerr << soliloquy << " initializing velements WITH entries, velements=" << aurostd::joinWDelimiter(velements,",") << endl;}

    m_has_stoich_coords=true;
    m_formation_energy_hull=!m_cflags.flag("CHULL::ENTROPIC_TEMPERATURE");    //energy vs. entropic_temperature hull
    m_half_hull=true;
    m_lower_hull=m_formation_energy_hull; //energy/entropic_temperature lower/upper hull
    m_add_artificial_unaries=true;

    vector<ChullPoint> points;
    ChullPoint cp;

    for(uint i=0,fl_size_i=entries.size();i<fl_size_i;i++){
      for(uint j=0,fl_size_j=entries[i].size();j<fl_size_j;j++){
        for(uint k=0,fl_size_k=entries[i][j].size();k<fl_size_k;k++){
          cp.initialize(velements,entries[i][j][k],*p_FileMESSAGE,*p_oss,m_formation_energy_hull);
          points.push_back(cp);
          //save icsd entries
          if(aurostd::substring2bool(entries[i][j][k].prototype,"_ICSD_")){m_icsd_entries.push_back(points.size()-1);}
        }
      }
    }
    if(!points.size()){
      message << "No entries loaded";
      //simply always die here, we cannot grab dimensionality of hull without ANY points
      if(0&&m_cflags.flag("FORCE")){pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);}
      else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
    }
    return loadPoints(points,velements,m_formation_energy_hull,m_add_artificial_unaries);
  }

  void ConvexHull::loadPoints(const vector<xvector<double> >& vcoords,bool has_stoich_coords,bool formation_energy_hull,bool add_artificial_unaries) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::loadPoints():";
    vector<ChullPoint> points;
    if(LDEBUG) {cerr << soliloquy << " initializing vcoords (has_stoich_coords==" << has_stoich_coords << "), count=" << vcoords.size() << endl;}
    ChullPoint cp;
    for(uint i=0,fl_size_i=vcoords.size();i<fl_size_i;i++){
      cp.initialize(vcoords[i],*p_FileMESSAGE,*p_oss,has_stoich_coords,formation_energy_hull);
      points.push_back(cp);
    }
    return loadPoints(points,formation_energy_hull,add_artificial_unaries);
  }

  void ConvexHull::loadPoints(const vector<ChullPoint>& vpoints,bool formation_energy_hull,bool add_artificial_unaries) {
    vector<string> velements;
    return loadPoints(vpoints,velements,formation_energy_hull,add_artificial_unaries);
  }

  void ConvexHull::loadPoints(const vector<ChullPoint>& vpoints,const vector<string>& velements,bool formation_energy_hull,bool add_artificial_unaries) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::loadPoints():";
    stringstream message;

    if(velements.size()){
      m_velements.clear(); for(uint i=0,fl_size_i=velements.size();i<fl_size_i;i++){m_velements.push_back(velements[i]);}
      std::sort(m_velements.begin(),m_velements.end()); //safe
    }

    if(LDEBUG) {cerr << soliloquy << " initializing chullpoints, count=" << vpoints.size() << endl;}
    for(uint i=0,fl_size_i=vpoints.size();i<fl_size_i;i++){m_points.push_back(vpoints[i]);};
    if(!m_points.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No points loaded, no way to determine dimensionality of hull");}

    //flag defaults
    m_formation_energy_hull=formation_energy_hull;    //energy vs. entropic_temperature hull
    if(m_formation_energy_hull){m_half_hull=m_lower_hull=true;} //default
    m_half_hull=(m_half_hull && m_cflags.flag("CHULL::FULL_HULL")==false); //energy/entropic_temperature lower/upper hull //override with flag from m_cflags  //HE20210510 - added CHULL::FULL_HULL
    m_lower_hull=(m_formation_energy_hull && m_cflags.flag("CHULL::FULL_HULL")==false); //energy/entropic_temperature lower/upper hull //override with flag from m_cflags  //HE20210510 - added CHULL::FULL_HULL

    m_add_artificial_unaries=add_artificial_unaries;

    //detect for coord types mixture!
    m_has_stoich_coords=( m_points[0].m_has_stoich_coords || m_has_stoich_coords );
    m_dim=m_points[0].m_coords.rows;
    if(m_dim<2){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"1D hulls are trivial");} //this MUST be true: chull cannot find facets for 1D hulls
    //test of stupidity
    for(uint i=0,fl_size_i=m_points.size();i<fl_size_i;i++){
      if(!m_points[i].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
      if(m_points[i].getDim()!=m_dim){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch among points");}
      if(m_points[i].m_has_stoich_coords!=m_has_stoich_coords){
        message << "Mismatch among coord types (stoich vs. non-stoich coords), assuming non-stoich coords";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        m_has_stoich_coords=false;
        break;
      }
    }

    if(m_half_hull && m_has_stoich_coords && m_add_artificial_unaries){m_thermo_hull=true;}
    if(LDEBUG) {
      cerr << soliloquy << " thermo_hull=" << m_thermo_hull << endl;
      cerr << soliloquy << " has_stoich_coords=" << m_has_stoich_coords << endl;
      cerr << soliloquy << " half_hull=" << m_half_hull << endl;
      cerr << soliloquy << " lower_hull=" << m_lower_hull << endl;
      cerr << soliloquy << " add_artificial_unaries=" << m_add_artificial_unaries << endl;
    }

    //ensures proper construction of hull
    //duplicates DO NOT AFFECT performance/accuracy of algorithm
    //we ignore these points after hull construction anyway
    if(m_add_artificial_unaries){addArtificialUnaries();}

    //get s_coords
    if(m_has_stoich_coords){for(uint i=0,fl_size_i=m_points.size();i<fl_size_i;i++){m_points[i].setStoichCoords();}} //repetita iuvant

    //if(0){  //do NOT resort points, keep in same order as user input
    //  if(LDEBUG) {cerr << soliloquy << " resorting all points (including artificial points) by coord/stoich (descending) and energy (ascending)" << endl;}
    //  std::sort(m_points.begin(),m_points.end());
    //}

    //DO NOT ADD/SUBTRACT/CHANGE-ORDER OF M_POINTS BEYOND THIS FUNCTION
  }

  void ConvexHull::calculateOutlierThreshold(const vector<double>& _energies,double& upper_threshold,double& lower_threshold) {
    xvector<double> energies=aurostd::vector2xvector<double>(_energies);
    return calculateOutlierThreshold(energies,upper_threshold,lower_threshold);
  }

  void ConvexHull::calculateOutlierThreshold(const xvector<double>& energies,double& upper_threshold,double& lower_threshold) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::calculateOutlierThreshold():";
    stringstream message;

    upper_threshold=AUROSTD_MAX_DOUBLE;   //effectively NOT a threshold
    lower_threshold=-AUROSTD_MAX_DOUBLE;  //effectively NOT a threshold

    //nice solution here! but only works for odd counts
    //http://en.cppreference.com/w/cpp/algorithm/nth_element
    bool iqr_method=true; //unfortunately, MAD is normal distribution dependent, NOT our case here

    uint iqr_count_threshold=4; //3 results in degenerate quartile indices
    if((uint)energies.rows<iqr_count_threshold){ //ALWAYS not enough points to do statistics (need 3 quartiles)
      message << "Not enough degrees of freedom for outlier detection analysis per interquartile-range (count=" << energies.rows << " < " << iqr_count_threshold << ")";
      if(m_cflags.flag("FAKE_HULL")){aurostd::StringstreamClean(message);}  //don't want to see these errors, they are expected
      else if(m_cflags.flag("CHULL::STRICT_OUTLIER_ANALYSIS")&&(!m_cflags.flag("FORCE"))){
        message << " (results may not be reliable). Terminating hull analysis.";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message,_VALUE_RANGE_);
      } else {
        message << ", skipping outlier analysis.";pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
      }
      return;
    }

    if(LDEBUG) {xvector<double> temp_eng = energies; sort(temp_eng); cerr << "lastCoords(): " << temp_eng << endl;}
    double q1,q2,q3;
    //so we sort full anyway to be completely robust, should be easy considering how we sorted before
    aurostd::getQuartiles(energies,q1,q2,q3);  //we sort in here

    double lower_anchor,upper_anchor,range,multiplier;
    if(iqr_method){  //classical iqr measure of outlier
      lower_anchor=q1;
      upper_anchor=q3;
      range=q3-q1;      //interquartile range, iqr
      //multiplier=3.25;  //default=1.5, but we need to be more conservative from trials
    } else {  //absolute deviation around the median (MAD)
      lower_anchor=q2;
      upper_anchor=q2;
      range=aurostd::getMAD(energies,q2); //better iqr IF normal distribution, otherwise we need to know type of distribution (quartiles)
      //multiplier=3.25;                    //doi=10.1080/14640749108400962; 3 (very conservative), 2.5 (moderately conservative), 2 (poorly conservative)
    }
    multiplier=DEFAULT_CHULL_OUTLIER_MULTIPLIER;

    if(LDEBUG) {
      cerr << soliloquy << " lower_anchor=" << lower_anchor << ", median=" << q2 << ", upper_anchor=" << upper_anchor << ", range=" << range << endl;
    }

    upper_threshold=upper_anchor+(multiplier*range);
    lower_threshold=lower_anchor-(multiplier*range);
  }

  vector<uint> ConvexHull::calculateOutliers(const vector<uint>& points_to_consider) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    //it is very important that we do not define outliers using std/mean, as these are
    //very sensitive to outliers
    //instead, use median
    //see discussion here:  doi=10.1016/j.jesp.2013.03.013
    string soliloquy=XPID+"ConvexHull::calculateOutliers():";
    vector<uint> outliers;

    //bool keep_outliers=m_cflags.flag("CHULL::INCLUDE_OUTLIERS");
    bool show_warnings=true;

    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}

    //get vector of last coords (we want to find outliers in this dimension)
    vector<double> _energies;  //vector and not xvector because we need push_back()
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=points_to_consider.size();i<fl_size_i;i++){
      i_point=points_to_consider[i];
      if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
      _energies.push_back(m_points[i_point].getLastCoord());
    }

    double upper_threshold,lower_threshold;
    calculateOutlierThreshold(_energies,upper_threshold,lower_threshold);

    stringstream message;
    char LOGGER_TYPE=_LOGGER_OPTION_;
    if(show_warnings){LOGGER_TYPE=_LOGGER_WARNING_;}  //show warning if we do not remove!
    if(!(m_half_hull && !m_lower_hull)){  //look at lower range
      const double& threshold=lower_threshold;
      for(uint i=0,fl_size_i=points_to_consider.size();i<fl_size_i;i++){
        i_point=points_to_consider[i];
        if(m_points[i_point].getLastCoord()<threshold){
          outliers.push_back(i_point);
          message << "Identified (lower) outlier auid=" << m_points[i_point].m_entry.auid << ", ";
          message << "aurl=" << m_points[i_point].m_entry.aurl << ", ";
          message << "lastCoord()=" << m_points[i_point].getLastCoord() << " (<threshold=" << threshold << ")"; 
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, LOGGER_TYPE);
        }
      }
    }
    if(!(m_half_hull && m_lower_hull)){  //look at upper range
      const double& threshold=upper_threshold;
      for(uint i=0,fl_size_i=points_to_consider.size();i<fl_size_i;i++){
        i_point=points_to_consider[i];
        if(m_points[i_point].getLastCoord()>threshold){
          outliers.push_back(i_point);
          message << "Identified (upper) outlier auid=" << m_points[i_point].m_entry.auid << ", ";
          message << "aurl=" << m_points[i_point].m_entry.aurl << ", ";
          message << "lastCoord()=" << m_points[i_point].getLastCoord() << " (>threshold=" << threshold << ")"; 
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, LOGGER_TYPE);
        }
      }
    }
    //if we request outliers, lets get them, we can neglect them later
    //if(keep_outliers){
    //  message << "NOT removing outliers";
    //  pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
    //  outliers.clear();
    //}
    ////remove outliers
    //std::sort(outliers.rbegin(),outliers.rend()); //descending
    //for(uint i=0,fl_size_i=outliers.size();i<fl_size_i;i++){
    //  message << "Removing outlier auid=" << m_points[outliers[i]].m_entry.auid;
    //  pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
    //  m_points.erase(m_points.begin()+outliers[i]);
    //}
    if(LDEBUG) {cerr << soliloquy << " done" << endl;}
    return outliers;
  }

  vector<uint> ConvexHull::getOutliers() {
    string soliloquy=XPID+"ConvexHull::getOutliers():";
    vector<uint> points_to_consider;
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        points_to_consider.push_back(i_point);
      }
    }
    return calculateOutliers(points_to_consider);
  }

  vector<uint> ConvexHull::getOutliers(const xvector<int>& elements_present) {
    string soliloquy=XPID+"ConvexHull::getOutliers():";
    stringstream message;
    vector<uint> points_to_consider;
    uint i_point=AUROSTD_MAX_UINT;
    char LOGGER_TYPE=_LOGGER_OPTION_;
    bool silent=0;
    bool see_neglect=m_cflags.flag("CHULL::SEE_NEGLECT");

    if(m_half_hull){  //we only care about points above/below hull
      for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
        if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
        if(m_coord_groups[i_coord_group].getElementsPresent()!=elements_present){continue;}
        for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
          i_point=m_coord_groups[i_coord_group].m_points[i];
          if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
          if(m_points[i_point].isWithinHalfHull(m_lower_hull)){points_to_consider.push_back(i_point);} //!std::signbit(m_points[i_point].getLastCoord())) //positive
          else {
            silent=(!see_neglect && LOGGER_TYPE==_LOGGER_OPTION_);
            message << "Neglecting ";
            if(m_points[i_point].m_has_entry){message << "[auid=" << m_points[i_point].m_entry.auid << ",aurl=" << m_points[i_point].m_entry.aurl << "] ";}
            else {message << "[i_point=" << i_point << "] ";}
            message << "from outlier analysis: entry not within " << (m_lower_hull?"lower":"upper") << " half hull";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, LOGGER_TYPE, silent);
          }
        }
      }
    } else {
      for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
        if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
        if(m_coord_groups[i_coord_group].getElementsPresent()!=elements_present){continue;}
        for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
          i_point=m_coord_groups[i_coord_group].m_points[i];
          if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
          points_to_consider.push_back(i_point);
        }
      }
    }

    bool check_count=(m_half_hull&&sum(elements_present)==2);
    if(check_count){
      uint binaries_half_hull_threshold=DEFAULT_CHULL_OUTLIER_ANALYSIS_COUNT_THRESHOLD_BINARIES;
      if(points_to_consider.size()<binaries_half_hull_threshold){
        message << "Not enough degrees of freedom for outlier detection analysis per user defined threshold (count=" << points_to_consider.size() << " < " << binaries_half_hull_threshold << ")";
        if(m_cflags.flag("FAKE_HULL")){aurostd::StringstreamClean(message);}  //don't want to see these errors, they are expected
        else if(m_cflags.flag("CHULL::STRICT_OUTLIER_ANALYSIS")&&(!m_cflags.flag("FORCE"))){
          message << " (results may not be reliable). Terminating hull analysis.";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message,_VALUE_RANGE_);
        } else {
          message << ", skipping outlier analysis.";pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        }
        vector<uint> outliers;
        return outliers;
      }
    }

    return calculateOutliers(points_to_consider);
  }

  vector<uint> ConvexHull::findArtificialPoints(uint i_coord_group){
    string soliloquy=XPID+"ConvexHull::findArtificialPoints():";
    if(i_coord_group>m_coord_groups.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}

    uint i_point=AUROSTD_MAX_UINT;
    vector<uint> artificial_points;
    for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
      i_point=m_coord_groups[i_coord_group].m_points[i];
      if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
      if(m_points[i_point].m_is_artificial){artificial_points.push_back(i_point);}
    }

    return artificial_points;
  }

  uint ConvexHull::findArtificialUnary(uint i_coord_group){
    string soliloquy=XPID+"ConvexHull::findArtificialUnary():";
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No unaries to be found (coordinates are not stoichiometric)");}
    if(i_coord_group>m_coord_groups.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
    if(!m_coord_groups[i_coord_group].m_points.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] is empty");}
    if(!m_points[m_coord_groups[i_coord_group].m_points[0]].isUnary()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] is not unary");}

    vector<uint> artificial_points=findArtificialPoints(i_coord_group);
    if(artificial_points.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Missing artificial points");}
    if(artificial_points.size()!=1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Too many artificial points: "+aurostd::utype2string(artificial_points.size()));}

    return artificial_points[0];
  }

  void ConvexHull::organizeHullPoints(uint i_coord_group) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::organizeHullPoints():";
    if(i_coord_group>m_coord_groups.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}

    if(LDEBUG) {cerr << soliloquy << " finding min/max energy point(s) for coord_group[" << i_coord_group << "]" << endl;}

    m_coord_groups[i_coord_group].m_candidate_hull_points.clear();
    uint p_size=m_coord_groups[i_coord_group].m_points.size();
    if(p_size==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup has no points");}

    //the sole purpose of an artificial point is to sit on the hull, ignore all others
    uint i_point=AUROSTD_MAX_UINT;
    if(m_coord_groups[i_coord_group].m_has_artificial_unary){
      if(LDEBUG) {cerr << soliloquy << " looking for artificial point in coord_group[" << i_coord_group << "]" << endl;}
      i_point=findArtificialUnary(i_coord_group);
      if(LDEBUG) {
        cerr << soliloquy << " found artificial point in coord_group[" << i_coord_group << "]: ";
        cerr << "point[" << i_point << "]=" << m_points[i_point].m_coords << endl;
      }
      m_coord_groups[i_coord_group].m_candidate_hull_points.push_back(i_point);
      return;
    }

    if(m_half_hull){
      i_point=m_coord_groups[i_coord_group].m_points[0];        //lowest point for lower_hull, highest point for upper_hull
      if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
      if(m_lower_hull){
        if(lessEqualZero(m_points[i_point].getLastCoord())) //std::signbit(m_points[i_point].getLastCoord()))
        { //CO20200106 - patching for auto-indenting
          m_coord_groups[i_coord_group].m_candidate_hull_points.push_back(i_point);
          if(LDEBUG) {
            cerr << soliloquy << " lower half hull point found: ";
            cerr << "point[" << i_point << "]=" << m_points[i_point].m_coords << endl;
          }
        }
      } else {
        if(greaterEqualZero(m_points[i_point].getLastCoord()))  //!std::signbit(m_points[i_point].getLastCoord()))
        { //CO20200106 - patching for auto-indenting
          m_coord_groups[i_coord_group].m_candidate_hull_points.push_back(i_point);
          if(LDEBUG) {
            cerr << soliloquy << " upper half hull point found: ";
            cerr << "point[" << i_point << "]=" << m_points[i_point].m_coords << endl;
          }
        }
      }
      return; //below, we add other extreme in energy, which we don't care about for half hulls
    }

    i_point=m_coord_groups[i_coord_group].m_points[0];        //lowest energy point
    if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
    m_coord_groups[i_coord_group].m_candidate_hull_points.push_back(i_point);
    if(LDEBUG) {
      cerr << soliloquy << " hull point found: ";
      cerr << "point[" << i_point << "]=" << m_points[i_point].m_coords << endl;
    }
    if(p_size>1){ //also grab other extreme
      i_point=m_coord_groups[i_coord_group].m_points[p_size-1];
      if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
      m_coord_groups[i_coord_group].m_candidate_hull_points.push_back(i_point);
      if(LDEBUG) {
        cerr << soliloquy << " hull point found: ";
        cerr << "point[" << i_point << "]=" << m_points[i_point].m_coords << endl;
      }
    }
  }

  void ConvexHull::organizeHullPoints() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::organizeHullPoints():";
    if(!m_coord_groups.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Points have not been structured correctly");}
    if(LDEBUG) {
      cerr << soliloquy << " filtering points definitely NOT on the hull by energy" << endl;
      cerr << soliloquy << " only looking for min/max energy points in all coord_groups" << endl;
    }
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){organizeHullPoints(i_coord_group);}
  }

  void ConvexHull::initializeNaries() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::initializeNaries():";
    stringstream message;
    //clear
    for(uint i_nary=0,fl_size_i_nary=m_naries.size();i_nary<fl_size_i_nary;i_nary++){
      for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
        m_naries[i_nary].m_alloys[i_alloy].clear();
      }
      m_naries[i_nary].clear();
    }
    m_naries.clear();

    //initialize with combinations of dim
    Nary nary;
    Alloy alloy;
    aurostd::xcombos xc;
    xvector<int> elements_present;
    for(uint i_nary=0;i_nary<m_dim;i_nary++){
      nary.initialize(i_nary+1);
      m_naries.push_back(nary);
      xc.reset(m_dim,i_nary+1,'C');
      while(xc.increment()){
        elements_present=aurostd::vector2xvector<int>(xc.getCombo());
        alloy.initialize(elements_present);
        m_naries[i_nary].m_alloys.push_back(alloy);
      }
    }
    if(m_naries.size()==0){message << "m_naries.size()=0, xcombos may be broken";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
    if(!m_naries[0].m_alloys.size()){message << "m_naries[0].m_alloys.size()==0, xcombos may be broken";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
    //SORT NOW! do not sort later as we populate m_points with i_nary and i_alloy
    for(uint i_nary=0,fl_size_i_nary=m_naries.size();i_nary<fl_size_i_nary;i_nary++){
      std::sort(m_naries[i_nary].m_alloys.rbegin(),m_naries[i_nary].m_alloys.rend()); //descending order
    }
    std::sort(m_naries.begin(),m_naries.end());
    if(LDEBUG) {cerr << soliloquy << " m_naries.size()=" << m_naries.size() << endl;}
  }

  void ConvexHull::structurePoints() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::structurePoints():";
    stringstream message;
    m_coord_groups.clear();
    m_naries.clear();

    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}

    //NOTE, m_points is UNTOUCHED (unsorted, fully populated) input, i.e., identical input of user
    //HOWEVER, m_coord_groups[].m_points only contain indices to points that we will consider for the hull calculation, i.e., does not contain
    //any points to be neglected (requested or otherwise)
    //if you want input of the user, use m_points
    //if you want points for the hull, go through m_coord_groups
    if(LDEBUG) {cerr << soliloquy << " gathering points to neglect" << endl;}

    bool fhsc_requested=m_cflags.flag("CHULL::CALCULATE_FAKE_HULL_STABILITY_CRITERION"); //CO20210315
    bool perform_structure_comparison=(1&&(!m_cflags.flag("CHULL::SKIP_STRUCTURE_COMPARISON"))); //(1&&!(m_cflags.flag("CHULL::SKIP_STRUCTURE_COMPARISON")||(!m_cflags.flag("CHULL::MULTI_OUTPUT")&&m_cflags.flag("CHULL::LATEX_DOC")&&m_cflags.flag("CHULL::IMAGE_ONLY"))));
    uint i_point_sc=AUROSTD_MAX_UINT;
    xvector<double> r_coords_sc_input;
    string auid_sc=m_cflags.getattachedscheme("CHULL::CALCULATE_FAKE_HULL_STABILITY_CRITERION");
    if(auid_sc.empty()){fhsc_requested=false;}
    if(fhsc_requested){
      for(uint i=0,fl_size_i=m_points.size();i<fl_size_i&&i_point_sc==AUROSTD_MAX_UINT;i++){
        const ChullPoint& point=m_points[i];
        const aflowlib::_aflowlib_entry& entry=m_points[i].m_entry;
        if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
        // start remove points
        if(m_points[i].m_has_entry && entry.auid==auid_sc){
          i_point_sc=i;
          r_coords_sc_input=point.getStoichiometricCoords();
        }
      }
    }
    if(i_point_sc==AUROSTD_MAX_UINT){fhsc_requested=false;}

    bool remove_requested=m_cflags.flag("CHULL::NEGLECT");
    bool see_neglect=m_cflags.flag("CHULL::SEE_NEGLECT");
    bool remove_submodular=true;  //remove AEL-AGL, APL, etc.
    bool fhn1eg_requested=m_cflags.flag("CHULL::CALCULATE_FAKE_HULL_N+1_ENTHALPY_GAIN"); //SK20200327
    bool remove_invalid=true;
    bool remove_duplicate_entries=true;        //we remove duplicate entries from the database, but in general, keep input of user constant
    bool remove_extreme=m_cflags.flag("CHULL::REMOVE_EXTREMA");
    bool perform_outliers_analysis=DEFAULT_CHULL_PERFORM_OUTLIER_ANALYSIS;
    bool keep_outliers=(!perform_outliers_analysis || m_cflags.flag("CHULL::INCLUDE_OUTLIERS"));
    bool remove_outliers=!keep_outliers;
    if(LDEBUG) {cerr << soliloquy << " remove_outliers=" << remove_outliers << endl;}

    vector<string> points_neglect;
    double extrema_val = 0.0;
    if(remove_requested){aurostd::string2tokens(m_cflags.getattachedscheme("CHULL::NEGLECT"),points_neglect,",");}
    if(points_neglect.size()==0){remove_requested=false;}
    if(remove_extreme){
      extrema_val=aurostd::string2utype<double>(m_cflags.getattachedscheme("CHULL::REMOVE_EXTREMA"));
      if(m_formation_energy_hull){
        if(greaterEqualZero(extrema_val)){
          message << "Ignoring remove extreme points flag -- you provided a number >= 0. H_f convex hull sits below 0";
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
          remove_extreme=false;
        }
      } else {
        if(lessEqualZero(extrema_val)){
          message << "Ignoring remove extreme points flag -- you provided a number <= 0. T_S convex hull sits above 0";
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
          remove_extreme=false;
        }
      }
    }

    vector<string> removing_messages;
    if(remove_requested){removing_messages.push_back("undesired");}
    if(remove_invalid){removing_messages.push_back("erroneous");}
    if(remove_duplicate_entries){removing_messages.push_back("duplicate");}
    if(remove_extreme){removing_messages.push_back("extreme");}
    if(remove_outliers){removing_messages.push_back("outlier");}
    if(fhn1eg_requested){removing_messages.push_back(aurostd::utype2string(m_velements.size())+"D (N+1 enthalpy gain)");}  //SK20200327
    if(fhsc_requested){removing_messages.push_back("auid="+auid_sc+" and equivalent (stability criterion)");}  //SK20200327
    if(removing_messages.size()){
      message << "Filtering out " << aurostd::joinWDelimiter(removing_messages,"/") << " entries";
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
    }

    //quick add in of PAW_GGA if not already included in allowed list
    if(m_cflags.flag("CHULL::INCLUDE_PAW_GGA")&&(!aurostd::WithinList(m_allowed_dft_types,"PAW_GGA"))){m_allowed_dft_types.push_back("PAW_GGA");}

    //ignore bad database
    bool ignore_bad_database=(DEFAULT_CHULL_IGNORE_KNOWN_ILL_CONVERGED && !m_cflags.flag("CHULL::INCLUDE_ILL_CONVERGED"));
    if(LDEBUG) {cerr << soliloquy << " ignore_bad_database=" << ignore_bad_database << endl;}

    //organize into coordgroups
    if(LDEBUG) {cerr << soliloquy << " organizing into coordgroups" << endl;}
    vector<uint> unique_entries;
    string invalid_reason,canonical_auid;
    char LOGGER_TYPE=_LOGGER_OPTION_;
    bool silent=false;
    uint i_coord_group_sort;  //so it doesn't conflict with i_coord_group in for-loops
    CoordGroup cg;
    xvector<double> r_coords;
    for(uint i=0,fl_size_i=m_points.size();i<fl_size_i;i++){
      const ChullPoint& point=m_points[i];
      const aflowlib::_aflowlib_entry& entry=m_points[i].m_entry;
      if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
      // start remove points
      if(m_points[i].m_has_entry){
        if(remove_invalid && !entryValid(entry,invalid_reason,LOGGER_TYPE,ignore_bad_database)){
          if(!invalid_reason.empty()){
            silent=(!see_neglect && LOGGER_TYPE==_LOGGER_OPTION_);
            message << "Neglecting [auid=" << entry.auid << ",aurl=" << entry.aurl << "]: " << invalid_reason;
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, LOGGER_TYPE, silent);
          }
          continue;
        }
        if(remove_submodular){
          if(entry.aurl.find("ARUN.AEL_")!=string::npos ||
              entry.aurl.find("ARUN.AGL_")!=string::npos ||
              entry.aurl.find("ARUN.APL_")!=string::npos ||
              entry.aurl.find("ARUN.QHA_")!=string::npos ||
              FALSE){
            silent=true;  //no need to see
            message << "Neglecting [auid=" << entry.auid << ",aurl=" << entry.aurl << "]: sub-module load";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, LOGGER_TYPE, silent);
            continue;
          }
        }
        if(remove_duplicate_entries && !entryUnique(unique_entries,entry,canonical_auid)){
          silent=(!see_neglect);
          message << "Neglecting [auid=" << entry.auid << ",aurl=" << entry.aurl << "]: duplicate database entry (see " << canonical_auid << ")";
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_, silent);
          continue;
        }
        unique_entries.push_back(i);
        if(aurostd::WithinList(points_neglect,entry.auid)){
          message << "Neglecting [auid=" << entry.auid << ",aurl=" << entry.aurl << "]: as requested";
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
          continue;
        }
        if(fhn1eg_requested) {  //SK20200330
          if(point.getDim()==(point.m_i_nary+1)) {
            message << "Neglecting [auid=" << entry.auid << ",aurl=" << entry.aurl << "] to calculate N+1 enthalpy gain";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
            continue;
          }
        }
        if(fhsc_requested){ //CO20210315
          if(coordsIdentical(r_coords_sc_input,point.getStoichiometricCoords()) && phasesEquivalent(i_point_sc,i,perform_structure_comparison)){
            message << "Neglecting [auid=" << entry.auid << ",aurl=" << entry.aurl << "] to calculate stability criterion hull";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
            continue;
          }
        }
        if(remove_extreme){
          if(m_formation_energy_hull){
            if(chull::H_f_atom(entry, _m_) < extrema_val){
              message << "Neglecting [auid=" << entry.auid << ",aurl=" << entry.aurl << "]: flagged as extreme with H_f = " << chull::H_f_atom(entry, _m_) << " (meV/atom)";
              pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
              continue;
            }
          } else {
            if(chull::T_S(entry) > extrema_val){
              message << "Neglecting [auid=" << entry.auid << ",aurl=" << entry.aurl << "]: flagged as extreme with T_S = " << chull::T_S(entry) << " (K)";
              pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
              continue;
            }
          }
        }
      }
      //// end remove points
      //organize into m_naries
      //perhaps think about organizing by c_coords instead in the future (int compare vs. double compare), would be more exact
      //this would require adding a priority check for composition, and falling back to stoichiometry if composition is not available (artificial)
      //not really a priority, we don't explore compositions that are so close (to within 1e-8)
      //comparison of stoichiometry is more general, but less reliable than composition (to within tol)
      //nevermind, vcomposition is a double anyway (in anticipation for POCC), so floating point comparisons are inevitable
      r_coords=point.getStoichiometricCoords();
      if(LDEBUG) {cerr << soliloquy << " point[" << i << "]: m_coords=" << point.m_coords << ", r_coords=" << r_coords << ", compound=\"" << point.m_entry.compound << "\", dim=" << point.m_i_nary+1 << endl;}
      if(!getCoordGroupIndex(r_coords,i_coord_group_sort)){
        cg.initialize(r_coords,point.m_has_stoich_coords);
        m_coord_groups.push_back(cg);
        i_coord_group_sort=m_coord_groups.size()-1;
      }
      m_coord_groups[i_coord_group_sort].m_points.push_back(i);
      if(m_coord_groups[i_coord_group_sort].m_has_stoich_coords && !point.m_has_stoich_coords){
        message << "Mismatch among coord types (stoich vs. non-stoich coords), assuming non-stoich coords";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        m_coord_groups[i_coord_group_sort].m_has_stoich_coords=false;
      }
      if(point.isUnary()&&point.m_is_artificial){m_coord_groups[i_coord_group_sort].m_has_artificial_unary=true;}
    }

    //remove outliers before sort (BY MATCHING COORDS)
    //we do this analysis EVEN if we keep outliers in the end, simply print out useful warnings for user
    uint i_point=AUROSTD_MAX_UINT;
    vector<uint> outliers;

    if(perform_outliers_analysis){
      if(m_has_stoich_coords){
        //proceed through each set of binaries, find all sets of outliers and append together
        xvector<int> elements_present;
        vector<uint> _outliers;
        aurostd::xcombos xc(m_dim,2,'C'); //binaries ONLY for now
        while(xc.increment()){
          elements_present=aurostd::vector2xvector<int>(xc.getCombo());
          _outliers=getOutliers(elements_present);
          outliers.insert(outliers.end(),_outliers.begin(),_outliers.end());
        }
      } else {outliers=getOutliers();}
    }

    if(keep_outliers){
      message << "NOT removing outliers";
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
      outliers.clear();
    }

    bool found_outlier=false;
    vector<uint> points_to_remove;
    uint valid_count=0;
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      points_to_remove.clear();
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        found_outlier=false;
        for(uint j=0,fl_size_j=outliers.size();j<fl_size_j&&!found_outlier;j++){if(i_point==outliers[j]){found_outlier=true;}}
        if(found_outlier){points_to_remove.push_back(i);} //not i_point, so I can remove this index
        else {if(!m_points[i_point].m_is_artificial){valid_count++;}}
      }
      if(points_to_remove.size()){
        std::sort(points_to_remove.rbegin(),points_to_remove.rend()); //descending
        if(LDEBUG) {cerr << soliloquy << " before outlier removal, count = " << m_coord_groups[i_coord_group].m_points.size() << endl;}
        for(uint i=0,fl_size_i=points_to_remove.size();i<fl_size_i;i++){
          i_point=m_coord_groups[i_coord_group].m_points[points_to_remove[i]];
          if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
          message << "Removing outlier ";
          if(m_points[i_point].m_has_entry){message << "auid=" << m_points[i_point].m_entry.auid;}
          else {message << "m_coords=" << m_points[i_point].m_coords;}
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_OPTION_);
          m_coord_groups[i_coord_group].m_points.erase(m_coord_groups[i_coord_group].m_points.begin()+points_to_remove[i]);
        }
        if(LDEBUG) {cerr << soliloquy << " after outlier removal, m_coord_groups[" << i_coord_group << "].m_points.size() = " << m_coord_groups[i_coord_group].m_points.size() << endl;}
      }
    }
    message << "Employing " << valid_count << " total entries for " << pflow::arity_string(m_dim,false,false) << " convex hull analysis";
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

    //remove empty m_coord_groups
    vector<uint> empty_coord_groups;
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      if(m_coord_groups[i_coord_group].m_points.size()==0){empty_coord_groups.push_back(i_coord_group);}
    }
    std::sort(empty_coord_groups.rbegin(),empty_coord_groups.rend()); //descending
    for(uint i=0,fl_size_i=empty_coord_groups.size();i<fl_size_i;i++){m_coord_groups.erase(m_coord_groups.begin()+empty_coord_groups[i]);}

    //sort
    m_sort_energy_ascending=!(m_half_hull==true && m_lower_hull==false); //upper half hull should sort DESCENDING (ground-state first)
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      std::sort(m_coord_groups[i_coord_group].m_points.begin(),m_coord_groups[i_coord_group].m_points.end(),sortWithinCoordGroup(m_points,m_sort_energy_ascending));  //ascending order
    }
    std::sort(m_coord_groups.rbegin(),m_coord_groups.rend()); //descending order for alphabetic print out later

    //assign coord group indices to points, useful later
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      //set ref state
      if(m_coord_groups[i_coord_group].m_points.size()){
        m_coord_groups[i_coord_group].m_ref_state=artificialMap(m_coord_groups[i_coord_group].m_points[0]);
      }
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        m_points[i_point].m_i_coord_group=i_coord_group;
      }
    }
    if(LDEBUG) {cerr << soliloquy << " done organizing into coordgroups" << endl;}

    organizeHullPoints();

    if(LDEBUG) {
      cerr << soliloquy << " coord_groups structure:" << endl;
      for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
        cerr << soliloquy << " coord_group[" << i_coord_group << "] coords=" << m_coord_groups[i_coord_group].m_coords << endl;
        for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
          cerr << soliloquy << " point[" << i << "] compound=" << m_points[m_coord_groups[i_coord_group].m_points[i]].m_entry.compound << " ";
          cerr << "coords=" << m_points[m_coord_groups[i_coord_group].m_points[i]].m_coords << " ";
          cerr << "has_stoich_coords=" << m_points[m_coord_groups[i_coord_group].m_points[i]].m_has_stoich_coords << " ";
          cerr << "formation_energy_coord=" << m_points[m_coord_groups[i_coord_group].m_points[i]].m_formation_energy_coord << endl;
        }
      }
    }

    if(m_has_stoich_coords){
      if(LDEBUG) {cerr << soliloquy << " stoich_coords found, also sorting into n-aries and alloys" << endl;}
      message << "Stoichiometric coordinates detected, structuring entries by arity";
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

      initializeNaries(); //create empty bins first, we can do this combinatorially

      if(LDEBUG){cerr << soliloquy << " m_coord_groups.size()=" << m_coord_groups.size() << endl;}

      uint i_nary,i_alloy;
      for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
        if(LDEBUG){cerr << soliloquy << " m_coord_groups[i_coord_group=" << i_coord_group << "].m_points.size()=" << m_coord_groups[i_coord_group].m_points.size() << endl;}
        if(!m_coord_groups[i_coord_group].m_points.size()){continue;}
        //we already filled bins, if we cannot find alloy system, then it's a bust
        if(!getAlloyIndex(m_coord_groups[i_coord_group],i_nary,i_alloy,true)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Cannot get alloys index");}  //redo as we never done before
        m_coord_groups[i_coord_group].m_i_nary=i_nary;
        m_coord_groups[i_coord_group].m_i_alloy=i_alloy;
        m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.push_back(i_coord_group);
        //set i_nary and i_alloy to points too
        for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
          i_point=m_coord_groups[i_coord_group].m_points[i];
          if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
          m_points[i_point].m_i_nary=i_nary;
          m_points[i_point].m_i_alloy=i_alloy;
        }
      }

      bool only_within_half_hull=false; //m_half_hull; //these counts should reflect total entries
      vector<vector<uint> > hull_sizes=getHullSizes(only_within_half_hull);
      if(only_within_half_hull){
        message << "Half hull detected, reducing entry count to those within the relevant hemisphere";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
      }
      for(uint i_nary=0,fl_size_i_nary=m_naries.size();i_nary<fl_size_i_nary;i_nary++){
        for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
          message << "Entries structure: employing " << getEntriesCount(i_nary,i_alloy,only_within_half_hull);
          if(m_velements.size()){message << " " << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"-");}
          message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
          message << " entries, ";
          message << hull_sizes[i_nary][i_alloy] << " entries total for ";
          message << pflow::arity_string(i_nary+1,false,false) << " convex hull analysis";
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
        }
      }

      if(LDEBUG) {
        for(uint i_nary=0,fl_size_i_nary=m_naries.size();i_nary<fl_size_i_nary;i_nary++){
          cerr << soliloquy << " " << pflow::arity_string(i_nary+1,false,false) << ":" << endl;
          for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
            cerr << soliloquy << " alloy[" << i_alloy << "]: elements_present=" << m_naries[i_nary].m_alloys[i_alloy].m_elements_present << endl;
            for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i<fl_size_i;i++){
              i_coord_group_sort=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
              cerr << soliloquy << " coord_group[" << i_coord_group_sort << "]=" << m_coord_groups[i_coord_group_sort].m_coords << endl;
              for(uint j=0,fl_size_j=m_coord_groups[i_coord_group_sort].m_points.size();j<fl_size_j;j++){
                cerr << soliloquy << " compound=";
                cerr << (m_points[m_coord_groups[i_coord_group_sort].m_points[j]].m_is_artificial ? 
                    string("ARTIFICIAL") : 
                    m_points[m_coord_groups[i_coord_group_sort].m_points[j]].m_entry.compound) << " ";
                cerr << "coords=" << m_points[m_coord_groups[i_coord_group_sort].m_points[j]].m_coords << endl;
              }
            }
          }
        }
      }
    }
    if(LDEBUG) {cerr << soliloquy << " done" << endl;}
  }

  vector<string> ConvexHull::alloyToElements(const ChullPoint& point) const {return alloyToElements(point.m_i_nary,point.m_i_alloy);}
  vector<string> ConvexHull::alloyToElements(uint i_nary,uint i_alloy) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::alloyToElements():";
    if(LDEBUG){cerr << soliloquy << " BEGIN" << endl;}
    const xvector<int>& elements_present=getElementsPresent(i_nary,i_alloy);
    if((uint)elements_present.rows!=m_velements.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between elements present and composition");}
    vector<string> vout;
    for(int i=elements_present.lrows;i<=elements_present.urows;i++){
      if(elements_present[i]==1){vout.push_back(m_velements[i-elements_present.lrows]);}
    }
    return vout;
  }

  void ConvexHull::checkStructurePoints() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::checkStructurePoints():";
    stringstream message;

    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}

    bool binary_statistics_check=m_naries.size()>1; //unary hull //true;

    if(m_has_stoich_coords){
      //UNARIES - START
      //tests of stupidity
      if(m_naries.size()!=m_dim){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Missing n-aries");} //these are populated by default if done correctly
      uint i_nary=0;
      if(m_naries[i_nary].m_alloys.size()!=m_dim){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Missing unary alloys");} //these are populated by default if done correctly

      //check for ground-states (non-artificial points)
      bool found_real = false, found_artificial = false;
      uint i_coord_group = 0,i_point = 0,i_point_real = 0;
      for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
        if(m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size()!=1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unexpected count of coordgroups for unaries, should only be 1");}
        found_real=found_artificial=false;
        i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[0];
        for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i&&!(found_real&&found_artificial);i++){
          i_point=m_coord_groups[i_coord_group].m_points[i];
          if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
          if(m_points[i_point].m_is_artificial){found_artificial=true;}
          else {
            if(!found_real){i_point_real=i_point;}  //grab first i_point that's real
            found_real=true;
          }
        }
        if(m_add_artificial_unaries&&!found_artificial){
          message << "Missing artificial points for";
          if(i_alloy<m_velements.size()){message << " " << m_velements[i_alloy];}
          message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
          throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message.str()); message.str("");
        }
        if(found_real){
          if(m_thermo_hull){
            if(abs(m_points[i_point_real].getLastCoord())>=ENERGY_TOL){
              message << "Very skewed ground-state end point for";
              if(i_alloy<m_velements.size()){message << " " << m_velements[i_alloy];}
              message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
              message << " (auid=" << m_points[i_point_real].m_entry.auid << ")";
              message << ": abs(" << m_points[i_point_real].getLastCoord() << ")>=" << ENERGY_TOL << " [eV]";
              message << " (please report on AFLOW Forum: aflow.org/forum)";
              if(m_cflags.flag("FAKE_HULL")){aurostd::StringstreamClean(message);}  //don't want to see these errors, they are expected
              else if(m_cflags.flag("FORCE")||m_cflags.flag("CHULL::INCLUDE_SKEWED_HULLS")){pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);}
              else {
                message << ". Override with --force (results may not be reliable).";
                throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);
              }
            }
          }
        } else {
          if(!m_cflags.flag("FAKE_HULL")){
            message << "No ground-state available for";
            if(i_alloy<m_velements.size()){message << " " << m_velements[i_alloy];}
            message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
            pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
          }
        }
      }
      //UNARIES - STOP

      //BINARIES - START
      uint count_threshold_binaries_total=DEFAULT_CHULL_OUTLIER_ANALYSIS_COUNT_THRESHOLD_BINARIES;
      if(binary_statistics_check){
        i_nary=1;
        uint count;
        for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
          count=getEntriesCount(i_nary,i_alloy,false);  //check total first
          if(count<count_threshold_binaries_total){
            stringstream hull;
            //safe in case m_velements was not set
            if(m_velements.size()){hull << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"-") << " ";}
            hull << "[i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
            message << pflow::arity_string(i_nary+1,true,false) <<  " hull " << hull.str() << " is unreliable (total_entry_count=" << count << " < " << count_threshold_binaries_total << ")";
            if(m_cflags.flag("FAKE_HULL")){aurostd::StringstreamClean(message);}  //don't want to see these errors, they are expected
            else if(m_cflags.flag("FORCE")||m_cflags.flag("CHULL::INCLUDE_UNRELIABLE_HULLS")){pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);}
            else {
              message << ". Override with --force (results may not be reliable).";
              throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);
            }
          }
        }
      }
      //BINARIES - STOP
    }
    if(LDEBUG) {cerr << soliloquy << " done" << endl;}
  }

  void ConvexHull::addPointToFacet(ChullFacet& facet,uint i_point) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::addPointToFacet():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    facet.addVertex(m_points[i_point],i_point);
    if(LDEBUG) {
      cerr << soliloquy << " facet.m_vertices.size()=" << facet.m_vertices.size() << endl;
      for(uint i=0,fl_size_i=facet.m_vertices.size();i<fl_size_i;i++){
        cerr << facet.m_vertices[i].ch_index << "  h_coords=" << facet.m_vertices[i].ch_point.h_coords << endl;
      }
    }
  }

  void ConvexHull::initializeFacet(ChullFacet& facet,bool check_validity) {facet.initialize(h_reference,h_dim,check_validity);}

  uint ConvexHull::getExtremePoint(uint dim) {
    vector<FacetPoint> points_to_avoid;
    return getExtremePoint(dim,points_to_avoid);
  }

  uint ConvexHull::getExtremePoint(uint dim,const vector<FacetPoint>& points_to_avoid) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getExtremePoint():";
    stringstream message;
    if(!h_points.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No starting points provided");}
    uint i_point=AUROSTD_MAX_UINT;
    double extreme=-1.0;  //since it's the abs() we check below, -1 is FINE
    bool avoid=false;
    if(LDEBUG) {
      cerr << soliloquy << " h_points:" << endl;
      for(uint i=0,fl_size_i=h_points.size();i<fl_size_i;i++){
        cerr << h_points[i] << "  h_coords=" << m_points[h_points[i]].h_coords << endl;
      }
      cerr << soliloquy << " points_to_avoid:" << endl;
      for(uint j=0,fl_size_j=points_to_avoid.size();j<fl_size_j;j++){
        cerr << points_to_avoid[j].ch_index << "  h_coords=" << m_points[points_to_avoid[j].ch_index].h_coords << endl;
      }
    }
    //HE20220412 START
    //collect directions already spanned by `points_to_avoid`
    vector<xvector<double>> directions;
    for (size_t avoid_i=1; avoid_i<points_to_avoid.size(); avoid_i++){
      // using the first extreme point as our starting point for all directions
      directions.push_back(m_points[points_to_avoid[avoid_i].ch_index].h_coords - m_points[points_to_avoid[0].ch_index].h_coords);
    }
    //HE20220412 END
    int h_coords_index=0;
    xvector<double> new_direction;
    for(uint i=0,fl_size_i=h_points.size();i<fl_size_i;i++){
      h_coords_index=(int)dim+m_points[h_points[i]].h_coords.lrows;
      if(h_coords_index>m_points[h_points[i]].h_coords.urows){
        throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid coordinate index");
      }
      avoid=false;
      for(uint j=0,fl_size_j=points_to_avoid.size();j<fl_size_j&&!avoid;j++){
        if(h_points[i]==points_to_avoid[j].ch_index){
          avoid=true;
          break;
        }
      } //HE20220412 added break to end loop when point is found
      if(avoid){continue;}
      //ensure that considered points add a new dimension to the initial facet (not collinear)
      //without this check, the first facet may not be spanning a dim-1 space
      //resulting in a wrong normal vector that trips up the search algorithm for the next point to add
      //which can lead to an endless loop in ConvexHull::calculateFacets()
      //this check became necessary as the creation of atomic environments uses ConvexHull to create hulls from arbitrary points
      //HE20220412 START
      if (!directions.empty()) {
        new_direction = m_points[h_points[i]].h_coords - m_points[points_to_avoid[0].ch_index].h_coords;
        for (vector<xvector<double>>::const_iterator direction = directions.begin(); direction != directions.end(); direction++) {
          if (aurostd::isCollinear(*direction, new_direction, ZERO_TOL))  {
            avoid=true;
            break;
          }
        }
        if(avoid){continue;}
      }
      //HE20220412 END
      if(abs(m_points[h_points[i]].h_coords[h_coords_index])>extreme){
        i_point=h_points[i];
        extreme=abs(m_points[h_points[i]].h_coords[h_coords_index]);
      }
    }
    if(i_point==AUROSTD_MAX_UINT){
      message << "No point found, points_to_avoid is too restrictive (points_to_avoid.size()==" << points_to_avoid.size() << ")";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message.str()); message.str("");
    }
    if(LDEBUG) {cerr << soliloquy << " i_point=" << i_point << endl;}
    return i_point;
  }

  void ConvexHull::setCentroid() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setCentroid():";
    vector<xvector<double> > points;
    for(uint i=0,fl_size_i=h_points.size();i<fl_size_i;i++){points.push_back(m_points[h_points[i]].h_coords);}
    h_centroid=h_reference=aurostd::getCentroid(points);  //fix h_reference later
    //if(1){
    //  //h_centroid[0]=0.5;h_centroid[1]=0.5;h_centroid[2]=-0.01;
    //  for(int i=h_centroid.lrows;i<=h_centroid.urows-1;i++){h_centroid[i]=0.5;}
    //  h_centroid[h_centroid.urows]=-0.01;
    //}
    if(LDEBUG) {cerr << soliloquy << " centroid: " << h_centroid << endl;}
  }

  vector<FacetPoint> ConvexHull::getInitialExtremePoints() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getInitialExtremePoints():";
    if(LDEBUG) {cerr << soliloquy << " start" << endl;}
    ChullFacet facet(*p_FileMESSAGE,*p_oss);  //CO20180305
    string error;
    //get first h_dim points from just the extremes, and plug into facet
    //BAD CASE: fewer than h_dim points, this is NOT hull-able
    if(h_points.size()<h_dim){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Not enough points to build an initial facet");}
    for(uint i=0;i<h_dim;i++){addPointToFacet(facet,getExtremePoint(i,facet.m_vertices));}
    if(!facet.isValid(error)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"An initial facet cannot be created per initial extreme points, invalid points input: "+error);}
    initializeFacet(facet,false); //already validated
    //now get furthest point from this facet, initialize outside set first
    FacetPoint f_point;
    for(uint i=0,fl_size_i=h_points.size();i<fl_size_i;i++){
      if(facet.isPointOnFacet(h_points[i])){continue;}
      f_point.initialize(m_points[h_points[i]],h_points[i]);
      facet.f_outside_set.push_back(f_point);
      if(LDEBUG) {cerr << soliloquy << " adding to facet[" << 0 << "] outside set: " << h_points[i] << endl;}
    }
    if(facet.f_outside_set.size()){ //in special case where there are only 2 points in 2D, we simply return facet and not simplex
      facet.setFurthestPoint();
      facet.addVertex(facet.f_furthest_point); //already have a vector<uint> in m_points, simply append and return
    }
    if(LDEBUG) {
      cerr << soliloquy << " building initial simplex with extreme points:" << endl;
      for(uint i=0,fl_size_i=facet.m_vertices.size();i<fl_size_i;i++){
        cerr << facet.m_vertices[i].ch_point.h_coords << endl;
      }
    }
    return facet.m_vertices;
  }

  void ConvexHull::setNeighbors() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setNeighbors():";

    //print ridges so far
    if(LDEBUG) {
      vector<uint> indices;
      for(uint i=0,fl_size_i=h_facets.size();i<fl_size_i;i++){
        indices=h_facets[i].getCHIndices();
        cerr << soliloquy << " facet[" << i << "] has indices: ";
        for(uint j=0,fl_size_j=indices.size();j<fl_size_j;j++){
          cerr << indices[j];
          if(j!=indices.size()-1){cerr << ",";}
        }
        cerr << endl;
      }
    }

    for(uint i_facet=0,fl_size_i_facet=h_facets.size();i_facet<fl_size_i_facet;i_facet++){h_facets[i_facet].f_neighbors.clear();}
    for(uint i=0,fl_size_i=h_facets.size();i<fl_size_i;i++){
      for(uint j=i+1,fl_size_j=h_facets.size();j<fl_size_j;j++){
        if(h_facets[i].shareRidge(h_facets[j])){
          h_facets[i].f_neighbors.push_back(j);
          h_facets[j].f_neighbors.push_back(i);
        }
      }
      //can only perform this check if we have more than one h_facet, otherwise NO neighbors
      if(h_facets.size()>1&&h_facets[i].f_neighbors.size()!=h_dim){
        stringstream message;
        if(LDEBUG) {
          cerr << soliloquy << " neighbors for facet[i_facet=" << i << ",coords=";
          for(uint j=0,fl_size_j=h_facets[i].m_vertices.size();j<fl_size_j;j++){cerr << h_facets[i].m_vertices[j].ch_point.h_coords << (j!=h_facets[i].m_vertices.size()-1?", ":"");}
          cerr << "]: ";
          for(uint j=0,fl_size_j=h_facets[i].f_neighbors.size();j<fl_size_j;j++){
            cerr << h_facets[i].f_neighbors[j] << " ";
          }
          cerr << endl;
          cerr << soliloquy << " is_vertical=" << h_facets[i].m_is_vertical << endl;
        }
        message << "Neighbor count (" << h_facets[i].f_neighbors.size() << ") and facet dimension (" << h_dim << ") mismatch";
        if(0&&m_cflags.flag("FORCE")){pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);}  //h_facets[i].m_is_vertical
        else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      }
    }
    for(uint i=0,fl_size_i=h_facets.size();i<fl_size_i;i++){std::sort(h_facets[i].f_neighbors.begin(),h_facets[i].f_neighbors.end());}

    if(LDEBUG) {
      for(uint i=0,fl_size_i=h_facets.size();i<fl_size_i;i++){
        cerr << soliloquy << " neighbors for facet[i_facet=" << i << ",coords=";
        for(uint j=0,fl_size_j=h_facets[i].m_vertices.size();j<fl_size_j;j++){cerr << h_facets[i].m_vertices[j].ch_point.h_coords << (j!=h_facets[i].m_vertices.size()-1?", ":"");}
        cerr << "]: ";
        for(uint j=0,fl_size_j=h_facets[i].f_neighbors.size();j<fl_size_j;j++){
          cerr << h_facets[i].f_neighbors[j] << " ";
        }
        cerr << endl;
      }
    }
  }

  void ConvexHull::createInitializeSimplex() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::createInitializeSimplex():";
    //clear
    h_facets.clear();
    setCentroid();

    vector<FacetPoint> initial_extreme_points=getInitialExtremePoints();
    //fix h_reference now!
    //NOTE: originally we used the hull centroid to determine alignment of facet normals
    //however, this does not work in the case of 3D hulls with no 3D points (only 2D hull points)
    //instead, we align with the centroid of the initial_extreme_points, as this point SHOULD be guaranteed to be in the hull
    //the hull only gets bigger by accepting more points
    //so we set h_reference first to h_centroid, since we don't care about the alignment of the normal inside getInitialExtremePoints()
    //then we fix here and keep for all facets
    vector<xvector<double> > points;
    for(uint i=0,fl_size_i=initial_extreme_points.size();i<fl_size_i;i++){points.push_back(initial_extreme_points[i].ch_point.h_coords);}
    h_reference=aurostd::getCentroid(points);
    if(LDEBUG) {cerr << soliloquy << " new h_reference=" << h_reference << endl;}

    //new first facet of endpoints

    if(initial_extreme_points.size()==h_dim+1){if(LDEBUG) {cerr << soliloquy << " building initial simplex" << endl;}}
    else if(initial_extreme_points.size()==h_dim){if(LDEBUG) {cerr << soliloquy << " not enough points to build a simplex, will settle for a facet instead" << endl;}}
    else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Not enough points to construct initial simplex/facet");}

    //get dim combos of points
    string error;
    aurostd::xcombos xc(initial_extreme_points.size(),h_dim,'C');
    vector<int> indices;
    while(xc.increment()){
      //remember, indices are NOT the indices themselves, but a place holder as to whether to include the number at the index
      //e.g., indices==1,1,0; therefore, include indices 0,1
      indices=xc.getCombo();
      if(LDEBUG) {
        cerr << soliloquy << " indices=";
        for(uint i=0,fl_size_i=indices.size();i<fl_size_i;i++){cerr << indices[i] << (i!=indices.size()-1?",":"");}
        cerr << endl;
      }
      h_facets.push_back(ChullFacet(*p_FileMESSAGE,*p_oss));  //CO20180305
      for(uint i=0,fl_size_i=indices.size();i<fl_size_i;i++){
        if(indices[i]==1){h_facets.back().addVertex(initial_extreme_points[i]);}
      }
      if(LDEBUG) {
        cerr << soliloquy << " initial facet[" << h_facets.size() << "] new point[" << h_facets.back().m_vertices.size() << "] ";
        cerr << "coords=" << m_points[h_facets.back().m_vertices.back().ch_index].h_coords << endl;
      }
      if(!h_facets.back().isValid(error)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"An initial facet cannot be created, invalid points input: "+error);}
      initializeFacet(h_facets.back(),false); //already validated
    }
    if(initial_extreme_points.size()==h_dim+1){if(LDEBUG) {cerr << soliloquy << " initial simplex built" << endl;}}
    else if(initial_extreme_points.size()==h_dim){if(LDEBUG) {cerr << soliloquy << " initial (single) facet built" << endl;}}
    else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Not enough points to construct initial simplex/facet");}

    //if net distance, then it must be outside hull
    bool associated;
    FacetPoint f_point;
    for(uint i=0,fl_size_i=h_points.size();i<fl_size_i;i++){
      associated=false;
      if(LDEBUG) {cerr << soliloquy << " associating point[" << h_points[i] << "] to a facet's outside set" << endl;}
      f_point.initialize(m_points[h_points[i]],h_points[i]);
      for(uint i_facet=0,fl_size_i_facet=h_facets.size();i_facet<fl_size_i_facet && !associated;i_facet++){
        if(h_facets[i_facet].isPointOnFacet(f_point)){associated=true;} //skip the obvious
        if(!associated && h_facets[i_facet].isPointOutside(f_point)){
          h_facets[i_facet].f_outside_set.push_back(f_point);
          associated=true;
          if(LDEBUG) {cerr << soliloquy << " associating point[" << h_points[i] << "] with facet[" << i_facet << "].f_outside_set" << endl;}
        }
      }
      if(!associated){
        if(LDEBUG) {cerr << soliloquy << " NOT associating point[" << h_points[i] << "] with any facet outside set" << endl;}
      }
    }
    //get furthest point
    for(uint i_facet=0,fl_size_i_facet=h_facets.size();i_facet<fl_size_i_facet;i_facet++){
      if(LDEBUG) {cerr << soliloquy << " facet[" << i_facet << "] has " << h_facets[i_facet].f_outside_set.size() << " outside points" << endl;}
      h_facets[i_facet].setFurthestPoint();
    }
    setNeighbors();
  }

  void ConvexHull::setVisibleFacets(uint i_facet){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setVisibleFacets():";
    if(i_facet>h_facets.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index with h_facets");}
    //clean
    for(uint i=0,fl_size_i=h_facets.size();i<fl_size_i;i++){h_facets[i].f_visited=false;}
    h_visible_facets.clear();

    //initialize
    h_visible_facets.push_back(i_facet);
    h_facets[i_facet].f_visited=true;

    uint i_visible,i_neigh;
    //[CO20190409 - size() must be recalculated for EVERY loop]for(uint i=0,fl_size_i=h_visible_facets.size();i<fl_size_i;i++)
    for(uint i=0;i<h_visible_facets.size();i++)
    { //CO20200106 - patching for auto-indenting
      i_visible=h_visible_facets[i];
      for(uint j=0,fl_size_j=h_facets[i_visible].f_neighbors.size();j<fl_size_j;j++){
        i_neigh=h_facets[i_visible].f_neighbors[j];
        if(h_facets[i_neigh].f_visited){continue;}
        h_facets[i_neigh].f_visited=true;
        if(h_facets[i_neigh].isPointOutside(h_facets[i_facet].f_furthest_point)){h_visible_facets.push_back(i_neigh);}
      }
      //there's no need to set i=0 for this loop (unlike the facets loop in calculateFacets()
      //we iterate through neighbors, visiting only once
      //the neighbors of a facet do not change here
    }

    if(LDEBUG) {
      cerr << soliloquy << " visible facets for facet[" << i_facet << "]: ";
      for(uint i=0,fl_size_i=h_visible_facets.size();i<fl_size_i;i++){cerr << h_visible_facets[i] << " ";}
      cerr << endl;
    }
  }

  void ConvexHull::setHorizonRidges(){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setHorizonRidges():";
    if(!h_visible_facets.size()){return;}
    h_horizon_ridges.clear();
    bool match;
    for(uint i1=0,fl_size_i1=h_visible_facets.size();i1<fl_size_i1;i1++){
      for(uint j1=0,fl_size_j1=h_facets[h_visible_facets[i1]].m_ridges.size();j1<fl_size_j1;j1++){
        match=false;
        for(uint i2=0,fl_size_i2=h_visible_facets.size();i2<fl_size_i2&&!match;i2++){
          if(i1==i2){continue;}
          for(uint j2=0,fl_size_j2=h_facets[h_visible_facets[i2]].m_ridges.size();j2<fl_size_j2&&!match;j2++){
            if(h_facets[h_visible_facets[i1]].m_ridges[j1].getCHIndices()==h_facets[h_visible_facets[i2]].m_ridges[j2].getCHIndices()){
              match=true;
            }
          }
        }
        if(!match){h_horizon_ridges.push_back(h_facets[h_visible_facets[i1]].m_ridges[j1]);}
      }
    }

    if(LDEBUG) {
      cerr << soliloquy << " horizon ridges: ";
      for(uint i=0,fl_size_i=h_horizon_ridges.size();i<fl_size_i;i++){
        for(uint j=0,fl_size_j=h_horizon_ridges[i].m_vertices.size();j<fl_size_j;j++){
          cerr << h_horizon_ridges[i].m_vertices[j].ch_index << (j==h_horizon_ridges[i].m_vertices.size()-1?"":" ");
        }
        cerr << (i==h_horizon_ridges.size()-1?"":", ");
      }
      cerr << endl;
    }
  }

  uint ConvexHull::createNewFacets(FacetPoint furthest_point){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::createNewFacets():";
    if(furthest_point.ch_index>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index with furthest_point");}
    uint old_facet_count=h_facets.size();
    string error; //dummy so we don't recreate every time
    for(uint i=0,fl_size_i=h_horizon_ridges.size();i<fl_size_i;i++){
      //check obvious
      if(h_horizon_ridges[i].isPointOnFacet(furthest_point)){
        if(LDEBUG) {cerr << soliloquy << " skipping new facet: duplicate point" << endl;}
        continue;
      }
      h_horizon_ridges[i].addVertex(furthest_point);
      if(LDEBUG) {cerr << soliloquy << " furthest point for new facet: " << furthest_point.ch_index << " " << m_points[furthest_point.ch_index].h_coords << endl;}
      if(!h_horizon_ridges[i].isValid(error)){  //corner case, happens when creating new facets on edges or corners of hull
        if(LDEBUG) {cerr << soliloquy << " skipping new facet: " << error << endl;}
        continue;
      }
      initializeFacet(h_horizon_ridges[i],false); //already validated
      h_facets.push_back(h_horizon_ridges[i]);
      if(LDEBUG) {
        cerr << soliloquy << " new facet: ";
        for(uint j=0,fl_size_j=h_facets.back().m_vertices.size();j<fl_size_j;j++){cerr << m_points[h_facets.back().m_vertices[j].ch_index].h_coords << " | ";}
        cerr << endl;
      }
    }
    if(LDEBUG) {cerr << soliloquy << " " << h_facets.size()-old_facet_count << " new facets" << endl;}
    return h_facets.size()-old_facet_count;
    //do neighbors at the end!
  }

  void ConvexHull::updateOutsideSet(uint new_facet_count){  //they are at the end of the list
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::updateOutsideSet():";
    //we're deleting visible planes soon, so we need to reassess/reassign outside points
    uint i_visible;
    bool associated;
    for(uint i=0,fl_size_i=h_visible_facets.size();i<fl_size_i;i++){
      i_visible=h_visible_facets[i];
      for(uint j=0,fl_size_j=h_facets[i_visible].f_outside_set.size();j<fl_size_j;j++){
        FacetPoint& f_point=h_facets[i_visible].f_outside_set[j];
        associated=false;
        if(LDEBUG) {cerr << soliloquy << " re-associating point[" << f_point.ch_index << "] with a new facet" << endl;}
        for(uint fl_size_i_facet=h_facets.size(),i_facet=fl_size_i_facet-new_facet_count;i_facet<fl_size_i_facet&&!associated;i_facet++){
          if(h_facets[i_facet].isPointOnFacet(f_point)){associated=true;} //skip the obvious
          if(!associated && h_facets[i_facet].isPointOutside(f_point)){
            h_facets[i_facet].f_outside_set.push_back(f_point);
            associated=true;
            if(LDEBUG) {cerr << soliloquy << " associating point[" << f_point.ch_index << "] with facet[" << i_facet << "].f_outside_set" << endl;}
          }
        }
      }
    }
    for(uint fl_size_i_facet=h_facets.size(),i_facet=fl_size_i_facet-new_facet_count;i_facet<fl_size_i_facet;i_facet++){
      if(LDEBUG) {cerr << soliloquy << " NEW facet[" << i_facet << "] has " << h_facets[i_facet].f_outside_set.size() << " outside points" << endl;}
      h_facets[i_facet].setFurthestPoint();
    }
  }

  void ConvexHull::deleteVisibleFacets() {
    //sort in descending order because all indices above the point of deletion change
    std::sort(h_visible_facets.rbegin(), h_visible_facets.rend());  //descending  //, std::greater<uint>());
    for(uint i=0,fl_size_i=h_visible_facets.size();i<fl_size_i;i++){h_facets.erase(h_facets.begin()+h_visible_facets[i]);}
  }

  void ConvexHull::removeDuplicateHullPoints() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::removeDuplicateHullPoints():";
    std::sort(h_points.begin(),h_points.end());h_points.erase( std::unique( h_points.begin(), h_points.end() ), h_points.end() );  //first remove duplicate indices

    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}
    vector<uint> indices_2_remove;
    for(uint i=0,fl_size_i=h_points.size();i<fl_size_i;i++){
      for(uint j=i+1,fl_size_j=h_points.size();j<fl_size_j;j++){
        if(identical(m_points[h_points[i]].h_coords,m_points[h_points[j]].h_coords,ZERO_TOL)){
          indices_2_remove.push_back(j);
        }
      }
    }
    if(LDEBUG) {
      cerr << soliloquy << " removing points: ";
      for(uint i=0,fl_size_i=indices_2_remove.size();i<fl_size_i;i++){cerr << indices_2_remove[i] << " ";}
      cerr << endl;
    }
    std::sort(indices_2_remove.rbegin(),indices_2_remove.rend()); //descending
    for(uint i=0,fl_size_i=indices_2_remove.size();i<fl_size_i;i++){h_points.erase(h_points.begin()+indices_2_remove[i]);}
    if(LDEBUG) {cerr << soliloquy << " done" << endl;}
  }

  void ConvexHull::calculateFacets() {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    //only copy those possibly on the hull (does not include endpoints)
    string soliloquy=XPID+"ConvexHull::calculateFacets():";

    h_facets.clear();
    removeDuplicateHullPoints();
    if(!h_points.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No points found on hull");}
    h_dim=m_points[h_points[0]].h_coords.rows;

    for(uint i=1,fl_size_i=h_points.size();i<fl_size_i;i++){
      if((uint)m_points[h_points[i]].h_coords.rows!=h_dim){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid initialization of hull coordinates");}
    }

    if(LDEBUG) {
      for(uint i=0,fl_size_i=h_points.size();i<fl_size_i;i++){
        cerr << soliloquy << " m_coords=" << m_points[h_points[i]].m_coords << "; h_coords=" << m_points[h_points[i]].h_coords << endl; //<< "; relevant " << m_points[h_points[i]].isRelevantPoint(elements_present) << endl;
      }
    }

    //main loop START - see algorithm here: 10.1145/235815.235821
    createInitializeSimplex();

    uint new_facet_count;
    //[CO20190409 - size() must be recalculated for EVERY loop]for(uint i_facet=0,fl_size_i_facet=h_facets.size();i_facet<fl_size_i_facet;i_facet++)
    for(uint i_facet=0;i_facet<h_facets.size();i_facet++)
    { //CO20200106 - patching for auto-indenting
      if(!h_facets[i_facet].f_outside_set.size()){continue;}  //the only way we exit this loop is if we continue for ALL facets
      setVisibleFacets(i_facet);
      setHorizonRidges();
      new_facet_count=createNewFacets(h_facets[i_facet].f_furthest_point);
      if(new_facet_count){
        updateOutsideSet(new_facet_count);  //redistribute outside set among new facets (visible planes will go soon)
        for(uint fl_size_i_facet=h_facets.size(),i_facet=fl_size_i_facet-new_facet_count;i_facet<fl_size_i_facet;i_facet++){h_facets[i_facet].setFurthestPoint();}  //get furthest points for new facets
        deleteVisibleFacets();  //delete visible facets
        setNeighbors();
      }
      i_facet=-1; //restart full loop!
    }
    //main loop END - see algorithm here: 10.1145/235815.235821

    //resort points in facets with knowledge of normal
    //if normal is pointed down, sort in descending order
    bool sort_stoich_ascending;
    for(uint i=0,fl_size_i=h_facets.size();i<fl_size_i;i++){
      sort_stoich_ascending=!h_facets[i].m_in_lower_hemisphere;
      std::sort(h_facets[i].m_vertices.begin(),h_facets[i].m_vertices.end(),
          sortThermoPoints(sort_stoich_ascending,m_sort_energy_ascending));
    }
    std::sort(h_facets.begin(),h_facets.end(),sortFacetsByPoints(m_points));  //auto sort

    if(LDEBUG) {
      cerr << soliloquy << " hull points:" << endl;
      for(uint i_facet=0,fl_size_i_facet=h_facets.size();i_facet<fl_size_i_facet;i_facet++){
        cerr << soliloquy << " facet " << i_facet << ": ";
        for(uint i=0,fl_size_i=h_facets[i_facet].m_vertices.size();i<fl_size_i;i++){
          cerr << m_points[h_facets[i_facet].m_vertices[i].ch_index].h_coords << " - auid " << m_points[h_facets[i_facet].m_vertices[i].ch_index].m_entry.auid << " | ";
        }
        cerr << "normal " << h_facets[i_facet].m_normal << " | angles " << aurostd::getGeneralAngles(h_facets[i_facet].m_normal,ZERO_TOL) << endl;//<< " | x " << cos(h_facets[i_facet].m_angle) << " | y " << sin(h_facets[i_facet].m_angle)  << endl;
      }
    }
  }

  const xvector<int>& ConvexHull::getElementsPresent(uint i_nary,uint i_alloy) const {
    string soliloquy=XPID+"ConvexHull::setElementsPresent():";
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    return m_naries[i_nary].m_alloys[i_alloy].m_elements_present;
  }
  const xvector<int>& ConvexHull::getElementsPresent(uint i_point) const {
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,"ConvexHull::getElementsPresent():","Invalid index within points");}
    return m_points[i_point].m_elements_present;
  }
  xvector<int> ConvexHull::getElementsPresent(const vector<uint>& vcpoints) const {
    //get union of elements_present, just the sum
    string soliloquy=XPID+"ConvexHull::getElementsPresent():";
    if(vcpoints.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No points provided");}
    xvector<int> elements_present=getElementsPresent(vcpoints[0]);
    if(vcpoints.size()==1){return elements_present;}
    for(uint i=1,fl_size_i=vcpoints.size();i<fl_size_i;i++) {
      uint i_point=vcpoints[i];
      const xvector<int>& _elements_present=getElementsPresent(i_point);
      elements_present+=_elements_present;
    }
    return elements_present;
  }

  void ConvexHull::setElementsPresent(uint i_nary,uint i_alloy){m_elements_present=getElementsPresent(i_nary,i_alloy);}

  void ConvexHull::addRelevantUnariesToHullCalculation(uint i_nary,uint i_alloy) {
    string soliloquy=XPID+"ConvexHull::addRelevantUnariesToHullCalculation():";
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    return addRelevantUnariesToHullCalculation(m_naries[i_nary].m_alloys[i_alloy].m_elements_present);
  }

  void ConvexHull::addRelevantUnariesToHullCalculation(xvector<int>& elements_present) {
    string soliloquy=XPID+"ConvexHull::addRelevantUnariesToHullCalculation():";
    uint i_nary=0;
    if((uint)elements_present.rows!=m_naries[i_nary].m_alloys.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unary alloy is missing from m_naries");}
    uint i_coord_group,i_point;
    for(int i_alloy=elements_present.lrows;i_alloy<=elements_present.urows;i_alloy++){
      if(elements_present[i_alloy]==1){
        if(m_naries[i_nary].m_alloys[i_alloy-elements_present.lrows].m_coord_groups.size()!=1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unexpected count of coordgroups for unaries, should only be 1");}
        i_coord_group=m_naries[i_nary].m_alloys[i_alloy-elements_present.lrows].m_coord_groups[0];
        if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
        for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_candidate_hull_points.size();i<fl_size_i;i++){
          i_point=m_coord_groups[i_coord_group].m_candidate_hull_points[i];
          if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
          addPointToHullCalculation(i_point,elements_present);
        }
      }
    }
  }

  void ConvexHull::addLowerDimensionPointsToHullCalculation(uint i_nary_max){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::addLowerDimensionPointsToHullCalculation():";
    if(i_nary_max>m_naries.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}
    //grab from m_naries[i_nary].m_alloys[i_alloy].m_facets
    //we already added unaries, so there will be duplicates, but we safely remove in calculateFacets()
    //don't worry about this yet
    uint i_point=AUROSTD_MAX_UINT,i_facet=AUROSTD_MAX_UINT;
    for(uint i_nary=1;i_nary<i_nary_max;i_nary++){
      if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
      for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
        if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
        if(m_naries[i_nary].m_alloys[i_alloy].belongs2Hull(m_elements_present)){
          for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_facets.size();i<fl_size_i;i++){
            i_facet=m_naries[i_nary].m_alloys[i_alloy].m_facets[i];
            if(i_facet>m_facets.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_facets");}
            const ChullFacet& facet=m_facets[i_facet];
            for(uint j=0,fl_size_j=facet.m_vertices.size();j<fl_size_j;j++){
              i_point=facet.m_vertices[j].ch_index;
              addPointToHullCalculation(i_point,m_elements_present); //this is hull specific, and set with setElementsPresent()
            }
          }
        }
      }
    }
    if(LDEBUG) {cerr << soliloquy << " done" << endl;}
  }

  void ConvexHull::addPointToHullCalculation(uint i_point){
    string soliloquy=XPID+"ConvexHull::addPointToHullCalculation():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    h_points.push_back(i_point);
    m_points[i_point].setHullCoords();
  }

  void ConvexHull::addPointToHullCalculation(uint i_point,xvector<int>& elements_present){
    string soliloquy=XPID+"ConvexHull::addPointToHullCalculation():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    h_points.push_back(i_point);
    m_points[i_point].setHullCoords(elements_present);
  }

  void ConvexHull::preparePointsForHullCalculation(uint i_nary,uint i_alloy) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::preparePointsForHullCalculation():";
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}
    h_points.clear();
    addRelevantUnariesToHullCalculation(i_nary,i_alloy);
    addLowerDimensionPointsToHullCalculation(i_nary); //don't worry about adding unary duplicates, we remove them robustly in calculateFacets()
    uint i_coord_group,i_point;
    for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i<fl_size_i;i++){
      i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
      for(uint j=0,fl_size_j=m_coord_groups[i_coord_group].m_candidate_hull_points.size();j<fl_size_j;j++){
        i_point=m_coord_groups[i_coord_group].m_candidate_hull_points[j];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        addPointToHullCalculation(i_point,m_naries[i_nary].m_alloys[i_alloy].m_elements_present);
      }
    }
    if(LDEBUG) {cerr << soliloquy << " done" << endl;}
  }

  void ConvexHull::preparePointsForHullCalculation() {
    string soliloquy=XPID+"ConvexHull::preparePointsForHullCalculation():";
    h_points.clear();
    //we already checked extremes in last (energy) direction, just add these to the hull
    //don't include those points in between
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_candidate_hull_points.size();i<fl_size_i;i++){
        i_point=m_coord_groups[i_coord_group].m_candidate_hull_points[i];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        addPointToHullCalculation(i_point);
      }
    }
  }

  uint ConvexHull::getNearestFacetVertically(const vector<uint>& i_facets,const ChullPoint& point) const{
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getNearestFacetVertically():";
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    if(LDEBUG) {cerr << soliloquy << " m_coords=" << point.m_coords << ", h_coords=" << point.h_coords << endl;}
    return getNearestFacetVertically(i_facets,point.h_coords);
  }

  uint ConvexHull::getNearestFacetVertically(const vector<uint>& i_facets,const xvector<double>& point) const{
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    //determines nearness by vertical distance
    string soliloquy=XPID+"ConvexHull::getNearestFacetVertically():";
    uint i_facet = 0, i_facet_min = 0;
    uint i_facet_artificial=-1; //really large uint
    double vdist,dist=AUROSTD_MAX_DOUBLE;
    for(uint i=0,fl_size_i=i_facets.size();i<fl_size_i;i++){
      i_facet=i_facets[i];
      if(i_facet>m_facets.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_facets");}
      const ChullFacet& facet=m_facets[i_facet];
      if(!facet.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Facet not initialized");}
      if(facet.m_hypercollinear){continue;}
      if(facet.m_is_vertical){continue;}
      if(facet.m_is_artificial){
        i_facet_artificial=i_facet;
        continue;
      }
      if(LDEBUG) {cerr << soliloquy << " looking at facet[" << i_facet << "]" << endl;}
      vdist=abs(facet.getSignedVerticalDistanceToZero(point));  //abs, //(repetita iuvant)
      if(vdist<dist){
        i_facet_min=i_facet;
        dist=vdist;
      }
    }
    //safety, return artificial facet if no other facets available
    if(dist==AUROSTD_MAX_DOUBLE){
      if(i_facet_artificial>m_facets.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No nearest facet found");}
      return i_facet_artificial;
    }
    return i_facet_min;
  }

  const vector<uint>& ConvexHull::getRelevantFacets(uint i_nary,uint i_alloy) const {
    string soliloquy=XPID+"ConvexHull::getRelevantFacets():";
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}

    if(i_nary==0){  //unaries are special case
      //try m_facets, otherwise start from top and go down
      if(m_i_facets.size()){return m_i_facets;}
      for(uint fl_size_i_nary=m_naries.size(),i_nary=fl_size_i_nary-1;i_nary<fl_size_i_nary;i_nary--){
        for(uint fl_size_i_alloy=m_naries[i_nary].m_alloys.size(),i_alloy=fl_size_i_alloy-1;i_alloy<=fl_size_i_alloy;i_alloy--){
          if(m_naries[i_nary].m_alloys[i_alloy].m_facets.size()){return m_naries[i_nary].m_alloys[i_alloy].m_facets;}
        }
      }
    } else {
      if(m_naries[i_nary].m_alloys[i_alloy].m_facets.size()){return m_naries[i_nary].m_alloys[i_alloy].m_facets;}
    }
    throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Facets not calculated");
  }

  void ConvexHull::setHullMembers() {return setHullMembers(m_i_facets);}
  void ConvexHull::setHullMembers(uint i_nary,uint i_alloy) {
    string soliloquy=XPID+"ConvexHull::setHullMembers():";
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    const vector<uint>& i_facets=getRelevantFacets(i_nary,i_alloy);//m_naries[i_nary].m_alloys[i_alloy].m_facets;
    return setHullMembers(i_facets);
  }

  void ConvexHull::setHullMembers(const vector<uint>& i_facets) {
    string soliloquy=XPID+"ConvexHull::setHullMembers():";
    if(!i_facets.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull has yet to be calculated");}
    uint i_point=AUROSTD_MAX_UINT,g_state=AUROSTD_MAX_UINT,i_coord_group=AUROSTD_MAX_UINT,i_facet=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=i_facets.size();i<fl_size_i;i++){
      i_facet=i_facets[i];
      if(i_facet>m_facets.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_facets");}
      for(uint j=0,fl_size_j=m_facets[i_facet].m_vertices.size();j<fl_size_j;j++){
        i_point=m_facets[i_facet].m_vertices[j].ch_index;
        if(!getCoordGroupIndex(i_point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
        //hull member == yes
        m_points[i_point].m_is_on_hull=true;
        m_coord_groups[i_coord_group].m_is_on_hull=true;
        if(m_thermo_hull){m_coord_groups[i_coord_group].m_hull_member=i_point;}  //very safe, only one hull-member per coordgroup
        //g-state == if not artificial point
        g_state=artificialMap(i_point);
        if(!m_points[g_state].m_is_artificial){m_points[g_state].m_is_g_state=true;}
      }
    }
  }

  void ConvexHull::setNearestFacet(uint i_nary,uint i_alloy,uint i_coord_group){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setNearestFacet():";
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    if(i_coord_group>m_coord_groups.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(m_coord_groups[i_coord_group].m_is_on_hull){return;}
    if(m_coord_groups[i_coord_group].m_points.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}

    uint i_point=m_coord_groups[i_coord_group].m_points[0];
    if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
    ChullPoint& point=m_points[i_point];
    //it's possible that h_coords has not been set (we only do it to points that make it to hull calc)
    //so set again (repetita iuvant)
    xvector<int>& elements_present=m_naries[i_nary].m_alloys[i_alloy].m_elements_present;
    point.setHullCoords(elements_present);
    const vector<uint>& i_facets=getRelevantFacets(i_nary,i_alloy);//m_naries[i_nary].m_alloys[i_alloy].m_facets;
    uint i_facet=getNearestFacetVertically(i_facets,point);
    m_coord_groups[i_coord_group].m_nearest_facet=i_facet;
    if(LDEBUG) {
      cerr << soliloquy << " nearest_facet[i_nary=" << i_nary << ",i_alloy=" << i_alloy << ",i_coord_group=" << i_coord_group;
      cerr << "]=" << m_coord_groups[i_coord_group].m_nearest_facet << endl;
    }
  }

  double ConvexHull::getSignedVerticalDistanceWithinCoordGroup(uint i_coord_group,uint i_point) const {
    string soliloquy=XPID+"ConvexHull::getSignedVerticalDistanceWithinCoordGroup():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    return getSignedVerticalDistanceWithinCoordGroup(i_coord_group,m_points[i_point]);
  }

  double ConvexHull::getSignedVerticalDistanceWithinCoordGroup(uint i_coord_group,const ChullPoint& point) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getSignedVerticalDistanceWithinCoordGroup():";
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
    if(m_coord_groups[i_coord_group].m_points.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    xvector<double> r_coords=point.getStoichiometricCoords();
    if(!identical(m_coord_groups[i_coord_group].m_coords,r_coords,ZERO_TOL)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point does not belong to coordgroup");}

    uint ref_point=artificialMap(m_coord_groups[i_coord_group].m_points[0]);  //don't need to set distance for artificial point, re-scale to this point
    if(!isViablePoint(ref_point)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup contains invalid point");}
    double ref_dist=0.0;
    //if(m_coord_groups[i_coord_group].m_is_on_hull){ //just a check //bad check, doesn't apply to unaries
    //if(!m_points[ref_point].m_is_on_hull){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup is on the hull, but hull point not found");}  //not the case for unaries
    //} else {  //[CO20200106 - close bracket for indenting]}
    if(!m_coord_groups[i_coord_group].m_is_on_hull){
      uint i_facet=m_coord_groups[i_coord_group].m_nearest_facet;
      if(i_facet>m_facets.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_facets");}
      ref_dist=m_facets[i_facet].getSignedVerticalDistance(m_points[ref_point]);  //signed distance
      //DO NOT CHECK SIGN OF VERTICAL DISTANCE, WE USE THIS FUNCTION FOR STABILITY CRITERION
      //if(m_half_hull){  //tests of stupidity
      //  //do not use signbit, add tol to zero (precision)
      //  //sign of distance:
      //  //independent of lower/upper hull:  above hull is negative, below hull is positive
      //  bool should_be_positive=!m_lower_hull;
      //  bool correct_sign_vertical_distance=chull::correctSignVerticalDistance(ref_dist,should_be_positive);
      //  if( m_lower_hull && !correct_sign_vertical_distance){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"(lower half hull) found point BELOW hull (entry="+m_points[ref_point].m_entry.auid+",dist2Hull="+aurostd::utype2string(ref_dist,4)+")");}
      //  if(!m_lower_hull && !correct_sign_vertical_distance){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"(upper half hull) found point ABOVE hull (entry="+m_points[ref_point].m_entry.auid+",dist2Hull="+aurostd::utype2string(ref_dist,4)+")");}
      //}
    }
    double delta=(point.getLastCoord()-m_points[ref_point].getLastCoord());
    double dist=ref_dist-delta;
    if(LDEBUG) {
      cerr << soliloquy << " point.m_entry.auid=" << point.m_entry.auid << endl;
      cerr << soliloquy << " m_points[ref_point].m_entry.auid=" << m_points[ref_point].m_entry.auid << endl;
      cerr << soliloquy << " point.m_entry.prototype=" << point.m_entry.prototype << endl;
      cerr << soliloquy << " m_points[ref_point].m_entry.prototype=" << m_points[ref_point].m_entry.prototype << endl;
      cerr << soliloquy << " point.m_coords=" << point.m_coords << endl;
      cerr << soliloquy << " m_points[ref_point].m_coords=" << m_points[ref_point].m_coords << endl;
      cerr << soliloquy << " ref_dist=" << ref_dist << endl;
      cerr << soliloquy << " delta=" << delta << endl;
      cerr << soliloquy << " dist=" << dist << endl;
    }
    return dist;
  }

  double ConvexHull::getDistanceToHull(uint i_point,bool redo,bool get_signed_distance) const{
    string soliloquy=XPID+"ConvexHull::getDistanceToHull():";
    if(i_point>(m_points.size()-1)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");} //HE20210629 make comparison more precise
    return getDistanceToHull(m_points[i_point],redo,get_signed_distance);
  }

  double ConvexHull::getDistanceToHull(const ChullPoint& point,bool redo,bool get_signed_distance) const{
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getDistanceToHull():";
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    //const vector<uint>& i_facets=m_i_facets;
    double dist;
    if(!redo){
      if(LDEBUG) {cerr << soliloquy << " attempting to find coordgroup for fast distance calculation" << endl;}
      uint i_coord_group=AUROSTD_MAX_UINT;
      //only if the distances have already been found for all points, and we can identify the coordgroup (point may legitimately be outside)
      //the redo in the getCoordGroupIndex() is VERY safe, so let's keep it
      if(getCoordGroupIndex(point,i_coord_group,true)){
        if(LDEBUG) {cerr << soliloquy << " found coordgroup[" << i_coord_group << "] (coords=" << m_coord_groups[i_coord_group].m_coords << ")" << endl;}
        dist=getSignedVerticalDistanceWithinCoordGroup(i_coord_group,point);
        if(get_signed_distance==false){dist=abs(dist);} //CO20180828 //CO20190808
        if(LDEBUG) {cerr << soliloquy << " dist=" << dist << endl;}
        return dist;
      }
      //  uint ref_point=m_coord_groups[i_coord_group].m_ref_state;
      //  if(LDEBUG) {cerr << soliloquy << " preliminarily setting ref_point=" << ref_point << endl;}
      //  double dist=AUROSTD_NAN;
      //  if(isViablePoint(ref_point)){dist=m_points[ref_point].getDist2Hull(_std_);}
      //  else {
      //    if(m_coord_groups[i_coord_group].m_is_on_hull){
      //      ref_point=m_coord_groups[i_coord_group].m_points[0];
      //      if(isViablePoint(ref_point) && m_points[ref_point].m_is_on_hull){dist=0.0;} //some safety checks, but ultimately set to 0
      //    }
      //  }
      //  if(LDEBUG) {
      //    cerr << soliloquy << " m_points[ref_point=" << ref_point << "].m_coords=";
      //    for(int i=m_points[ref_point].m_coords.lrows;i<=m_points[ref_point].m_coords.urows;i++){cerr << m_points[ref_point].m_coords[i] << " ";}
      //    cerr << endl;
      //    cerr << soliloquy << " dist of ref_point = " << dist << endl;
      //  }
      //  if(!m_points[ref_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
      //  if(dist<AUROSTD_NAN){ //safety
      //    double delta=(m_points[ref_point].getLastCoord()-point.getLastCoord());
      //    if(LDEBUG) {
      //      cerr << soliloquy << " delta = " << delta << endl;
      //      cerr << soliloquy << " dist+delta = " << dist+delta << endl;
      //      cerr << soliloquy << " dist-delta = " << dist-delta << endl;
      //      cerr << soliloquy << " delta-dist = " << delta-dist << endl;
      //    }
      //    if(LDEBUG) {cerr << soliloquy << " getSignedVerticalDistanceWithinCoordGroup()=" << getSignedVerticalDistanceWithinCoordGroup(i_coord_group,point) << endl;}
      //    return delta-dist;
      //  }
    }
    vector<uint> i_facets=m_i_facets;
    //if we have stoich_coords, we need to find relevant facets
    if(m_has_stoich_coords){
      if(LDEBUG) {cerr << soliloquy << " stoich_coords detected, trying to find relevant facets" << endl;}
      uint i_nary,i_alloy;
      if(!getAlloyIndex(point,i_nary,i_alloy)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Cannot get alloys index");}
      if(i_nary==0){  //unaries are special cases, they RARELY work with normal getSignedVerticalDistance()
        if(LDEBUG) {cerr << soliloquy << " found unary, need to use coordgroup to find distance (rarely works with normal getSignedVerticalDistance()" << endl;}
        uint i_coord_group=AUROSTD_MAX_UINT;
        if(!getCoordGroupIndex(point,i_coord_group,true)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Cannot find unary coordgroup");}
        dist=getSignedVerticalDistanceWithinCoordGroup(i_coord_group,point);
        if(get_signed_distance==false){dist=abs(dist);} //CO20180828 //CO20190808
        if(LDEBUG) {cerr << soliloquy << " dist=" << dist << endl;}
        return dist;
      }
      i_facets=getRelevantFacets(i_nary,i_alloy);
    } else {
      if(LDEBUG) {cerr << soliloquy << " searching through ALL facets for closest vertical distance" << endl;}
    }
    //otherwise, all facets are relevant (same dimension)
    uint i_facet=getNearestFacetVertically(i_facets,point);
    dist=m_facets[i_facet].getSignedVerticalDistance(point);
    if(get_signed_distance==false){dist=abs(dist);} //CO20180828 //CO20190808
    if(LDEBUG) {cerr << soliloquy << " dist=" << dist << endl;}
    return dist;
  }

  vector<double> ConvexHull::getDistancesToHull(const vector<string>& vauid,bool redo) const{
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getDistancesToHull():";
    stringstream message;
    vector<double> vdist2hull;
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=vauid.size();i<fl_size_i;i++){
      const string& auid=vauid[i];
      if(auid.empty()){message << "Empty auid found";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      if(!findPoint(auid,i_point)){message << "Specified auid not found on hull (auid=" << auid << ")";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      if(LDEBUG) {cerr << soliloquy << " grabbing distance to hull for i_point=" << i_point << endl;}
      vdist2hull.push_back(getDistanceToHull(i_point,redo));
    }
    return vdist2hull;
  }

  bool ConvexHull::hullDistanceExtractionRequired() const {
    if(thermoPropertiesExtractionRequired()){return true;}  //dependency
    if(!m_cflags.flag("CHULL::MULTI_OUTPUT")&&(m_cflags.flag("CHULL::LATEX_DOC")||m_cflags.flag("CHULL::PNG_IMAGE"))){
      aurostd::xoption lflags=resolvePlotLabelSettings();
      bool meta_labels=lflags.flag("CHULL::PLOT_META_LABELS");
      bool labels_off_hull=lflags.flag("CHULL::PLOT_LABELS_OFF_HULL");
      if(meta_labels&&labels_off_hull){return true;}  //need distances to hull here
      bool no_doc=m_cflags.flag("CHULL::NO_DOC");
      if(no_doc){return false;}
      bool image_only=m_cflags.flag("CHULL::IMAGE_ONLY");
      if(image_only){return false;}
    }
    return true;
  }

  bool ConvexHull::thermoPropertiesExtractionRequired() const {
    if(thermoPostProcessingExtractionRequired()){return true;}  //dependency
    if(!m_cflags.flag("CHULL::MULTI_OUTPUT")&&(m_cflags.flag("CHULL::LATEX_DOC")||m_cflags.flag("CHULL::PNG_IMAGE"))){
      aurostd::xoption lflags=resolvePlotLabelSettings();
      bool icsd_labels=lflags.flag("CHULL::PLOT_ICSD_LABELS");
      if(icsd_labels){return true;}
      bool no_doc=m_cflags.flag("CHULL::NO_DOC");
      if(no_doc){return false;}
      bool image_only=m_cflags.flag("CHULL::IMAGE_ONLY");
      if(image_only){return false;}
    }
    return true;
  }

  bool ConvexHull::thermoPostProcessingExtractionRequired() const {
    if(!m_cflags.flag("CHULL::MULTI_OUTPUT")&&(m_cflags.flag("CHULL::LATEX_DOC")||m_cflags.flag("CHULL::PNG_IMAGE"))){
      bool no_doc=m_cflags.flag("CHULL::NO_DOC");
      if(no_doc){return false;}
      bool image_only=m_cflags.flag("CHULL::IMAGE_ONLY");
      if(image_only){return false;}
    }
    return true;
  }

  void ConvexHull::setDistancesToHull(uint i_nary,uint i_alloy) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setDistancesToHull():";
    stringstream message;
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}

    //SKIP_HULL_DISTANCE_CALCULATION is NOT recommended
    //the algorithm is already heavily optimized so it's quite fast
    bool perform_hull_distance_calculation=(1 &&
        hullDistanceExtractionRequired() &&
        (!m_cflags.flag("CHULL::SKIP_HULL_DISTANCE_CALCULATION")) &&
        TRUE); //(1&&!(m_cflags.flag("CHULL::SKIP_HULL_DISTANCE_CALCULATION")||(!m_cflags.flag("CHULL::MULTI_OUTPUT")&&m_cflags.flag("CHULL::LATEX_DOC")&&m_cflags.flag("CHULL::IMAGE_ONLY"))));
    if(!perform_hull_distance_calculation){return;}

    message << "Gathering hull distance data for";
    if(m_velements.size()){message << " " << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"-");}
    message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

    uint i_coord_group=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i<fl_size_i;i++){
      i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
      if(!m_coord_groups[i_coord_group].m_points.size()){continue;}
      if(!m_coord_groups[i_coord_group].m_initialized){continue;}
      if(LDEBUG) {cerr << soliloquy << " looking at i_coord_group=" << i_coord_group << endl;}
      if(!m_coord_groups[i_coord_group].m_is_on_hull){setNearestFacet(i_nary,i_alloy,i_coord_group);} //only off-hull need nearest facets
      setDistancesToHull(i_nary,i_alloy,i_coord_group);
    }
  }

  void ConvexHull::setDistancesToHull(uint i_nary,uint i_alloy,uint i_coord_group) {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setDistancesToHull():";
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    if(i_coord_group>m_coord_groups.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(m_coord_groups[i_coord_group].m_nearest_facet>m_facets.size()-1){setNearestFacet(i_nary,i_alloy,i_coord_group);}
    if(m_coord_groups[i_coord_group].m_points.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}

    uint i_point=m_coord_groups[i_coord_group].m_points[0];
    if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
    i_point=artificialMap(i_point); //don't need to set distance for artificial point, re-scale to this point
    ChullPoint& point=m_points[i_point];
    double dist_2_hull=0.0;
    bool check_dist_2_hull=false;
    if(!m_coord_groups[i_coord_group].m_is_on_hull){ //off-hull, this is the reason it works for unaries, unaries coordgroup are declared ON-HULL, so dist==0 automatically
      uint i_facet=m_coord_groups[i_coord_group].m_nearest_facet;
      dist_2_hull=m_facets[i_facet].getSignedVerticalDistance(point);  //do this "expensive" calculation only once, others are simply z-scaled
      if(LDEBUG) {
        cerr << soliloquy << " dist[coord=" << point.h_coords << "]=" << dist_2_hull << endl;
        if(check_dist_2_hull){
          cerr << soliloquy << " comparing fast dist calculation = "  << dist_2_hull;
          cerr << " vs. slow dist calculation =" << getDistanceToHull(point) << endl;
        }
      }
      if(m_half_hull){  //tests of stupidity
        //do not use signbit, add tol to zero (precision)
        //sign of distance:
        //independent of lower/upper hull:  above hull is negative, below hull is positive
        bool should_be_positive=!m_lower_hull;
        bool correct_sign_vertical_distance=chull::correctSignVerticalDistance(dist_2_hull,should_be_positive);
        if( m_lower_hull && !correct_sign_vertical_distance){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"(lower half hull) found point BELOW hull (entry="+point.m_entry.auid+",dist2Hull="+aurostd::utype2string(dist_2_hull,4)+")");}
        if(!m_lower_hull && !correct_sign_vertical_distance){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"(upper half hull) found point ABOVE hull (entry="+point.m_entry.auid+",dist2Hull="+aurostd::utype2string(dist_2_hull,4)+")");}
        //[OBSOLETE CO20180828]if(m_lower_hull){
        //[OBSOLETE CO20180828]  if(notNegative(dist_2_hull,true)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"(lower half hull) found point BELOW hull (entry="+point.m_entry.auid+",dist2Hull="+aurostd::utype2string(dist_2_hull,4)+")");}
        //[OBSOLETE CO20180828]} else {
        //[OBSOLETE CO20180828]  if(notPositive(dist_2_hull,true)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"(upper half hull) found point ABOVE hull (entry="+point.m_entry.auid+",dist2Hull="+aurostd::utype2string(dist_2_hull,4)+")");}
        //[OBSOLETE CO20180828]}
      }
    }
    //KEEP THE SIGN CONVENTION AS IS, it is correct without manipulation
    //by convention, distances inside hull are NEGATIVE, following the reaction equation (spontaneous decomposition)
    //which we just checked is the case, so force negative
    //dist_2_hull=-abs(dist_2_hull); //force positive, the value is what we care about now
    //[OBSOLETE CO20180828]point.m_dist_2_hull=m_coord_groups[i_coord_group].m_nearest_distance=dist_2_hull;
    point.m_dist_2_hull=m_coord_groups[i_coord_group].m_nearest_distance=abs(dist_2_hull);
    if(LDEBUG) {cerr << soliloquy << " |dist|=" << point.m_dist_2_hull << endl;}
    uint j_point;
    for(uint j=0,fl_size_j=m_coord_groups[i_coord_group].m_points.size();j<fl_size_j;j++){
      j_point=m_coord_groups[i_coord_group].m_points[j];
      j_point=artificialMap(j_point); //don't need to set distance for artificial point, re-scale to this point
      m_points[j_point].m_dist_2_hull=point.m_dist_2_hull;
      //[OBSOLETE CO20180828]if(i_point!=j_point){m_points[j_point].m_dist_2_hull+=(point.getLastCoord()-m_points[j_point].getLastCoord());}  //simply ADD difference
      if(i_point!=j_point){m_points[j_point].m_dist_2_hull+=abs(point.getLastCoord() - m_points[j_point].getLastCoord());}  //simply ADD difference
      //it's possible that h_coords has not been set (we only do it to points that make it to hull calc)
      //so set again (repetita iuvant)
      if(LDEBUG) {
        xvector<int>& elements_present=m_naries[i_nary].m_alloys[i_alloy].m_elements_present;
        m_points[j_point].setHullCoords(elements_present);
        cerr << soliloquy << " dist[coord=" << m_points[j_point].h_coords << "]=" << m_points[j_point].m_dist_2_hull << endl;
      }
    }
  }

  vector<uint> ConvexHull::extractDecompositionPhases(const ChullFacet& facet) const{
    string soliloquy=XPID+"ConvexHull::extractDecompositionPhases():";
    uint i_point=AUROSTD_MAX_UINT;
    vector<uint> decomp_phases;
    for(uint i=0,fl_size_i=facet.m_vertices.size();i<fl_size_i;i++){
      i_point=facet.m_vertices[i].ch_index;
      decomp_phases.push_back(i_point);
    }
    if(decomp_phases.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No decomposition phases found");}
    std::sort(decomp_phases.begin(),
        decomp_phases.end(),
        sortCHullPoints(m_points,false,true)); //stoich sorting should be descending, energy sorting default okay here
    return decomp_phases;
  }

  vector<uint> ConvexHull::getDecompositionPhases(uint i_point) const{
    string soliloquy=XPID+"ConvexHull::getDecompositionPhases():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    return getDecompositionPhases(m_points[i_point]);
  }

  vector<uint> ConvexHull::getDecompositionPhases(const ChullPoint& point) const{
    string soliloquy=XPID+"ConvexHull::getDecompositionPhases():";
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    if(point.m_is_on_hull){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No decomposition coefficients for hull members");}
    uint i_facet=AUROSTD_MAX_UINT;
    //polymorph possibility, other reductions in dimensionality are prescribed with the coefficients
    uint i_coord_group=AUROSTD_MAX_UINT;
    bool found_coord_group=getCoordGroupIndex(point,i_coord_group);
    if(found_coord_group){  //composition has already been considered by hull, might be g-state
      if(m_coord_groups[i_coord_group].m_is_on_hull){
        vector<uint> dcomp_phases;
        dcomp_phases.push_back(m_coord_groups[i_coord_group].m_ref_state);
        return dcomp_phases;
      }
      i_facet=m_coord_groups[i_coord_group].m_nearest_facet;
    }
    vector<uint> i_facets=m_i_facets;  //default, most broad  //make a copy so we can reset if m_has_stoich_coords, don't worry, only vector<uint> (pointers essentially)
    if(m_has_stoich_coords){
      uint i_nary,i_alloy;
      if(!getAlloyIndex(point,i_nary,i_alloy)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Cannot get alloys index");}
      i_facets=getRelevantFacets(i_nary,i_alloy);
    }
    if(!found_coord_group||(i_facet>m_facets.size()-1)){i_facet=getNearestFacetVertically(i_facets,point);}
    return extractDecompositionPhases(m_facets[i_facet]);
  }

  void ConvexHull::setDecompositionPhases(uint i_nary,uint i_alloy,uint i_coord_group){
    string soliloquy=XPID+"ConvexHull::setDecompositionPhases():";
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    if(i_coord_group>m_coord_groups.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(m_coord_groups[i_coord_group].m_nearest_facet>m_facets.size()-1){setNearestFacet(i_nary,i_alloy,i_coord_group);}

    if(m_coord_groups[i_coord_group].m_is_on_hull){
      if(!isViablePoint(m_coord_groups[i_coord_group].m_hull_member)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No hull member set for m_coord_group["+aurostd::utype2string(i_coord_group)+"]",_RUNTIME_ERROR_);}
      vector<uint> dcomp_phases;dcomp_phases.push_back(m_coord_groups[i_coord_group].m_hull_member);
      m_coord_groups[i_coord_group].m_decomp_phases=dcomp_phases;
      return;
    }

    uint i_facet=m_coord_groups[i_coord_group].m_nearest_facet;
    ChullFacet& facet=m_facets[i_facet];
    m_coord_groups[i_coord_group].m_decomp_phases=extractDecompositionPhases(facet);
  }

  xvector<double> ConvexHull::getDecompositionCoefficients(uint i_point,vector_reduction_type vred) const{
    string soliloquy=XPID+"ConvexHull::getDecompositionCoefficients():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    return getDecompositionCoefficients(m_points[i_point],vred);
  }

  xvector<double> ConvexHull::getDecompositionCoefficients(const ChullPoint& point,vector_reduction_type vred) const{
    string soliloquy=XPID+"ConvexHull::getDecompositionCoefficients():";
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    //[returns self]if(point.m_is_on_hull){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No decomposition coefficients for hull members");}
    uint i_coord_group=AUROSTD_MAX_UINT;
    bool found_coord_group=getCoordGroupIndex(point,i_coord_group);
    if(found_coord_group){  //composition has already been considered by hull, might be g-state
      if(m_coord_groups[i_coord_group].m_is_on_hull){
        xvector<double> dcomp_coefs(2);
        dcomp_coefs[dcomp_coefs.lrows]=dcomp_coefs[dcomp_coefs.lrows+1]=1.0;
        return dcomp_coefs;
      }
      if(m_coord_groups[i_coord_group].m_decomp_phases.size()){
        return getDecompositionCoefficients(point,m_coord_groups[i_coord_group].m_decomp_phases,vred);
      }
    }
    return getDecompositionCoefficients(point,getDecompositionPhases(point),vred);
  }

  xvector<double> ConvexHull::getDecompositionCoefficients(uint i_point,const vector<uint>& decomp_phases,vector_reduction_type vred) const{
    string soliloquy=XPID+"ConvexHull::getDecompositionCoefficients():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    return getDecompositionCoefficients(m_points[i_point],decomp_phases,vred);
  }

  xvector<double> ConvexHull::getDecompositionCoefficients(const ChullPoint& point,const vector<uint>& decomp_phases,vector_reduction_type vred) const{
    string soliloquy=XPID+"ConvexHull::getDecompositionCoefficients():";
    //do m_coords_group first (REDUCED)
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    if(!decomp_phases.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No decomposition phases found");}
    if(decomp_phases.size()==1){  //probably polymorph
      uint i_point_other=decomp_phases[0];
      if(!isViablePoint(i_point_other)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Index to decomposition phase not found");}
      const ChullPoint& point_other=m_points[i_point_other];
      uint i_coord_group=AUROSTD_MAX_UINT,i_coord_group_other=AUROSTD_MAX_UINT;
      bool found_coord_group=getCoordGroupIndex(point,i_coord_group);
      bool found_coord_group_other=getCoordGroupIndex(point_other,i_coord_group_other);
      if(found_coord_group&&found_coord_group_other&&i_coord_group==i_coord_group_other){ //definitely polymorph
        xvector<double> dcomp_coefs(2);
        dcomp_coefs[dcomp_coefs.lrows]=dcomp_coefs[dcomp_coefs.lrows+1]=1.0;
        return dcomp_coefs;
      }
      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Not enough decomposition phases provided");
    }
    vector<xvector<double> > lhs,rhs;
    //lhs
    lhs.push_back(point.getTruncatedReducedCoords(m_elements_present,vred));
    //rhs
    for(uint i=0,fl_size_i=decomp_phases.size();i<fl_size_i;i++){
      if(decomp_phases[i]>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
      if(!m_points[decomp_phases[i]].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
      rhs.push_back(m_points[decomp_phases[i]].getTruncatedReducedCoords(m_elements_present,vred));
    }
    xvector<double> coef=balanceChemicalEquation(lhs,rhs,true,ZERO_TOL);  //normalize
    //aurostd::shiftlrows(coef,0);
    return coef;
  }

  void ConvexHull::setDecompositionCoefficients(uint i_nary,uint i_alloy,uint i_coord_group){
    string soliloquy=XPID+"ConvexHull::setDecompositionCoefficients():";
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    if(i_coord_group>m_coord_groups.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(m_coord_groups[i_coord_group].m_decomp_phases.size()==0){setDecompositionPhases(i_nary,i_alloy,i_coord_group);}

    if(m_coord_groups[i_coord_group].m_is_on_hull){
      xvector<double> dcomp_coefs(2);
      dcomp_coefs[dcomp_coefs.lrows]=dcomp_coefs[dcomp_coefs.lrows+1]=1.0;
      m_coord_groups[i_coord_group].m_decomp_coefs=dcomp_coefs;
      return;
    }

    //we get different coefficients between stoich and composition
    //ALWAYS use composition (even POCC, simply won't reduce), and do NOT mix stoich + composition
    uint i_point=m_coord_groups[i_coord_group].m_points[0];
    if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
    vector<uint>& decomp_phases=m_coord_groups[i_coord_group].m_decomp_phases;
    m_coord_groups[i_coord_group].m_decomp_coefs=getDecompositionCoefficients(i_point,decomp_phases,frac_vrt);

    //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]//now do individual coefficients //[OBSOLETE - reduce by frac always], NO REDUCE
    //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
    //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]  i_point=m_coord_groups[i_coord_group].m_points[i];
    //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]  if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
    //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]  m_points[i_point].m_decomp_coefs=getDecompositionCoefficients(i_point,decomp_phases,frac_vrt);
    //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]}
  }

  void ConvexHull::setOffHullProperties(uint i_nary,uint i_alloy){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setOffHullProperties():";
    stringstream message;
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}

    message << "Gathering decomposition reaction data for";
    if(m_velements.size()){message << " " << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"-");}
    message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

    uint i_coord_group=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i<fl_size_i;i++){
      i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
      if(!m_coord_groups[i_coord_group].m_points.size()){continue;}
      if(!m_coord_groups[i_coord_group].m_initialized){continue;}
      if(m_coord_groups[i_coord_group].m_is_on_hull){continue;}
      if(LDEBUG) {cerr << soliloquy << " looking at i_coord_group=" << i_coord_group << endl;}
      //setNearestFacet(i_nary,i_alloy,i_coord_group);    //we now do separately and previously (setDistancesToHull())
      //setDistancesToHull(i_nary,i_alloy,i_coord_group); //we now do separately and previously (setDistancesToHull())
      setDecompositionPhases(i_nary,i_alloy,i_coord_group);
      setDecompositionCoefficients(i_nary,i_alloy,i_coord_group);
    }
  }

  vector<uint> ConvexHull::getAdjacentFacets(uint hull_member,bool ignore_hypercollinear,bool ignore_vertical,bool ignore_artificial) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getAdjacentFacets():";
    if(hull_member>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No hull member has been identified");}
    vector<uint> adjacent_i_facets;
    if(!m_points[hull_member].m_is_on_hull){return adjacent_i_facets;}

    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}

    uint i_nary=m_points[hull_member].m_i_nary;
    uint i_alloy=m_points[hull_member].m_i_alloy;
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    const vector<uint>& i_facets=getRelevantFacets(i_nary,i_alloy);//m_naries[i_nary].m_alloys[i_alloy].m_facets;
    uint i_facet;
    for(uint i=0,fl_size_i=i_facets.size();i<fl_size_i;i++){
      i_facet=i_facets[i];
      if(i_facet>m_facets.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_facets");}
      if(ignore_hypercollinear && m_facets[i_facet].m_hypercollinear){continue;}  //really (d-1) facets
      if(ignore_vertical && m_facets[i_facet].m_is_vertical){continue;}           //really (d-1) facets
      if(ignore_artificial && m_facets[i_facet].m_is_artificial){continue;}       //contains all unaries
      if(m_facets[i_facet].isPointOnFacet(hull_member)){adjacent_i_facets.push_back(i_facet);}
    }
    if(adjacent_i_facets.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No adjacent facets found");}
    if(LDEBUG) {cerr << soliloquy << " stop" << endl;}
    return adjacent_i_facets;
  }

  vector<vector<uint> > ConvexHull::getEquilibriumPhases(uint hull_member) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getEquilibriumPhases():";
    if(hull_member>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    const ChullPoint& point=m_points[hull_member];
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    if(!point.m_is_on_hull){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No equilibrium phases for non hull members");}
    vector<vector<uint> > equilibrium_phases;

    vector<uint> adjacent_i_facets=getAdjacentFacets(hull_member,true,true,true);
    //make full copy of relevant facets so we can sort accordingly, ignore vertical and artificial facets
    vector<ChullFacet> adjacent_facets;
    for(uint i=0,fl_size_i=adjacent_i_facets.size();i<fl_size_i;i++){adjacent_facets.push_back(m_facets[adjacent_i_facets[i]]);}

    //sort
    for(uint i_facet=0,fl_size_i_facet=adjacent_facets.size();i_facet<fl_size_i_facet;i_facet++){
      std::sort(adjacent_facets[i_facet].m_vertices.begin(),adjacent_facets[i_facet].m_vertices.end(),
          sortThermoPoints(false,true)); //stoich sorting should be descending, energy sorting default okay here
    }
    std::sort(adjacent_facets.begin(),adjacent_facets.end(),
        sortFacetsByPoints(m_points,false,false,false,false));  //not auto sort, sort everything descending

    uint i_point=AUROSTD_MAX_UINT;
    for(uint i_facet=0,fl_size_i_facet=adjacent_facets.size();i_facet<fl_size_i_facet;i_facet++){
      if(LDEBUG) {cerr << soliloquy << " found new relevant facet[" << i_facet << "] with points: ";}
      equilibrium_phases.push_back(vector<uint>(0));
      for(uint i=0,fl_size_i=adjacent_facets[i_facet].m_vertices.size();i<fl_size_i;i++){
        i_point=adjacent_facets[i_facet].m_vertices[i].ch_index;
        equilibrium_phases.back().push_back(i_point);
        if(LDEBUG) {cerr << m_points[i_point].h_coords << " [" << i_point << "]" << (i!=adjacent_facets[i_facet].m_vertices.size()-1?", ":"");}
      }
      if(LDEBUG) {cerr << endl;}
    }
    return equilibrium_phases;
  }

  void ConvexHull::setEquilibriumPhases(uint i_nary,uint i_alloy,uint i_coord_group){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setEquilibriumPhases():";
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    if(i_coord_group>m_coord_groups.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(!m_coord_groups[i_coord_group].m_is_on_hull){return;}
    if(m_coord_groups[i_coord_group].m_points.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}

    //get hull-member and check that it's correct
    uint hull_member=m_coord_groups[i_coord_group].m_hull_member;
    if(hull_member>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No hull member has been identified");}
    if(!m_points[hull_member].m_is_on_hull){return;}
    if(m_points[hull_member].isUnary()){return;} //others are in equilibrium with it, must be context of mixture!

    if(LDEBUG) {cerr << soliloquy << " looking at hull-member[" << hull_member << "]=" << m_points[hull_member].h_coords << endl;}

    m_coord_groups[i_coord_group].m_equilibrium_phases=getEquilibriumPhases(hull_member);

    if(LDEBUG) {cerr << soliloquy << " stop" << endl;}
  }

  bool ConvexHull::phasesEquivalent(uint i_point1,uint i_point2,bool perform_structure_comparison) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::phasesEquivalent():";
    if(i_point1>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    if(i_point2>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    if(!m_points[i_point1].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point1)+"] is not initialized");}
    if(!m_points[i_point2].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point2)+"] is not initialized");}

    if(i_point1==i_point2){return true;} //it is equivalent to self, so we only do checks if necessary

    //return false early for points without an entry
    if(!m_points[i_point1].m_has_entry){return false;}
    if(!m_points[i_point2].m_has_entry){return false;}

    if(LDEBUG) {cerr << soliloquy << " comparing [auid=" << m_points[i_point1].m_entry.auid << "] and [auid=" << m_points[i_point2].m_entry.auid << "]" << endl;}

    //strict==false, there might be entries in the database without a formation_enthalpy or sg calculated
    //ultimately, we want to compare structures
    if(energiesDiffer(i_point1,i_point2,false)){return false;} //first filter by those with wildly different energies, not strict
    if(spacegroupsDiffer(i_point1,i_point2,false)){return false;} //first filter by those with wildly different spacegroups, not strict
    if(!perform_structure_comparison){return false;}  //only return true if you can compare structures
    if(!structuresEquivalent(i_point1,i_point2)){return false;}

    return true;
  }

  //strict === strictly differ
  //if we don't know, because of AUROSTD_NAN's or NOSG's, we may still return false anyway to 
  //continue on to more strict determination later
  bool ConvexHull::energiesDiffer(uint i_point1,uint i_point2,bool strict) const{
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::energiesDiffer():";
    if(i_point1>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    if(i_point2>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}

    if(i_point1==i_point2){return false;}
    if(!m_points[i_point1].m_has_entry){return strict;}  //if strict, then return that they do differ (true)
    if(!m_points[i_point2].m_has_entry){return strict;}  //if strict, then return that they do differ (true)

    const double& energy1=m_points[i_point1].getFormationEnthalpy();
    const double& energy2=m_points[i_point2].getFormationEnthalpy();
    if(LDEBUG) {cerr << soliloquy << energy1 << " vs. " << energy2 << endl;}
    if(energy1>=AUROSTD_NAN || energy2>=AUROSTD_NAN){return strict;} //if strict, then return that they do differ (true)

    bool differs=aurostd::isdifferent(energy1,energy2,ENERGY_TOL);
    if(LDEBUG) {cerr << soliloquy << " energies do " << (differs?"":"NOT ") << "differ" << endl;}
    return differs;
  }

  //strict === strictly differ
  //if we don't know, because of AUROSTD_NAN's or NOSG's, we may still return false anyway to 
  //continue on to more strict determination later
  bool ConvexHull::spacegroupsDiffer(uint i_point1,uint i_point2,bool strict) const{
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::spacegroupsDiffer():";
    if(i_point1>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    if(i_point2>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}

    if(i_point1==i_point2){return false;}
    if(!m_points[i_point1].m_has_entry){return strict;}  //if strict, then return that they do differ (true)
    if(!m_points[i_point2].m_has_entry){return strict;}  //if strict, then return that they do differ (true)

    const string& sg1=m_points[i_point1].getSG();
    const string& sg2=m_points[i_point2].getSG();
    if(LDEBUG) {cerr << soliloquy << sg1 << " vs. " << sg2 << endl;}
    if(sg1==NOSG || sg2==NOSG){return strict;}  //if strict, then return that they do differ (true)

    bool differs=(sg1!=sg2);
    if(LDEBUG) {cerr << soliloquy << " spacegroups do " << (differs?"":"NOT ") << "differ" << endl;}
    return differs;
  }

  bool ConvexHull::structuresEquivalent(uint i_point1,uint i_point2) const{
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::structuresEquivalent():";
    if(i_point1>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    if(i_point2>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}

    if(i_point1==i_point2){return true;}
    //we will not be so stringent on throwing errors here, if we cannot find/load structure, simply return false
    if(!m_points[i_point1].m_has_entry){return false;}
    if(!m_points[i_point2].m_has_entry){return false;}

    xstructure a,b;
    if(!m_points[i_point1].getMostRelaxedXstructure(a)){return false;}
    if(!m_points[i_point2].getMostRelaxedXstructure(b)){return false;}
    //if(!m_points[i_point1].loadXstructures(true)){return false;}
    //if(!m_points[i_point2].loadXstructures(true)){return false;}

    //const xstructure& a=m_points[i_point1].m_entry.vstr[0];
    //const xstructure& b=m_points[i_point2].m_entry.vstr[0];
    if(LDEBUG) {
      cerr << soliloquy << " loaded both structures" << endl;
      cerr << soliloquy << " structure 1" << endl;
      cerr << a;
      cerr << soliloquy << " structure 2" << endl;
      cerr << b;
    }
    bool are_equivalent=compare::structuresMatch(a,b,true,false,false); //match species and use fast match, but not scale volume, two structures with different volumes (pressures) are different! //DX20180123 - added fast_match = true //DX20190318 - not fast_match but optimized_match=false
    if(LDEBUG) {cerr << soliloquy << " structures are " << (are_equivalent?"":"NOT ") << "equivalent" << endl;}
    return are_equivalent;
  }

  vector<uint> ConvexHull::getEquivalentGStates(uint g_state) const{
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getEquivalentGStates():";
    if(g_state>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    const ChullPoint& point=m_points[g_state];
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    if(!point.m_is_g_state){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No equivalent g-states for non ground-state structures");}
    uint i_coord_group=AUROSTD_MAX_UINT;
    if(!getCoordGroupIndex(point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
    if(!m_coord_groups[i_coord_group].m_is_on_hull){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup is not on the hull");}
    bool perform_structure_comparison=(1&&(!m_cflags.flag("CHULL::SKIP_STRUCTURE_COMPARISON"))); //(1&&!(m_cflags.flag("CHULL::SKIP_STRUCTURE_COMPARISON")||(!m_cflags.flag("CHULL::MULTI_OUTPUT")&&m_cflags.flag("CHULL::LATEX_DOC")&&m_cflags.flag("CHULL::IMAGE_ONLY"))));

    vector<uint> equivalent_g_states;

    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
      i_point=m_coord_groups[i_coord_group].m_points[i];
      if(!phasesEquivalent(g_state,i_point,perform_structure_comparison)){continue;}
      equivalent_g_states.push_back(i_point);
    }
    if(LDEBUG) {
      cerr << soliloquy << " g-state[" << g_state << "]=" << m_points[g_state].h_coords;
      cerr << " equivalent structures=";
      for(uint i=0,fl_size_i=equivalent_g_states.size();i<fl_size_i;i++){cerr << equivalent_g_states[i] << (i!=equivalent_g_states.size()-1?", ":"");}
      cerr << endl;
    }
    return equivalent_g_states;
  }

  bool ConvexHull::isICSD(uint i_point) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::isICSD():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    string point_icsd_number=getICSDNumber(i_point,true);
    if(LDEBUG) {cerr << soliloquy << " looking for icsd_number=" << point_icsd_number << endl;}
    if(point_icsd_number.empty()){return false;}  //no possible match
    if(m_icsd_entries.size()==0){return false;} //no possible match
    string entry_icsd_number;
    for(uint i=0,fl_size_i=m_icsd_entries.size();i<fl_size_i;i++){
      if(i_point==m_icsd_entries[i]){return true;} //instant match
      entry_icsd_number=getICSDNumber(m_icsd_entries[i],true);
      if(LDEBUG) {cerr << soliloquy << " comparing with entry_icsd_number=" << entry_icsd_number << endl;}
      if(entry_icsd_number.empty()){continue;}  //this is weird/bad, but let's not exit the whole program
      //we need to get the STRING number (may have 0's in the front) and species/stoichiometry equivalent
      //this can be done by looking at elements_present, since they map to species
      if(point_icsd_number==entry_icsd_number && m_points[i_point].m_elements_present==m_points[m_icsd_entries[i]].m_elements_present){
        if(LDEBUG) {
          cerr << soliloquy << " found match: point[i_point=" << i_point << "].prototype=" << m_points[i_point].m_entry.prototype;
          cerr << " vs. point[i_point=" << m_icsd_entries[i] << "].prototype=" << m_points[m_icsd_entries[i]].m_entry.prototype << endl;
        }
        return true;
      }
    }
    return false;
  }

  void ConvexHull::setEquivalentGStates(uint i_nary,uint i_alloy,uint i_coord_group){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setEquivalentGStates():";
    m_coord_groups[i_coord_group].m_equivalent_g_states.clear();
    m_coord_groups[i_coord_group].m_calculated_equivalent_g_states=false;
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    if(i_coord_group>m_coord_groups.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(!m_coord_groups[i_coord_group].m_is_on_hull){return;}
    if(m_coord_groups[i_coord_group].m_points.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}

    //we need to do a structure comparison, so get artificial map (did already before)
    uint g_state=m_coord_groups[i_coord_group].m_ref_state;
    if(g_state>m_points.size()-1){return;}
    if(!m_points[g_state].m_has_entry){return;} //throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No entry (structure) found"); //only point in coordgroup

    if(LDEBUG) {cerr << soliloquy << " looking at g-state[" << g_state << "]=" << m_points[g_state].h_coords << endl;}
    m_coord_groups[i_coord_group].m_equivalent_g_states=getEquivalentGStates(g_state);
    if(!m_coord_groups[i_coord_group].m_equivalent_g_states.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No equivalent states found (not even self)");}
    m_coord_groups[i_coord_group].m_calculated_equivalent_g_states=true;
    uint i_point=AUROSTD_MAX_UINT;
    bool icsd_g_state,_icsd_g_state;              //whether icsd exists among g_states
    uint i_canonical_icsd=AUROSTD_MAX_UINT;       //index of canonical icsd
    uint canonical_icsd_number=AUROSTD_MAX_UINT;  //lowest number
    uint icsd_number;
    icsd_g_state=false;
    for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_equivalent_g_states.size();i<fl_size_i;i++){
      i_point=m_coord_groups[i_coord_group].m_equivalent_g_states[i];
      if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
      m_points[i_point].m_is_equivalent_g_state=true; //g_state and equivalent_g_state should stay separate
      //get icsd information
      //we were strict in creating m_icsd_entries (only _ICSD_), but we need to check LIBs for ICSD_
      if(aurostd::substring2bool(m_points[i_point].m_entry.prototype,"ICSD_")){  //remember, _ICSD_ means icsd catalog, but ICSD_ means LIBs
        _icsd_g_state=isICSD(i_point);
        icsd_g_state|=_icsd_g_state;
        if(_icsd_g_state){  //find lowest icsd number
          icsd_number=aurostd::string2utype<uint>(getICSDNumber(i_point,true));
          if(icsd_number<canonical_icsd_number){
            i_canonical_icsd=i_point;
            canonical_icsd_number=icsd_number;
          }
        }
        //aurostd::string2tokens(m_points[i_point].m_entry.prototype,tokens,"_");
        //if(tokens.size()==3){ //skip everything else
        //  icsd_number=aurostd::string2utype<uint>(tokens[2]);
        //  if(icsd_number<canonical_icsd_number){
        //    i_canonical_icsd=i_point;
        //    canonical_icsd_number=icsd_number;
        //  }
        //}
      }
    }

    m_coord_groups[i_coord_group].m_icsd_g_state=icsd_g_state;
    m_coord_groups[i_coord_group].m_i_canonical_icsd=i_canonical_icsd;

    if(LDEBUG) {cerr << soliloquy << " stop" << endl;}
  }

  vector<uint> ConvexHull::getSymEquivalentGStates(uint g_state) const{
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getSymEquivalentGStates():";
    if(g_state>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    const ChullPoint& point=m_points[g_state];
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    if(!point.m_is_g_state){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No equivalent g-states for non ground-state structures");}
    uint i_coord_group=AUROSTD_MAX_UINT;
    if(!getCoordGroupIndex(point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}

    vector<uint> sym_equivalent_g_states;

    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
      i_point=m_coord_groups[i_coord_group].m_points[i];
      if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
      if(g_state!=i_point){if(spacegroupsDiffer(g_state,i_point,true)){continue;}}
      sym_equivalent_g_states.push_back(i_point);
    }
    if(LDEBUG) {
      cerr << soliloquy << " g-state[" << g_state << "]=" << m_points[g_state].h_coords;
      cerr << " symmetrically equivalent structures=";
      for(uint i=0,fl_size_i=sym_equivalent_g_states.size();i<fl_size_i;i++){cerr << sym_equivalent_g_states[i] << (i!=sym_equivalent_g_states.size()-1?", ":"");}
      cerr << endl;
    }
    return sym_equivalent_g_states;
  }

  void ConvexHull::setSymEquivalentGStates(uint i_nary,uint i_alloy,uint i_coord_group){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setSymEquivalentGStates():";
    m_coord_groups[i_coord_group].m_sym_equivalent_g_states.clear();
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}
    if(i_coord_group>m_coord_groups.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within coordgroups");}
    if(!m_coord_groups[i_coord_group].m_is_on_hull){return;}
    if(m_coord_groups[i_coord_group].m_points.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] has no points");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}

    //we need to do a structure comparison, so get artificial map (did already before)
    uint g_state=m_coord_groups[i_coord_group].m_ref_state;
    if(g_state>m_points.size()-1){return;}
    if(!m_points[g_state].m_has_entry){return;} //throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No entry (structure) found"); //only point in coordgroup

    if(LDEBUG) {cerr << soliloquy << " looking at g-state[" << g_state << "]=" << m_points[g_state].h_coords << endl;}
    m_coord_groups[i_coord_group].m_sym_equivalent_g_states=getSymEquivalentGStates(g_state);
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_sym_equivalent_g_states.size();i<fl_size_i;i++){
      i_point=m_coord_groups[i_coord_group].m_sym_equivalent_g_states[i];
      if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
      m_points[i_point].m_is_sym_equivalent_g_state=true; //g_state and sym_equivalent_g_state should stay separate
    }
    if(LDEBUG) {cerr << soliloquy << " stop" << endl;}
  }

  void ConvexHull::setOnHullProperties(uint i_nary,uint i_alloy){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setOnHullProperties():";
    stringstream message;
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}

    message << "Gathering equilibrium phases and determining equivalent ground-states for";
    if(m_velements.size()){message << " " << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"-");}
    message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
    message << ", please be patient";
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

    uint i_coord_group=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i<fl_size_i;i++){
      i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
      if(!m_coord_groups[i_coord_group].m_points.size()){continue;}
      if(!m_coord_groups[i_coord_group].m_initialized){continue;}
      if(!m_coord_groups[i_coord_group].m_is_on_hull){continue;}
      if(LDEBUG) {cerr << soliloquy << " looking at i_coord_group=" << i_coord_group << endl;}
      //setDistancesToHull(i_nary,i_alloy,i_coord_group); //we now do separately and previously (setDistancesToHull())
      //very important that you do not simply go through all facet points and find equilibrium points
      //this will overwrite binary information with ternary information
      //proceed safely with i_coord_group's
      setDecompositionPhases(i_nary,i_alloy,i_coord_group);
      setDecompositionCoefficients(i_nary,i_alloy,i_coord_group);
      setEquilibriumPhases(i_nary,i_alloy,i_coord_group);
      setSymEquivalentGStates(i_nary,i_alloy,i_coord_group);
      setEquivalentGStates(i_nary,i_alloy,i_coord_group);
    }
  }

  void ConvexHull::storeHullData(uint i_nary,uint i_alloy){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::storeHullData():";
    stringstream message;
    if(!h_facets.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull has yet to be calculated");}
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}

    m_naries[i_nary].m_alloys[i_alloy].m_facets.clear();
    for(uint i=0,fl_size_i=h_facets.size();i<fl_size_i;i++){
      m_facets.push_back(h_facets[i]);
      m_naries[i_nary].m_alloys[i_alloy].m_facets.push_back(m_facets.size()-1);
    }
    setHullMembers(i_nary,i_alloy);
    if(LDEBUG) {
      cerr << soliloquy << " hull points for i_nary=" << i_nary << ",i_alloy=" << i_alloy << endl;
      for(uint i=0,fl_size_i=m_points.size();i<fl_size_i;i++){
        if(m_points[i].m_is_on_hull){
          cerr << soliloquy << " hull_point[" << i << "].m_coords=" << m_points[i].m_coords << endl;
        }
      }
    }
    message << "Hull properties stored for";
    if(m_velements.size()){message << " " << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"-");}
    message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
  }

  void ConvexHull::storeHullData() {
    for(uint i=0,fl_size_i=h_facets.size();i<fl_size_i;i++){
      m_facets.push_back(h_facets[i]);
      m_i_facets.push_back(m_facets.size()-1);
    }
    setHullMembers();
  }

  void ConvexHull::extractThermodynamicProperties(uint i_nary,uint i_alloy){
    string soliloquy=XPID+"ConvexHull::extractThermodynamicProperties():";
    stringstream message;
    if(!h_facets.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull has yet to be calculated");}
    if(!m_has_stoich_coords){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Non-stoich coordinates");}
    if(i_nary>m_naries.size()-1 || i_alloy>m_naries[i_nary].m_alloys.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within m_naries");}
    if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary");}
    if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized alloy");}

    bool perform_thermo_properties_extraction=(1 && 
        thermoPropertiesExtractionRequired() && 
        (!m_cflags.flag("CHULL::SKIP_HULL_DISTANCE_CALCULATION")) &&
        (!m_cflags.flag("CHULL::SKIP_THERMO_PROPERTIES_EXTRACTION")) &&
        TRUE); //(1&&!(m_cflags.flag("CHULL::SKIP_THERMO_PROPERTIES_EXTRACTION")||(!m_cflags.flag("CHULL::MULTI_OUTPUT")&&m_cflags.flag("CHULL::LATEX_DOC")&&m_cflags.flag("CHULL::IMAGE_ONLY"))));
    if(!perform_thermo_properties_extraction){return;}
    if(!m_thermo_hull){
      message << "Cannot extract thermodynamic properties, thermodynamic hull NOT detected";
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
      return;
    }

    message << "Thermodynamic hull detected, gathering on/off hull properties for";
    if(m_velements.size()){message << " " << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"-");}
    message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
    if(i_nary==0){message << " (last)";}
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
    setOffHullProperties(i_nary,i_alloy);
    setOnHullProperties(i_nary,i_alloy);

    message << "Thermodynamic properties calculated for";
    if(m_velements.size()){message << " " << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"-");}
    message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
  }

  void ConvexHull::thermodynamicsPostProcessing(){
    //hull must be initialized for these analyses
    string soliloquy=XPID+"ConvexHull::thermodynamicsPostProcessing():";
    stringstream message;
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    if(!m_thermo_hull){return;}

    //do not perform thermodynamics postprocessing without having done extractThermodynamicProperties
    //we need equivalent g_states (setOnHullProperties())
    bool perform_thermo_post_processing=(1 &&
        thermoPostProcessingExtractionRequired() &&
        (!m_cflags.flag("CHULL::SKIP_HULL_DISTANCE_CALCULATION")) &&
        (!m_cflags.flag("CHULL::SKIP_THERMO_PROPERTIES_EXTRACTION")) &&
        (!m_cflags.flag("CHULL::SKIP_THERMO_POST_PROCESSING")) &&
        TRUE); //(1&&!(m_cflags.flag("CHULL::SKIP_THERMO_PROPERTIES_EXTRACTION")||(!m_cflags.flag("CHULL::MULTI_OUTPUT")&&m_cflags.flag("CHULL::LATEX_DOC")&&m_cflags.flag("CHULL::IMAGE_ONLY"))));
    if(!perform_thermo_post_processing){return;}

    message << "Performing thermodynamics post-processing";
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

    bool perform_stability_criterion=(1&&(!m_cflags.flag("CHULL::SKIP_STABILITY_CRITERION_ANALYSIS"))); //(1&&!(m_cflags.flag("CHULL::SKIP_STABILITY_CRITERION_ANALYSIS")||(!m_cflags.flag("CHULL::MULTI_OUTPUT")&&m_cflags.flag("CHULL::LATEX_DOC")&&m_cflags.flag("CHULL::IMAGE_ONLY"))));
    if(perform_stability_criterion){setStabilityCriterion();}

    bool perform_n_plus_1_enthalpy_gain=(1&&(!m_cflags.flag("CHULL::SKIP_N+1_ENTHALPY_GAIN_ANALYSIS"))); //(1&&!(m_cflags.flag("CHULL::SKIP_N+1_ENTHALPY_GAIN_ANALYSIS")||(!m_cflags.flag("CHULL::MULTI_OUTPUT")&&m_cflags.flag("CHULL::LATEX_DOC")&&m_cflags.flag("CHULL::IMAGE_ONLY"))));
    if(perform_n_plus_1_enthalpy_gain){setNPlus1EnthalpyGain();}

    return;
  }

  void ConvexHull::calculate(){
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    stringstream message;
    string soliloquy=XPID+"ConvexHull::calculate():";

    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        m_points[m_coord_groups[i_coord_group].m_points[i]].m_is_on_hull=false; //completely refresh
      }
      m_coord_groups[i_coord_group].m_is_on_hull=false; //completely refresh
    }

    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}
    //we first run through alloy hulls IF stoich_coords, grabbing hull_members
    if(m_has_stoich_coords){
      if(!m_naries.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Points have yet to be structured");}
      bool calc_highest_hull_only=m_cflags.flag("CHULL::CALCULATE_HIGHEST_DIMENSION_ONLY");
      uint i_nary_start=1;  //start at binaries
      if(calc_highest_hull_only){
        i_nary_start=m_naries.size()-1;
        message << "Calculating the highest dimensional hull ONLY (stoichiometric coordinates)";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
      }else{
        message << "Calculating the hull(s) in increasing dimensionality (stoichiometric coordinates)";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
      }
      for(uint i_nary=i_nary_start,fl_size_i_nary=m_naries.size();i_nary<fl_size_i_nary;i_nary++){
        for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
          message << "Calculating " << pflow::arity_string(i_nary+1,false,false) << " hull for";
          if(m_velements.size()){message << " " << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"-");}
          message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
          cleanHull();
          setElementsPresent(i_nary,i_alloy); //m_has_stoich_coords only
          if(calc_highest_hull_only){
            preparePointsForHullCalculation();  //inject all points
          }else{
            preparePointsForHullCalculation(i_nary,i_alloy);  //will have unary duplicates, but don't worry, we remove in calculateFacets()
          }
          calculateFacets();
          message << pflow::arity_string(i_nary+1,true,false) << " hull calculated for";
          if(m_velements.size()){message << " " << aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"-");}
          message << " [i_nary=" << i_nary <<",i_alloy=" << i_alloy << "]";
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
          storeHullData(i_nary,i_alloy);
          setDistancesToHull(i_nary,i_alloy); //do this always
          if(m_thermo_hull){extractThermodynamicProperties(i_nary,i_alloy);}
        }
      }
      //set unary properties last
      //sort of a hack, but actually an intelligent solution
      //unary hull-members will be identified in higher dimensions
      //therefore, we simply need to calculate their properties
      for(uint i_alloy=0,fl_size_i_alloy=m_naries[0].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){setDistancesToHull(0,i_alloy);} //do this always
      if(m_thermo_hull){  //very safe, not sure how these algorithms perform outside of this domain, already know we have m_has_stoich_coords
        //message << "Calculating thermodynamic properties for " << pflow::arity_string(1,false,true) << " (last)";
        //pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
        for(uint i_alloy=0,fl_size_i_alloy=m_naries[0].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){extractThermodynamicProperties(0,i_alloy);} //knows to skip facet storage //setOnHullProperties(0,i_alloy);
      }
      //print counts of g_states by dimension
      uint gstate_count=0,total_gstate_count=0;
      for(uint i_nary=0,fl_size_i_nary=m_naries.size();i_nary<fl_size_i_nary;i_nary++){
        gstate_count=getGStateCount(i_nary);
        message << "Found " << gstate_count << " " << pflow::arity_string(i_nary+1,false,false) << " ";
        if(m_thermo_hull){message << "ground-state phases";}
        else {message << "points on the hull";}
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
        total_gstate_count+=gstate_count;
      }
      message << "Found " << total_gstate_count << " ";
      if(m_thermo_hull){message << "ground-state phases";}
      else {message << "points on the hull";}
      message << " total";
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
    } else {
      message << "Entering default convex hull calculation (full-dimensional)";
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
      cleanHull();
      preparePointsForHullCalculation();
      calculateFacets();
      message << "Hull calculated";
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
      //print count of gstates (hull points)
      for(uint i_nary=0,fl_size_i_nary=m_naries.size();i_nary<fl_size_i_nary;i_nary++){
        message << "Found " << getGStateCount() << " points on the hull total";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
      }
    }
    storeHullData();  //that way, the largest dim facets get stored in m_facets!

    //resort within coord_groups to expose hull-members!
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      std::sort(m_coord_groups[i_coord_group].m_points.begin(),m_coord_groups[i_coord_group].m_points.end(),sortWithinCoordGroup(m_points,m_sort_energy_ascending));  //ascending order
    }
    if(LDEBUG) {cerr << soliloquy << " done" << endl;}
  }

  double ConvexHull::getStabilityCriterion(const string& cauid) const {
    string soliloquy=XPID+"ConvexHull::getStabilityCriterion():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    vector<string> vcauid; vcauid.push_back(cauid);
    vector<double> vsc=getStabilityCriterion(vcauid);
    return vsc[0];
  }

  double ConvexHull::getStabilityCriterion(uint cpoint) const {
    string soliloquy=XPID+"ConvexHull::getStabilityCriterion():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    if(cpoint>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    vector<uint> vcpoints; vcpoints.push_back(cpoint);
    vector<double> vsc=getStabilityCriterion(vcpoints);
    return vsc[0];
  }

  vector<double> ConvexHull::getStabilityCriterion(const vector<string>& vcauid) const {
    string soliloquy=XPID+"ConvexHull::getStabilityCriterion():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    stringstream message;

    uint i_point=AUROSTD_MAX_UINT;
    vector<uint> vcpoints; //follows vcauid
    for(uint i=0,fl_size_i=vcauid.size();i<fl_size_i;i++){
      const string& auid=vcauid[i];
      if(auid.empty()){message << "Empty auid found";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      if(!findPoint(auid,i_point)){message << "Specified auid not found on hull (auid=" << auid << ")";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      vcpoints.push_back(i_point);
    }
    return getStabilityCriterion(vcpoints);
  }

  vector<double> ConvexHull::getStabilityCriterion(const vector<uint>& vcpoints) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getStabilityCriterion():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    stringstream message;

    //set fake_hull
    xvector<int> elements_present_points=getElementsPresent(vcpoints);
    xvector<int> elements_present_hull=elements_present_points;
    if(sum(elements_present_hull)==1){
      //pick ANY other index to be 1 as well
      if(elements_present_hull[elements_present_hull.lrows]==0){elements_present_hull[elements_present_hull.lrows]=1;}
      else{
        if(elements_present_hull.rows<2){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"elements_present.rows<2",_INPUT_ILLEGAL_);} //we cannot have unary hulls as input (facets issue)
        if(elements_present_hull[elements_present_hull.lrows+1]==1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"elements_present mismatch for unary hull",_INDEX_MISMATCH_);}
        elements_present_hull[elements_present_hull.lrows+1]=1;
      }
    }
    if(sum(elements_present_hull)==1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Could not fix sum(elements_present_hull)==1",_RUNTIME_ERROR_);}
    ConvexHull fake_hull;
    getFakeHull(vcpoints,elements_present_hull,elements_present_points,fake_hull);

    //since i_nary and i_alloy don't change, the getDistanceToHull function should work fine (getRelevantFacets())
    vector<double> vscriterion;
    ChullPoint point;
    uint i_point=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=vcpoints.size();i<fl_size_i;i++) {
      i_point=vcpoints[i];
      //already checked validity of these points
      point=m_points[i_point];
      point.cleanPointForHullTransfer();  //clean now
      point.reduceCoords(elements_present_hull);  //reduce to minimum hull necessary to calculate scriterion (for unaries this will be a binary)
      point.setHullCoords(); //set to most general coords (m_coords), this reflects relevantFacets()
      //we need to clean this point of any properties relevant to REAL hull (not to be confused with fake hull)
      //clean first, then set h_coords
      //in the case that it is not a unary, leverage i_alloy of REAL hull first, then clean
      //if(point.isUnary()){
      //  point.setHullCoords(); //set to most general coords (m_coords), this reflects relevantFacets()
      //} else {
      //  if(!getAlloyIndex(point,i_nary,i_alloy)){message << "Alloy index not set (auid=" << point.m_entry.auid << ")";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      //  xvector<int> elements_present=m_naries[i_nary].m_alloys[i_alloy].m_elements_present;
      //  if(LDEBUG) {cerr << soliloquy << " elements_present=" << elements_present << endl;}
      //  point.setHullCoords(elements_present);  //just to be sure
      //}
      if(LDEBUG) {cerr << soliloquy << " m.coords=" << point.m_coords << endl;}
      if(LDEBUG) {cerr << soliloquy << " h.coords=" << point.h_coords << endl;}
      vscriterion.push_back(fake_hull.getDistanceToHull(point,false));
    }
    return vscriterion;
  }

  void ConvexHull::getFakeHull(const vector<uint>& vcpoints,ConvexHull& fake_hull) const {
    string soliloquy=XPID+"ConvexHull::getFakeHull():";
    if(!m_points.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No points loaded, no way to determine dimensionality of hull");}
    xvector<int> elements_present=aurostd::ones_xv<int>(m_points[0].m_coords.lrows,m_points[0].m_coords.lrows+(int)getDim()-1);
    return getFakeHull(vcpoints,elements_present,elements_present,fake_hull);
  }
  void ConvexHull::getFakeHull(const vector<uint>& vcpoints,const xvector<int>& elements_present,ConvexHull& fake_hull) const {
    return getFakeHull(vcpoints,elements_present,elements_present,fake_hull);
  }
  void ConvexHull::getFakeHull(const vector<uint>& vcpoints,const xvector<int>& elements_present_hull,const xvector<int>& elements_present_points,ConvexHull& fake_hull) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getFakeHull():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    stringstream message;

    //get full set of points to neglect
    uint i_point=AUROSTD_MAX_UINT,i_coord_group=AUROSTD_MAX_UINT,g_state=AUROSTD_MAX_UINT;

    if(LDEBUG) {cerr << soliloquy << " initial points_to_neglect.size()=" << vcpoints.size() << endl;}

    //vector<ChullPoint> points_to_neglect; //not sure why it needs to be vector of chullpoints, simply hold indices
    vector<uint> points_to_neglect;
    vector<uint> eq_gstates;
    for(uint i=0,fl_size_i=vcpoints.size();i<fl_size_i;i++){
      i_point=vcpoints[i];
      if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
      const ChullPoint& point=m_points[i_point];  //this point may not be on the hull, it may be an equivalent structure, but coordgroup is
      if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized chullpoint");}
      if(!getCoordGroupIndex(point,i_coord_group)){message << "Coordgroup index not set (input[" << i << "])";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
      if(!m_coord_groups[i_coord_group].m_points.size()){message << "No points found within coordgroup (input[" << i << "])";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      //if(!m_coord_groups[i_coord_group].m_is_on_hull){message << "Coordgroup not on the hull (input[" << i << "])";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);} //obsolete, now we don't assume coordgroup is on hull, we can remove ANY point
      points_to_neglect.push_back(i_point);
      if(m_coord_groups[i_coord_group].m_is_on_hull){
        g_state=m_coord_groups[i_coord_group].m_ref_state;  //we lose i_point here, so make sure to add it before this if-statement, otherwise we get SUPER degeneracy
        if(!m_points[g_state].m_is_g_state){message << "Coordgroup reference is not a ground-state structure (input[" << i << "])";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
        //const vector<uint>& eq_gstates=m_coord_groups[i_coord_group].m_equivalent_g_states;
        if(m_coord_groups[i_coord_group].m_calculated_equivalent_g_states){eq_gstates=m_coord_groups[i_coord_group].m_equivalent_g_states;}
        else {eq_gstates=getEquivalentGStates(g_state);}
        if(!eq_gstates.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No equivalent states found (not even self)");}
        //for(uint j=0,fl_size_j=eq_gstates.size();j<fl_size_j;j++){points_to_neglect.push_back(m_points[eq_gstates[j]]);}
        for(uint j=0,fl_size_j=eq_gstates.size();j<fl_size_j;j++){points_to_neglect.push_back(eq_gstates[j]);}
      }
    }

    std::sort(points_to_neglect.begin(),points_to_neglect.end());points_to_neglect.erase( std::unique( points_to_neglect.begin(), points_to_neglect.end() ), points_to_neglect.end() );  //first remove duplicate indices

    if(LDEBUG) {
      cerr << soliloquy << " points_to_neglect.size()=" << points_to_neglect.size() << endl;
      cerr << soliloquy << " points_to_neglect: ";
      for(uint i=0,fl_size_i=points_to_neglect.size();i<fl_size_i;i++){cerr << points_to_neglect[i] << " ";} 
      cerr << endl;
    }

    if(LDEBUG){
      cerr << soliloquy << " elements_present_hull=" << elements_present_hull << endl;
      cerr << soliloquy << " elements_present_points=" << elements_present_points << endl;
    }
    if(sum(elements_present_points)>sum(elements_present_hull)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"elements_present_hull must belong to bigger subspace than elements_present_points",_INPUT_ILLEGAL_);}

    //create new set of points
    //bool found=false;
    vector<ChullPoint> new_points;
    //do NOT go through m_points, this may include some duplicates we previously excluded (now not duplicates since we are removing points: AlFe hull)
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      if(LDEBUG){cerr << soliloquy << " m_coord_groups[i_coord_group=" << i_coord_group << "].getElementsPresent()=" << m_coord_groups[i_coord_group].getElementsPresent() << endl;}
      if(!subspaceBelongs(elements_present_points,m_coord_groups[i_coord_group].getElementsPresent())){
        if(LDEBUG) {cerr << soliloquy << " Ignoring irrelevant subspace of m_coord_groups[i_coord_group=" << i_coord_group << "] (m_coord_groups[i_coord_group=" << i_coord_group << "].getElementsPresent()=" << m_coord_groups[i_coord_group].getElementsPresent() << ")" << endl;}
        continue;
      }
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(aurostd::WithinList(points_to_neglect,i_point)){
          if(LDEBUG) {cerr << soliloquy << " Removing point from fake hull (i_point=" << i_point << ",auid=" << m_points[i_point].m_entry.auid << ")" << endl;}
          continue;
        }
        const ChullPoint& point=m_points[i_point];
        if(point.m_is_artificial){continue;}  //they will be added again
        //found=false;
        //for(uint j=0,fl_size_j=points_to_neglect.size();j<fl_size_j&&!found;j++){
        //  if(point.m_entry.auid==points_to_neglect[j].m_entry.auid){
        //    if(LDEBUG) {cerr << soliloquy << " Removing (equivalent) ground-state (auid=" << points_to_neglect[j].m_entry.auid << ")" << endl;}
        //    found=true;
        //  }
        //}
        //if(found){continue;}
        if(LDEBUG) {cerr << soliloquy << " including point[i_point=" << i_point << ",auid=" << m_points[i_point].m_entry.auid << "].compound=" << point.m_entry.compound << endl;}
        new_points.push_back(point);
        new_points.back().reduceCoords(elements_present_hull);
        if(LDEBUG) {cerr << soliloquy << " point[" << i_point << "].m_coords=" << new_points.back().m_coords << endl;}
        new_points.back().cleanPointForHullTransfer();
      }
    }
    if(!new_points.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No points found for pseudo convex hull");}

    //patch m_velements to match reduceCoords(elements_present_hull)
    vector<string> velements;
    if(m_velements.size()>0){
      vector<uint> relevant_indices=getRelevantIndices(elements_present_hull);
      if(LDEBUG){cerr << soliloquy << " relevant_indices=" << aurostd::joinWDelimiter(relevant_indices,",") << endl;}
      for(uint i=0,fl_size_i=relevant_indices.size();i<fl_size_i;i++){velements.push_back(m_velements[relevant_indices[i]-1]);} //-1 because xvector->vecto
      if(LDEBUG){cerr << soliloquy << " velements=" << aurostd::joinWDelimiter(velements,",") << endl;}
    }

    if(LDEBUG) {cerr << soliloquy << " Creating new (pseudo) hull without relevant g-states" << endl;}
    aurostd::xoption cflags=m_cflags;
    //[do NOT do, we need hull distance calculation]cflags.flag("CHULL::SKIP_HULL_DISTANCE_CALCULATION",true);  //no need to get the distances for ALL points, we will do for the one after hull creation
    cflags.flag("CHULL::SKIP_THERMO_PROPERTIES_EXTRACTION",true); //thermo properties NOT needed, just need hull
    //[killed off by SKIP_THERMO_PROPERTIES_EXTRACTION]cflags.flag("CHULL::SKIP_STRUCTURE_COMPARISON",true);       //structure comparison is not needed for 1 hull point distance calculation
    //[killed off by SKIP_THERMO_PROPERTIES_EXTRACTION]cflags.flag("CHULL::SKIP_STABILITY_CRITERION_ANALYSIS",true); //this would be circular
    //[killed off by SKIP_THERMO_PROPERTIES_EXTRACTION]cflags.flag("CHULL::SKIP_N+1_ENTHALPY_GAIN_ANALYSIS",true); //this would be circular
    cflags.flag("FAKE_HULL",true); //need to avoid "Very skewed ground-state..." and "Unreliable hull" issues, we're removing points, so these may (and likely will) come up
    cflags.flag("FORCE",true); //need to avoid outlier issues, we're removing points, so these may (and likely will) come up
    //let's skip all this extra output
    bool see_sub_output=false;//true;
    ostream& oss_empty=cout;if(!see_sub_output){oss_empty.setstate(std::ios_base::badbit);}  //like NULL
    ofstream devnull("/dev/null");  //NULL
    fake_hull.initialize(cflags,new_points,velements,devnull,oss_empty,m_half_hull,m_add_artificial_unaries);
    oss_empty.clear();  //clear badbit, as cout is GLOBAL
    if(!fake_hull.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Could not create pseudo convex hull");}
    if(LDEBUG) {cerr << soliloquy << " New (pseudo) hull created" << endl;}
  }

  double ConvexHull::getNPlus1EnthalpyGain(const string& cauid) const {
    string soliloquy=XPID+"ConvexHull::getNPlus1EnthalpyGain():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    vector<string> vcauid; vcauid.push_back(cauid);
    vector<double> vnp1eg=getNPlus1EnthalpyGain(vcauid);
    return vnp1eg[0];
  }
  double ConvexHull::getNPlus1EnthalpyGain(const string& cauid,ConvexHull& fake_hull,bool hull_set) const {
    string soliloquy=XPID+"ConvexHull::getNPlus1EnthalpyGain():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    vector<string> vcauid; vcauid.push_back(cauid);
    vector<double> vnp1eg=getNPlus1EnthalpyGain(vcauid,fake_hull,hull_set);
    return vnp1eg[0];
  }
  vector<double> ConvexHull::getNPlus1EnthalpyGain(const vector<string>& vcauid) const {ConvexHull fake_hull;return getNPlus1EnthalpyGain(vcauid,fake_hull,false);}
  vector<double> ConvexHull::getNPlus1EnthalpyGain(const vector<string>& vcauid,ConvexHull& fake_hull,bool hull_set) const {
    string soliloquy=XPID+"ConvexHull::getNPlus1EnthalpyGain():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    stringstream message;

    uint i_point=AUROSTD_MAX_UINT;
    vector<uint> vcpoints; //follows vcauid
    for(uint i=0,fl_size_i=vcauid.size();i<fl_size_i;i++){
      const string& auid=vcauid[i];
      if(auid.empty()){message << "Empty auid found";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      if(!findPoint(auid,i_point)){message << "Specified auid not found on hull (auid=" << auid << ")";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      vcpoints.push_back(i_point);
    }
    return getNPlus1EnthalpyGain(vcpoints,fake_hull,hull_set);
  }
  vector<double> ConvexHull::getNPlus1EnthalpyGain(const vector<uint>& vcpoints) const {ConvexHull fake_hull;return getNPlus1EnthalpyGain(vcpoints,fake_hull,false);}
  vector<double> ConvexHull::getNPlus1EnthalpyGain(const vector<uint>& vcpoints,ConvexHull& fake_hull,bool hull_set) const {
    vector<double> vnp1eg;
    for(uint i=0,fl_size_i=vcpoints.size();i<fl_size_i;i++){vnp1eg.push_back(getNPlus1EnthalpyGain(vcpoints[i],fake_hull,hull_set));}
    return vnp1eg;
  }
  double ConvexHull::getNPlus1EnthalpyGain(uint i_point) const {ConvexHull fake_hull;return getNPlus1EnthalpyGain(i_point,fake_hull,false);}
  double ConvexHull::getNPlus1EnthalpyGain(uint i_point,ConvexHull& fake_hull,bool hull_set) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getNPlus1EnthalpyGain():";
    stringstream message;

    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    ChullPoint point=m_points[i_point];
    if(point.m_i_nary==0){return AUROSTD_MAX_DOUBLE;} //N+1(unary)=formation_enthalpy (distance from 0 point) - TECHNICALLY TRUE (allowed in polytope theory), but our definition for N+1 enthalpy gain really starts for binaries (Delta H[{N|1,...,N-1}]), can NOT have 1|0
    bool force_calc_binaries=false; //set TRUE for debugging
    if(point.m_i_nary==0 || (point.m_i_nary==1 && force_calc_binaries==false) ){ //N+1(unary)=formation_enthalpy (distance from 0 point), N+1(binary)=formation_enthalpy (distance from 0 tieline)
      if(LDEBUG){cerr << soliloquy << " found " << (point.m_i_nary==0 ? "unary" : "binary") << ", returning abs(H_f_atom)" << endl;} //enthalpy_formation_atom
      if(point.m_has_entry&&H_f_atom(point.m_entry)!=AUROSTD_NAN){return abs(H_f_atom(point.m_entry));} //point.m_entry.enthalpy_formation_atom
      return AUROSTD_MAX_DOUBLE; //0; //return null
    }

    //set fake_hull
    xvector<int> elements_present_points=point.m_elements_present;
    xvector<int> elements_present_hull=elements_present_points;
    if(sum(elements_present_hull)==1){
      //pick ANY other index to be 1 as well
      if(elements_present_hull[elements_present_hull.lrows]==0){elements_present_hull[elements_present_hull.lrows]=1;}
      else{
        if(elements_present_hull.rows<2){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"elements_present.rows<2",_INPUT_ILLEGAL_);} //we cannot have unary hulls as input (facets issue)
        if(elements_present_hull[elements_present_hull.lrows+1]==1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"elements_present mismatch for unary hull",_INDEX_MISMATCH_);}
        elements_present_hull[elements_present_hull.lrows+1]=1;
      }
    }
    if(sum(elements_present_hull)==1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Could not fix sum(elements_present_hull)==1",_RUNTIME_ERROR_);}

    //get full set of points to neglect
    //neglect ALL points with equal or higher dimensionality
    if(hull_set==false){
      uint j_nary=AUROSTD_MAX_UINT,j_alloy=AUROSTD_MAX_UINT;
      if(!getAlloyIndex(point,j_nary,j_alloy)){message << "Alloy index not set (auid=" << point.m_entry.auid << ")";throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);}
      uint i_coord_group=AUROSTD_MAX_UINT;
      vector<uint> vcpoints;
      for(uint fl_size_i_nary=m_naries.size(),i_nary=(fl_size_i_nary-1);i_nary<fl_size_i_nary&&i_nary>=j_nary;i_nary--){ //go backwards!
        if(LDEBUG) {cerr << soliloquy << " removing i_nary=" << i_nary << endl;}
        for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
          for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i<fl_size_i;i++){
            i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
            for(uint j=0,fl_size_j=m_coord_groups[i_coord_group].m_points.size();j<fl_size_j;j++){
              vcpoints.push_back(m_coord_groups[i_coord_group].m_points[j]);
            }
          }
        }
      }

      if(LDEBUG) {
        cerr << soliloquy << " points_to_neglect.size()=" << vcpoints.size() << endl;
        std::sort(vcpoints.begin(),vcpoints.end());
        cerr << soliloquy << " points_to_neglect: ";
        for(uint i=0,fl_size_i=vcpoints.size();i<fl_size_i;i++){cerr << vcpoints[i] << " ";} 
        cerr << endl;
      }

      getFakeHull(vcpoints,elements_present_hull,elements_present_points,fake_hull);
    }

    //since j_nary and j_alloy don't change, the getDistanceToHull function should work fine (getRelevantFacets())
    //xvector<int> elements_present=m_naries[j_nary].m_alloys[j_alloy].m_elements_present;
    //if(LDEBUG) {cerr << soliloquy << " elements_present=" << elements_present << endl;}
    //point.setHullCoords(elements_present);  //just to be sure
    point.cleanPointForHullTransfer();      //clean now
    point.reduceCoords(elements_present_hull);  //reduce to minimum hull necessary to calculate scriterion (for unaries this will be a binary)
    point.setHullCoords(); //set to most general coords (m_coords), this reflects relevantFacets()
    if(LDEBUG) {cerr << soliloquy << " m.coords=" << point.m_coords << endl;}
    if(LDEBUG) {cerr << soliloquy << " h.coords=" << point.h_coords << endl;}

    return fake_hull.getDistanceToHull(point,false);
  }

  void ConvexHull::setStabilityCriterion() {
    bool LDEBUG = (FALSE || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setStabilityCriterion():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    stringstream message;

    message << "Determining stability criteria for ground-state structures, please be patient";
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

    vector<uint> g_states=getGStates(true);
    uint i_point=AUROSTD_MAX_UINT,i_coord_group=AUROSTD_MAX_UINT;
    double scriterion;
    vector<uint> eq_gstates;
    for(uint i=0,fl_size_i=g_states.size();i<fl_size_i;i++){
      i_point=g_states[i];
      if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
      if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
      if(LDEBUG) {cerr << soliloquy << " looking at point[i_point=" << i_point << "].m_coords=" << m_points[i_point].m_coords << endl;}
      scriterion=getStabilityCriterion(i_point);
      //CONSISTENCY CHECKS?
      //[OBSOLETE - this is a DISTANCE so it is always positive]if(m_half_hull){
      //[OBSOLETE - this is a DISTANCE so it is always positive]i  //do not use signbit, add tol to zero
      //[OBSOLETE - this is a DISTANCE so it is always positive]i  //sign of distance:
      //[OBSOLETE - this is a DISTANCE so it is always positive]i  //independent of lower/upper hull:  above hull is negative, below hull is positive
      //[OBSOLETE - this is a DISTANCE so it is always positive]i  if(m_lower_hull){
      //[OBSOLETE - this is a DISTANCE so it is always positive]    if(notPositive(scriterion,true)) //std::signbit(scriterion))
      //[OBSOLETE - this is a DISTANCE so it is always positive]    { //CO20200106 - patching for auto-indenting
      //[OBSOLETE - this is a DISTANCE so it is always positive]      message << "(lower half hull) found ground-state structure INSIDE hull, suggesting it was not really a ground-state";
      //[OBSOLETE - this is a DISTANCE so it is always positive]      message << " (i_point=" << i_point;
      //[OBSOLETE - this is a DISTANCE so it is always positive]      message << (m_points[i_point].m_entry.auid.empty()?"":",auid="+m_points[i_point].m_entry.auid);
      //[OBSOLETE - this is a DISTANCE so it is always positive]      message << ",scriterion=" << scriterion << ")";
      //[OBSOLETE - this is a DISTANCE so it is always positive]      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);
      //[OBSOLETE - this is a DISTANCE so it is always positive]    }
      //[OBSOLETE - this is a DISTANCE so it is always positive]  } else {
      //[OBSOLETE - this is a DISTANCE so it is always positive]    if(notNegative(scriterion,true)) //!std::signbit(scriterion))
      //[OBSOLETE - this is a DISTANCE so it is always positive]    { //CO20200106 - patching for auto-indenting
      //[OBSOLETE - this is a DISTANCE so it is always positive]      message << "(upper half hull) found ground-state structure INSIDE hull, suggesting it was not really a ground-state";
      //[OBSOLETE - this is a DISTANCE so it is always positive]      message << " (i_point=" << i_point;
      //[OBSOLETE - this is a DISTANCE so it is always positive]      message << (m_points[i_point].m_entry.auid.empty()?"":",auid="+m_points[i_point].m_entry.auid);
      //[OBSOLETE - this is a DISTANCE so it is always positive]      message << ",scriterion=" << scriterion << ")";
      //[OBSOLETE - this is a DISTANCE so it is always positive]i      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);
      //[OBSOLETE - this is a DISTANCE so it is always positive]i    }
      //[OBSOLETE - this is a DISTANCE so it is always positive]i  }
      //[OBSOLETE - this is a DISTANCE so it is always positive]i}
      //KEEP THE SIGN CONVENTION AS IS, it is correct without manipulation
      //set sign convention, negative for outside hull
      //scriterion=abs(scriterion);
      message << "Ground-state ";
      message << (!m_points[i_point].m_entry.compound.empty()?m_points[i_point].m_entry.compound+" ":"");
      message << "(i_point=" << i_point;
      message << (m_points[i_point].m_entry.auid.empty()?"":",auid="+m_points[i_point].m_entry.auid);
      message << ") shows stability criterion = ";
      message << chull::convertUnits(scriterion,(m_formation_energy_hull?_m_:_std_)) << " ";
      message << (m_formation_energy_hull?"meV/atom":"K");
      //this check should STILL work for unaries, as it's the difference of distances, and
      //the actual hull points should ALWAYS be lower than pseudo hull points, hence a positive scriterion
      //by convention, stability criterion are NEGATIVE as they are outside the hull
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
      m_points[i_point].m_stability_criterion=scriterion;
      //set equivalent ones
      if(!getCoordGroupIndex(i_point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
      if(!m_coord_groups[i_coord_group].m_is_on_hull){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup is not on the hull");}
      m_coord_groups[i_coord_group].m_stability_criterion=m_points[i_point].m_stability_criterion;
      //const vector<uint>& eq_gstates=m_coord_groups[i_coord_group].m_equivalent_g_states;
      if(m_coord_groups[i_coord_group].m_calculated_equivalent_g_states){eq_gstates=m_coord_groups[i_coord_group].m_equivalent_g_states;}
      else {eq_gstates=getEquivalentGStates(i_point);}
      if(!eq_gstates.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No equivalent states found (not even self)");}
      for(uint j=0,fl_size_j=eq_gstates.size();j<fl_size_j;j++){
        if(eq_gstates[j]>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
        if(!m_points[eq_gstates[j]].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(eq_gstates[j])+"] is not initialized");}
        scriterion=m_points[i_point].m_stability_criterion;
        scriterion+=(m_points[i_point].getLastCoord()-m_points[eq_gstates[j]].getLastCoord());
        //if(m_formation_energy_hull){scriterion+=abs(H_f_atom(m_points[i_point])-H_f_atom(m_points[eq_gstates[j]]));}
        //else {scriterion+=abs(T_S(m_points[i_point])-T_S(m_points[eq_gstates[j]]));}
        //unaries could be really close to 0
        //don't set if it becomes positive
        if(std::signbit(m_points[i_point].m_stability_criterion)!=std::signbit(scriterion)){scriterion=0;}  //define these to be 0, AlFe hull look at Fe
        m_points[eq_gstates[j]].m_stability_criterion=scriterion;
      }
    }
  }

  void ConvexHull::setNPlus1EnthalpyGain(uint i_point) {ConvexHull fake_hull;return setNPlus1EnthalpyGain(i_point,fake_hull,false);}
  void ConvexHull::setNPlus1EnthalpyGain(uint i_point,ConvexHull& fake_hull,bool hull_set) {
    bool LDEBUG = (FALSE || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setNPlus1EnthalpyGain():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    stringstream message;

    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
    //[CO20200404 - not useful, we still want values for binaries, this would skip over value assignment]if(test_binary_np1==false&&m_points[i_point].m_i_nary<2){continue;} //unaries would be trivial, and binaries is simply H_f
    if(LDEBUG) {cerr << soliloquy << " looking at point[i_point=" << i_point << "].m_coords=" << m_points[i_point].m_coords << ", compound=" << m_points[i_point].m_entry.compound << endl;}
    double np1egain=getNPlus1EnthalpyGain(i_point,fake_hull,hull_set);
    //CONSISTENCY CHECKS?
    //yes - for unaries/binaries N+1 == formation enthalpy
    //[MATHEMATICALLY ALLOWED but our definition of N+1 energy does not allow for unaries, so don't check]if(m_points[i_point].m_i_nary==0 || m_points[i_point].m_i_nary==1)
    if(m_points[i_point].m_i_nary==1) {
      if(m_points[i_point].m_has_entry&&H_f_atom(m_points[i_point].m_entry)!=AUROSTD_NAN){  //m_points[i_point].m_entry.enthalpy_formation_atom
        if(!aurostd::identical(abs(np1egain),abs(H_f_atom(m_points[i_point].m_entry)),ZERO_MEV_TOL)){ //m_points[i_point].m_entry.enthalpy_formation_atom
          message << "abs(np1egain) != abs(H_f_atom(m_points[i_point].m_entry)) [ " << abs(np1egain) << " != " << abs(H_f_atom(m_points[i_point].m_entry)) << " ], please check"; //m_points[i_point].m_entry.enthalpy_formation_atom
          throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message,_RUNTIME_ERROR_); //throw an error because we are not in debug mode (see force_calc_binaries)
          //pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        }
      }
    }
    //[OBSOLETE - this is a DISTANCE so it is always positive]if(m_points[i_point].m_i_nary>0){ //skip unaries for this check
    //[OBSOLETE - this is a DISTANCE so it is always positive]  if(m_half_hull){
    //[OBSOLETE - this is a DISTANCE so it is always positive]    //do not use signbit, add tol to zero
    //[OBSOLETE - this is a DISTANCE so it is always positive]    //sign of distance:
    //[OBSOLETE - this is a DISTANCE so it is always positive]    //independent of lower/upper hull:  above hull is negative, below hull is positive
    //[OBSOLETE - this is a DISTANCE so it is always positive]    if(m_lower_hull){
    //[OBSOLETE - this is a DISTANCE so it is always positive]      if(notPositive(np1egain,true)) //std::signbit(np1egain))
    //[OBSOLETE - this is a DISTANCE so it is always positive]      { //CO20200106 - patching for auto-indenting
    //[OBSOLETE - this is a DISTANCE so it is always positive]        message << "(lower half hull) found ground-state structure INSIDE hull, suggesting it was not really a ground-state";
    //[OBSOLETE - this is a DISTANCE so it is always positive]        message << " (i_point=" << i_point;
    //[OBSOLETE - this is a DISTANCE so it is always positive]        message << (m_points[i_point].m_entry.auid.empty()?"":",auid="+m_points[i_point].m_entry.auid);
    //[OBSOLETE - this is a DISTANCE so it is always positive]        message << ",np1egain=" << np1egain << ")";
    //[OBSOLETE - this is a DISTANCE so it is always positive]        throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);
    //[OBSOLETE - this is a DISTANCE so it is always positive]      }
    //[OBSOLETE - this is a DISTANCE so it is always positive]    } else {
    //[OBSOLETE - this is a DISTANCE so it is always positive]      if(notNegative(np1egain,true)) //!std::signbit(np1egain))
    //[OBSOLETE - this is a DISTANCE so it is always positive]      { //CO20200106 - patching for auto-indenting
    //[OBSOLETE - this is a DISTANCE so it is always positive]        message << "(upper half hull) found ground-state structure INSIDE hull, suggesting it was not really a ground-state";
    //[OBSOLETE - this is a DISTANCE so it is always positive]        message << " (i_point=" << i_point;
    //[OBSOLETE - this is a DISTANCE so it is always positive]        message << (m_points[i_point].m_entry.auid.empty()?"":",auid="+m_points[i_point].m_entry.auid);
    //[OBSOLETE - this is a DISTANCE so it is always positive]        message << ",np1egain=" << np1egain << ")";
    //[OBSOLETE - this is a DISTANCE so it is always positive]        throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,message);
    //[OBSOLETE - this is a DISTANCE so it is always positive]      }
    //[OBSOLETE - this is a DISTANCE so it is always positive]    }
    //[OBSOLETE - this is a DISTANCE so it is always positive]  }
    //[OBSOLETE - this is a DISTANCE so it is always positive]i}
    //KEEP THE SIGN CONVENTION AS IS, it is correct without manipulation
    //set sign convention, negative for outside hull
    //np1egain=abs(np1egain);
    if(m_points[i_point].m_i_nary>0){ //don't print for unaries
      message << "Ground-state ";
      message << (!m_points[i_point].m_entry.compound.empty()?m_points[i_point].m_entry.compound:"")+" ";
      message << "(i_point=" << i_point;
      message << (m_points[i_point].m_entry.auid.empty()?"":",auid="+m_points[i_point].m_entry.auid);
      message << ") shows N+1 enthalpy gain = ";
      message << chull::convertUnits(np1egain,(m_formation_energy_hull?_m_:_std_)) << " ";
      message << (m_formation_energy_hull?"meV/atom":"K");
    }
    //this check should STILL work for unaries, as it's the difference of distances, and
    //the actual hull points should ALWAYS be lower than pseudo hull points, hence a positive np1egain
    //by convention, enthalpy gains are NEGATIVE as they are outside the hull
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);
    m_points[i_point].m_n_plus_1_enthalpy_gain=np1egain;
    //set equivalent ones
    uint i_coord_group=AUROSTD_MAX_UINT;
    if(!getCoordGroupIndex(i_point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
    if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized coordgroup");}
    if(!m_coord_groups[i_coord_group].m_is_on_hull){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup is not on the hull");}
    m_coord_groups[i_coord_group].m_n_plus_1_enthalpy_gain=m_points[i_point].m_n_plus_1_enthalpy_gain;
    vector<uint> eq_gstates;
    //const vector<uint>& eq_gstates=m_coord_groups[i_coord_group].m_equivalent_g_states;
    if(m_coord_groups[i_coord_group].m_calculated_equivalent_g_states){eq_gstates=m_coord_groups[i_coord_group].m_equivalent_g_states;}
    else {eq_gstates=getEquivalentGStates(i_point);}
    if(!eq_gstates.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No equivalent states found (not even self)");}
    for(uint j=0,fl_size_j=eq_gstates.size();j<fl_size_j;j++){
      if(eq_gstates[j]>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
      if(!m_points[eq_gstates[j]].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(eq_gstates[j])+"] is not initialized");}
      np1egain=m_points[i_point].m_n_plus_1_enthalpy_gain;
      np1egain+=(m_points[i_point].getLastCoord()-m_points[eq_gstates[j]].getLastCoord());
      //if(m_formation_energy_hull){np1egain+=abs(H_f_atom(m_points[i_point])-H_f_atom(m_points[eq_gstates[j]]));}
      //else {np1egain+=abs(T_S(m_points[i_point])-T_S(m_points[eq_gstates[j]]));}
      //unaries could be really close to 0
      //don't set if it becomes positive
      if(std::signbit(m_points[i_point].m_n_plus_1_enthalpy_gain)!=std::signbit(np1egain)){np1egain=0;}  //define these to be 0, AlFe hull look at Fe
      m_points[eq_gstates[j]].m_n_plus_1_enthalpy_gain=np1egain;
    }
  }
  void ConvexHull::setNPlus1EnthalpyGain() {
    bool LDEBUG = (FALSE || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::setNPlus1EnthalpyGain():";
    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}
    stringstream message;

    message << "Determining N+1 enthalpy gain for ground-state structures, please be patient";
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

    vector<uint> g_states=getGStates(true);

    //CO20200804 - group g_states by elements_present, they will all need the same fake_hull
    vector<xvector<int> > v_elements_present;
    vector<vector<uint> > v_g_states;

    uint i=0,j=0,fl_size_i=0,fl_size_j=0;
    uint i_point=AUROSTD_MAX_UINT;
    bool found=false;
    for(i=0,fl_size_i=g_states.size();i<fl_size_i;i++){
      i_point=g_states[i];
      if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
      if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
      //[CO20200404 - not useful, we still want values for binaries, this would skip over value assignment]if(test_binary_np1==false&&m_points[i_point].m_i_nary<2){continue;} //unaries would be trivial, and binaries is simply H_f
      if(LDEBUG) {cerr << soliloquy << " looking at point[i_point=" << i_point << "].m_coords=" << m_points[i_point].m_coords << ", compound=" << m_points[i_point].m_entry.compound << endl;}

      found=false;
      for(j=0,fl_size_j=v_elements_present.size();j<fl_size_j&&found==false;j++){
        if(m_points[i_point].m_elements_present==v_elements_present[j]){
          if(LDEBUG){
            cerr << soliloquy << " adding point[i_point=" << i_point << ",auid=" << m_points[i_point].m_entry.auid << "].compound=\"" << m_points[i_point].m_entry.compound << "\" ";
            cerr << "with elements_present=" << m_points[i_point].m_elements_present << " to v_elements_present[j=" << j << "]=" << v_elements_present[j] << endl;
          }
          v_g_states[j].push_back(g_states[i]);
          found=true;
        }
      }
      if(!found){
        if(LDEBUG){
          cerr << soliloquy << " adding point[i_point=" << i_point << ",auid=" << m_points[i_point].m_entry.auid << "].compound=\"" << m_points[i_point].m_entry.compound << "\" ";
          cerr << "with elements_present=" << m_points[i_point].m_elements_present << " to set" << endl;
        }
        v_elements_present.push_back(m_points[i_point].m_elements_present);
        v_g_states.push_back(vector<uint>(0));
        v_g_states.back().push_back(g_states[i]);
      }
    }
    if(v_elements_present.size()!=v_g_states.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"v_elements_present.size()!=v_g_states.size()",_INDEX_MISMATCH_);}

    ConvexHull fake_hull;
    //[CO20200404 - not useful, we still want values for binaries, this would skip over value assignment]bool test_binary_np1=true;  //turn me off when you're sure np1 is working
    for(i=0,fl_size_i=v_g_states.size();i<fl_size_i;i++){
      /////////////////////////////////////////////////////////////
      if(v_g_states[i].empty()){continue;}
      i_point=v_g_states[i][0]; //g_states[i];
      setNPlus1EnthalpyGain(i_point,fake_hull,false);
      for(j=1,fl_size_j=v_g_states[i].size();j<fl_size_j;j++){
        i_point=v_g_states[i][j]; //g_states[i];
        setNPlus1EnthalpyGain(i_point,fake_hull,true);
      }
    }
  }

  void ConvexHull::cleanHull() {
    h_dim=0;
    m_elements_present.clear();
    h_points.clear();
    h_centroid.clear();
    h_reference.clear();
    h_facets.clear();
    h_visible_facets.clear();
    h_horizon_ridges.clear();
  }

  string ConvexHull::prettyPrintCompound(const ChullPoint& point,vector_reduction_type vred,bool exclude1,filetype ftype) const {  // overload
    if(!point.m_has_entry){
      string soliloquy=XPID+"ConvexHull::prettyPrintCompound():";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No entry found");
    }
    return prettyPrintCompound(point.m_entry,vred,exclude1,ftype);
  }

  string ConvexHull::prettyPrintCompound(const aflowlib::_aflowlib_entry& entry,vector_reduction_type vred,bool exclude1,filetype ftype) const {  // overload
    if(entry.vspecies.size()!=entry.vcomposition.size()) {
      if(entry.prototype.find("POCC")!=string::npos){ //POCC entries have no composition
        return pflow::prettyPrintCompound(entry.vspecies,entry.vstoichiometry,no_vrt,exclude1,ftype);  //pass in stoichiometry and do not reduce
      }else{
        string soliloquy=XPID+"ConvexHull::prettyPrintCompound():";
        stringstream message;
        message << "Entry (auid=" << entry.auid << ") is ill-defined: vspecies.size()!=vcomposition.size()";
        message << " (please report on AFLOW Forum: aflow.org/forum)";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        return entry.compound;
      }
    }
    return pflow::prettyPrintCompound(entry.vspecies,entry.vcomposition,vred,exclude1,ftype);  //ME20190628
  }

  //[ME20190628 - moved to pflow_funcs.cpp] string ConvexHull::prettyPrintCompound(const vector<string>& vspecies,const vector<double>& vcomposition,vector_reduction_type vred,bool exclude1,filetype ftype) const {  // overload
  //[ME20190628 - moved to pflow_funcs.cpp]   return prettyPrintCompound(vspecies,aurostd::vector2xvector<double>(vcomposition),vred,exclude1,ftype);
  //[ME20190628 - moved to pflow_funcs.cpp] }

  //[ME20190628 - moved to pflow_funcs.cpp] string ConvexHull::prettyPrintCompound(const vector<string>& vspecies,const xvector<double>& vcomposition,vector_reduction_type vred,bool exclude1,filetype ftype) const {  // main function
  //[ME20190628 - moved to pflow_funcs.cpp]   // creates compound_label for LaTeX and text docs, like adding $_{}$
  //[ME20190628 - moved to pflow_funcs.cpp]   // 2-D, we usually want vred=gcd_vrt true for convex points, and no_vrt elsewhere
  //[ME20190628 - moved to pflow_funcs.cpp]   string soliloquy=XPID+"ConvexHull::prettyPrintCompound():";
  //[ME20190628 - moved to pflow_funcs.cpp]   uint precision=COEF_PRECISION;
  //[ME20190628 - moved to pflow_funcs.cpp]   stringstream output;output.precision(precision);
  //[ME20190628 - moved to pflow_funcs.cpp]   if(vspecies.size()!=(uint)vcomposition.rows) {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"vspecies.size() != vcomposition.rows");}
  //[ME20190628 - moved to pflow_funcs.cpp]   // special case, unary
  //[ME20190628 - moved to pflow_funcs.cpp]   if(vspecies.size() == 1) {
  //[ME20190628 - moved to pflow_funcs.cpp]     output << vspecies[0];
  //[ME20190628 - moved to pflow_funcs.cpp]     if(!exclude1) {output << (vred==gcd_vrt?1:vcomposition[vcomposition.lrows]);}
  //[ME20190628 - moved to pflow_funcs.cpp]     return output.str();
  //[ME20190628 - moved to pflow_funcs.cpp]   }
  //[ME20190628 - moved to pflow_funcs.cpp]   xvector<double> comp=vcomposition;
  //[ME20190628 - moved to pflow_funcs.cpp]   if(vred==gcd_vrt){comp=aurostd::reduceByGCD(comp,ZERO_TOL);}
  //[ME20190628 - moved to pflow_funcs.cpp]   else if(vred==frac_vrt){comp=aurostd::normalizeSumToOne(comp,ZERO_TOL);}
  //[ME20190628 - moved to pflow_funcs.cpp]   else if(vred==no_vrt){;}
  //[ME20190628 - moved to pflow_funcs.cpp]   else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown reduce mode",_INPUT_UNKNOWN_);}
  //[ME20190628 - moved to pflow_funcs.cpp]   if(zeroWithinTol(aurostd::sum(comp))){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Empty composition");}
  //[ME20190628 - moved to pflow_funcs.cpp]   for(uint i=0,fl_size_i=vspecies.size();i<fl_size_i;i++) {
  //[ME20190628 - moved to pflow_funcs.cpp]     output << vspecies[i];
  //[ME20190628 - moved to pflow_funcs.cpp]     if(!(exclude1 && aurostd::identical(comp[i+comp.lrows],1.0,ZERO_TOL))) {
  //[ME20190628 - moved to pflow_funcs.cpp]       if(ftype==latex_ft) {output << "$_{";
  //[ME20190628 - moved to pflow_funcs.cpp]       } else if(ftype==gnuplot_ft){output<< "_{";}
  //[ME20190628 - moved to pflow_funcs.cpp]       output << comp[i+comp.lrows];
  //[ME20190628 - moved to pflow_funcs.cpp]       if(ftype==latex_ft) {output << "}$";}
  //[ME20190628 - moved to pflow_funcs.cpp]       else if(ftype==gnuplot_ft){output<< "}";}
  //[ME20190628 - moved to pflow_funcs.cpp]     }
  //[ME20190628 - moved to pflow_funcs.cpp]   }
  //[ME20190628 - moved to pflow_funcs.cpp]   return output.str();
  //[ME20190628 - moved to pflow_funcs.cpp] }

  string ConvexHull::getICSDNumber(uint i_point,bool remove_suffix) const{
    string soliloquy=XPID+"ConvexHull::getICSDNumber():";
    if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    return getICSDNumber(m_points[i_point],remove_suffix);
  }

  string ConvexHull::getICSDNumber(const ChullPoint& point,bool remove_suffix) const{
    string soliloquy=XPID+"ConvexHull::getICSDNumber():";
    if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized point");}
    if(!point.m_has_entry){return "";}
    return getICSDNumber(point.m_entry,remove_suffix);

  }
  string ConvexHull::getICSDNumber(const aflowlib::_aflowlib_entry& entry,bool remove_suffix) const{
    string soliloquy=XPID+"ConvexHull::getICSDNumber():";
    const string& proto=entry.prototype;
    if(!aurostd::substring2bool(proto,"ICSD_")){return "";}
    vector<string> tokens;
    aurostd::string2tokens(proto,tokens,"_");
    string icsd_number;
    if(tokens.size()==2){icsd_number=tokens[1];} //aurostd::substring2bool(proto,"ICSD_")
    else if(tokens.size()==3&&aurostd::substring2bool(proto,"_ICSD_")){icsd_number=tokens[2];}
    if(icsd_number.empty()){return icsd_number;}
    if(remove_suffix){
      aurostd::string2tokens(icsd_number,tokens,".");if(tokens.size()){icsd_number=tokens[0];}
      aurostd::string2tokens(icsd_number,tokens,":");if(tokens.size()){icsd_number=tokens[0];}
    }
    return icsd_number;
  }

  string ConvexHull::prettyPrintPrototype(const ChullPoint& point, bool double_back_slash,bool icsd_label_skim) const {  // overload
    if(!point.m_has_entry){
      string soliloquy=XPID+"ConvexHull::prettyPrintPrototype():";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No entry found");
    }
    return prettyPrintPrototype(point.m_entry,double_back_slash,icsd_label_skim);
  }

  string ConvexHull::prettyPrintPrototype(const aflowlib::_aflowlib_entry& entry, bool double_back_slash,bool icsd_label_skim) const {  // main function
    // creates prototype_label for LaTeX ONLY, no use for this function otherwise
    // escapes funny characters
    if(entry.prototype.empty()) {
      string soliloquy=XPID+"ConvexHull::prettyPrintPrototype():";
      stringstream message;
      message << "Entry (auid=" << entry.auid << ") is ill-defined: empty prototype";
      message << " (please report on AFLOW Forum: aflow.org/forum)";
      pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
      return entry.prototype;
    }
    bool fix_icsd_labels=true;
    string proto=entry.prototype;
    if(fix_icsd_labels&&aurostd::substring2bool(proto,"ICSD_")){
      vector<string> tokens;
      string string_to_fix=getICSDNumber(entry,icsd_label_skim==true);  //remove suffix if skim label
      //aurostd::string2tokens(proto,tokens,"_");
      //if(tokens.size()==2){string_to_fix=tokens[1];} //aurostd::substring2bool(proto,"ICSD_")
      //else if(tokens.size()==3&&aurostd::substring2bool(proto,"_ICSD_")){string_to_fix=tokens[2];}
      if(!string_to_fix.empty()){
        return (icsd_label_skim?"":"ICSD~")+(double_back_slash?string("\\\\"):string("\\"))+"#"+aurostd::fixStringLatex(string_to_fix,double_back_slash,false);
      }
      //else, just leave alone
    }
    return aurostd::fixStringLatex(proto,double_back_slash,false);
  }

  //[CO20190419 - moved to aurostd_main.cpp]string ConvexHull::fixStringLatex(const string& input, bool double_back_slash,bool symmetry_string) const {
  //[CO20190419 - moved to aurostd_main.cpp]  // deals with special characters for LaTeX, like some characters in prototype
  //[CO20190419 - moved to aurostd_main.cpp]  // see http://tex.stackexchange.com/questions/34580/escape-character-in-latex
  //[CO20190419 - moved to aurostd_main.cpp]  // double_back_slash was needed SOMETIMES for gnuplot output, as one backslash
  //[CO20190419 - moved to aurostd_main.cpp]  // went away when writing to file, and  -- OBSOLETE NOW
  //[CO20190419 - moved to aurostd_main.cpp]  string soliloquy=XPID+"ConvexHull::fixStringLatex():";
  //[CO20190419 - moved to aurostd_main.cpp]  string output;
  //[CO20190419 - moved to aurostd_main.cpp]  vector<char> problem_characters;
  //[CO20190419 - moved to aurostd_main.cpp]  problem_characters.push_back('&');
  //[CO20190419 - moved to aurostd_main.cpp]  problem_characters.push_back('%');
  //[CO20190419 - moved to aurostd_main.cpp]  problem_characters.push_back('$');
  //[CO20190419 - moved to aurostd_main.cpp]  problem_characters.push_back('#');
  //[CO20190419 - moved to aurostd_main.cpp]  if(!symmetry_string) {
  //[CO20190419 - moved to aurostd_main.cpp]    problem_characters.push_back('_');
  //[CO20190419 - moved to aurostd_main.cpp]    problem_characters.push_back('{');
  //[CO20190419 - moved to aurostd_main.cpp]    problem_characters.push_back('}');
  //[CO20190419 - moved to aurostd_main.cpp]  }
  //[CO20190419 - moved to aurostd_main.cpp]  problem_characters.push_back('~');  // different fix
  //[CO20190419 - moved to aurostd_main.cpp]  problem_characters.push_back('^');  // different fix
  //[CO20190419 - moved to aurostd_main.cpp]  string solution_string;
  //[CO20190419 - moved to aurostd_main.cpp]  solution_string = "\\\\";  // has to be string, \\ char does not work
  //[CO20190419 - moved to aurostd_main.cpp]  bool found_escaped_char;
  //[CO20190419 - moved to aurostd_main.cpp]  bool found_hyphen_symmetry = false;
  //[CO20190419 - moved to aurostd_main.cpp]  bool solved_hyphen_symmetry = false;
  //[CO20190419 - moved to aurostd_main.cpp]  for(uint i=0;i<input.length();i++) {
  //[CO20190419 - moved to aurostd_main.cpp]    // we first enter this loop because symmetry_string and input[i]=='-'
  //[CO20190419 - moved to aurostd_main.cpp]    // second enter loop because symmetry_string and found_hyphen_symmetry
  //[CO20190419 - moved to aurostd_main.cpp]    if(symmetry_string && (input[i] == '-' || found_hyphen_symmetry)) {
  //[CO20190419 - moved to aurostd_main.cpp]      if(!found_hyphen_symmetry) {
  //[CO20190419 - moved to aurostd_main.cpp]        // first enter loop, come here
  //[CO20190419 - moved to aurostd_main.cpp]        found_hyphen_symmetry = true;
  //[CO20190419 - moved to aurostd_main.cpp]        output.append((double_back_slash?string("\\"):string(""))+string("\\overline{"));
  //[CO20190419 - moved to aurostd_main.cpp]        // very important, we don't want to add hyphen, just replace
  //[CO20190419 - moved to aurostd_main.cpp]        // with overline, so continue
  //[CO20190419 - moved to aurostd_main.cpp]        continue;
  //[CO20190419 - moved to aurostd_main.cpp]      } else {
  //[CO20190419 - moved to aurostd_main.cpp]        // second enter loop, do nothing but turn this flag on
  //[CO20190419 - moved to aurostd_main.cpp]        // allow us to add input[i]
  //[CO20190419 - moved to aurostd_main.cpp]        found_hyphen_symmetry = false;
  //[CO20190419 - moved to aurostd_main.cpp]        solved_hyphen_symmetry = true;
  //[CO20190419 - moved to aurostd_main.cpp]      }
  //[CO20190419 - moved to aurostd_main.cpp]    } else {
  //[CO20190419 - moved to aurostd_main.cpp]      if(symmetry_string && solved_hyphen_symmetry) {
  //[CO20190419 - moved to aurostd_main.cpp]        // last step of symmetry_string fix, but we have to do this in part of
  //[CO20190419 - moved to aurostd_main.cpp]        // the loop to allow for next character to be identified as problem
  //[CO20190419 - moved to aurostd_main.cpp]        // character as well
  //[CO20190419 - moved to aurostd_main.cpp]        output.append(1, '}');
  //[CO20190419 - moved to aurostd_main.cpp]        solved_hyphen_symmetry = false;
  //[CO20190419 - moved to aurostd_main.cpp]      }
  //[CO20190419 - moved to aurostd_main.cpp]      // go through all problem characters
  //[CO20190419 - moved to aurostd_main.cpp]      for(uint j=0,fl_size_j=problem_characters.size();j<fl_size_j;j++) {
  //[CO20190419 - moved to aurostd_main.cpp]        if(input[i] == problem_characters[j]) {
  //[CO20190419 - moved to aurostd_main.cpp]          if(double_back_slash) {
  //[CO20190419 - moved to aurostd_main.cpp]            // if we find one, but it has double backslash, leave alone
  //[CO20190419 - moved to aurostd_main.cpp]            // doesn't matter what it is, if it has double backslash it's good
  //[CO20190419 - moved to aurostd_main.cpp]            // if we find one, but it only has single backslash, add one
  //[CO20190419 - moved to aurostd_main.cpp]            if(i && i - 1 && input[i - 1] == '\\' && input[i - 2] == '\\') {break;}
  //[CO20190419 - moved to aurostd_main.cpp]            else if(i && input[i - 1] == '\\') {
  //[CO20190419 - moved to aurostd_main.cpp]              output.append(1, '\\');  // just add one
  //[CO20190419 - moved to aurostd_main.cpp]              break;
  //[CO20190419 - moved to aurostd_main.cpp]            }
  //[CO20190419 - moved to aurostd_main.cpp]            // if we find one, give two backslashes
  //[CO20190419 - moved to aurostd_main.cpp]            output.append("\\\\");
  //[CO20190419 - moved to aurostd_main.cpp]            break;
  //[CO20190419 - moved to aurostd_main.cpp]          } else {
  //[CO20190419 - moved to aurostd_main.cpp]            // if we find one, but it has single backslash, leave alone
  //[CO20190419 - moved to aurostd_main.cpp]            // doesn't matter what it is, if it has single backslash it's good
  //[CO20190419 - moved to aurostd_main.cpp]            // if we find one, give single backslash
  //[CO20190419 - moved to aurostd_main.cpp]            if(i && input[i - 1] == '\\') {break;}  
  //[CO20190419 - moved to aurostd_main.cpp]            output.append(1, '\\');
  //[CO20190419 - moved to aurostd_main.cpp]            break;
  //[CO20190419 - moved to aurostd_main.cpp]          }
  //[CO20190419 - moved to aurostd_main.cpp]        }
  //[CO20190419 - moved to aurostd_main.cpp]      }
  //[CO20190419 - moved to aurostd_main.cpp]      // we also have to add {} for these characters
  //[CO20190419 - moved to aurostd_main.cpp]      if(input[i] == '~' || input[i] == '^') {output.append("{}");}
  //[CO20190419 - moved to aurostd_main.cpp]      found_escaped_char = false;
  //[CO20190419 - moved to aurostd_main.cpp]      if(input[i] == '\\') {
  //[CO20190419 - moved to aurostd_main.cpp]        for(uint j=0,fl_size_j=problem_characters.size();j<fl_size_j;j++) {
  //[CO20190419 - moved to aurostd_main.cpp]          // the only way this works if it's serving as an escape for a character
  //[CO20190419 - moved to aurostd_main.cpp]          // don't worry about double backslash here, we get to that when we find
  //[CO20190419 - moved to aurostd_main.cpp]          // the actual character
  //[CO20190419 - moved to aurostd_main.cpp]          if(i != (input.length() - 1) && input[i+1] == problem_characters[j]) {
  //[CO20190419 - moved to aurostd_main.cpp]            found_escaped_char = true;
  //[CO20190419 - moved to aurostd_main.cpp]            break;  // doesn't matter what it is, if it has backslash it's good
  //[CO20190419 - moved to aurostd_main.cpp]          }
  //[CO20190419 - moved to aurostd_main.cpp]        }
  //[CO20190419 - moved to aurostd_main.cpp]        // this is a problem, no way around it--we cannot output single backslash
  //[CO20190419 - moved to aurostd_main.cpp]        if(!found_escaped_char) {
  //[CO20190419 - moved to aurostd_main.cpp]          stringstream message;
  //[CO20190419 - moved to aurostd_main.cpp]          message << "Extraneous backslash found in \"" << input << "\" which may cause problems for LaTeX/gnuplot";
  //[CO20190419 - moved to aurostd_main.cpp]          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_WARNING_);
  //[CO20190419 - moved to aurostd_main.cpp]          return input;
  //[CO20190419 - moved to aurostd_main.cpp]        }
  //[CO20190419 - moved to aurostd_main.cpp]      }
  //[CO20190419 - moved to aurostd_main.cpp]    }
  //[CO20190419 - moved to aurostd_main.cpp]    // add in character from input
  //[CO20190419 - moved to aurostd_main.cpp]    output.append(1, input[i]);
  //[CO20190419 - moved to aurostd_main.cpp]  }
  //[CO20190419 - moved to aurostd_main.cpp]  return output;
  //[CO20190419 - moved to aurostd_main.cpp]}

  string ConvexHull::getPlotHeaderPDF(char function_mode,const string& column_header,bool display_color_gradient) const {
    // produces addplot latex string
    string soliloquy=XPID+"ConvexHull::getPlotHeaderPDF():";
    stringstream message;
    stringstream addplot_output_ss;addplot_output_ss.str("");

    uint dimension=getDim();
    bool reverse_axes=DEFAULT_CHULL_LATEX_REVERSE_AXIS;

    // http://tex.stackexchange.com/questions/59070/pgfplots-remove-darker-borders-on-marks
    // this string WILL cause warnings when compiling, but it's correct, no way to
    // fix it with our current compiler
    stringstream tmp_dark_border_points_command;
    tmp_dark_border_points_command << "scatter/use mapped color={draw=black,fill=mapped color,solid}";

    string dark_border_points_command = tmp_dark_border_points_command.str();

    // first do a check that the function_mode is not out of scope
    if(dimension == 2) {
      if(function_mode != ADDPLOT_MODE_HULL_POINTS &&
          function_mode != ADDPLOT_MODE_OFF_HULL_POINTS &&
          function_mode != ADDPLOT_MODE_HULL_FACETS) {
        throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Input dimension mode (2D) and function mode mismatch");
      }
      if(m_velements.size() != 2) {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Input dimension mode (2D) and elements.size() mismatch");}
    } else if(dimension == 3) {
      if(function_mode != ADDPLOT_MODE_HULL_POINTS &&
          function_mode != ADDPLOT_MODE_OFF_HULL_POINTS &&
          function_mode != ADDPLOT_MODE_HULL_FACETS &&
          function_mode != ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS &&
          function_mode != ADDPLOT_MODE_HEAT_MAPS) {
        throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Input dimension mode (3D) and function mode mismatch");
      }
      if(m_velements.size() != 3) {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Input dimension mode (3D) and elements.size() mismatch");}
    } else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Input dimension mode out of scope");}

    //also check column_header
    bool found=false;
    for(uint i=0,fl_size_i=m_velements.size();i<fl_size_i;i++){found|=(column_header==m_velements[i]);}
    found|=(column_header=="H_f_meVatom");
    found|=(column_header=="H_f_kJmol");
    found|=(column_header=="T_S");
    found|=(column_header=="Dist2hull");
    if(!found){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Input column_header mode out of scope ("+column_header+")");}

    // main addplot function
    if(dimension == 2) {addplot_output_ss << "\\addplot+[" << endl;}
    else {  // dimension==3
      if(function_mode == ADDPLOT_MODE_HEAT_MAPS) {addplot_output_ss << "\\addplot3[" << endl;}
      else {addplot_output_ss << "\\addplot3+[" << endl;}
    }

    if(function_mode == ADDPLOT_MODE_HULL_FACETS ||
        function_mode == ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS) {
      addplot_output_ss << "mark=none," << endl;
      if(function_mode == ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS) {
        addplot_output_ss << "color=white," << endl;
        addplot_output_ss << "solid," << endl;
        addplot_output_ss << "line width=2.0pt," << endl;
      } else {  // function_mode==ADDPLOT_MODE_HULL_FACETS
        addplot_output_ss << "color=black," << endl;
        addplot_output_ss << "solid," << endl;
        if(dimension == 3) {addplot_output_ss << "line width=2pt," << endl;}
      }
      addplot_output_ss << "] table ";
      if(dimension == 2) {
        if(reverse_axes){addplot_output_ss << "[x=" << m_velements[0];}
        else {addplot_output_ss << "[x=" << m_velements[1];}
        addplot_output_ss << ",y=" << column_header;
        addplot_output_ss << "]";
      } else {  // dimension==3
        addplot_output_ss << "[x=" << m_velements[1];
        addplot_output_ss << ",y=" << m_velements[0];
        addplot_output_ss << ",z=" << m_velements[2] << "]";  // flipping x and y
      }
    } else {  // function_mode==ADDPLOT_MODE_HULL_POINTS||function_mode==ADDPLOT_MODE_OFF_HULL_POINTS||function_mode==ADDPLOT_MODE_HEAT_MAPS
      if(function_mode == ADDPLOT_MODE_HEAT_MAPS) {
        addplot_output_ss << "patch," << endl;
        addplot_output_ss << "patch type=triangle," << endl;
        addplot_output_ss << "shader=interp," << endl;
      } else {
        addplot_output_ss << "only marks," << endl;  // IMPORTANT, no lines
        if(function_mode == ADDPLOT_MODE_HULL_POINTS) {
          addplot_output_ss << "mark=*," << endl;
          if(dimension == 2) {addplot_output_ss << "mark size=4," << endl;}
          else {  // dimension==3
            addplot_output_ss << "mark size=5," << endl;
            addplot_output_ss << "line width=2pt," << endl;
          }
        } else {  // function_mode==ADDPLOT_MODE_OFF_HULL_POINTS
          addplot_output_ss << "mark=x," << endl;
          addplot_output_ss << "mark options={scale=2,line width=2,solid";
        }
      }
      if(display_color_gradient || function_mode == ADDPLOT_MODE_HEAT_MAPS) {  
        // this OR statement doesn't practically matter, since one does not work without the other, 
        // but I keep it here so that the output of the string is complete
        if(function_mode == ADDPLOT_MODE_OFF_HULL_POINTS) {addplot_output_ss << "}," << endl;}
        addplot_output_ss << "point meta=\\thisrow{" << column_header << "}," << endl;  // uses point meta as color data
        addplot_output_ss << "nodes near coords*={}," << endl;  // no labels, but we need this for colors
        // GOT IT! // http://tex.stackexchange.com/questions/59070/pgfplots-remove-darker-borders-on-marks
        if(function_mode == ADDPLOT_MODE_HULL_POINTS) {addplot_output_ss << dark_border_points_command << "," << endl;}
        addplot_output_ss << "visualization depends on={\\thisrow{" << column_header << "} \\as \\" << column_header << "}," << endl;  // defines visualization dependency
      } else {
        if(function_mode == ADDPLOT_MODE_HULL_POINTS) {addplot_output_ss << "mark options={draw=black,fill=blue,solid}," << endl;}
        else {addplot_output_ss << ",draw=red}," << endl;}// function_mode==ADDPLOT_MODE_OFF_HULL_POINTS
      }
      addplot_output_ss << "] table ";
      if(dimension == 2) {
        if(reverse_axes){addplot_output_ss << "[x=" << m_velements[0];}
        else {addplot_output_ss << "[x=" << m_velements[1];}
        addplot_output_ss << ",y=" << column_header;
        addplot_output_ss << "]";
      } else {  // dimension==3
        addplot_output_ss << "[x=" << m_velements[1];
        addplot_output_ss << ",y=" << m_velements[0];
        addplot_output_ss << ",z=" << m_velements[2] << "]";  // flipping x and y
      }
    }
    addplot_output_ss << "{" << endl;
    for(uint i=0,fl_size_i=m_velements.size();i<fl_size_i;i++){addplot_output_ss << aurostd::PaddedPOST(m_velements[i], 30);}
    addplot_output_ss << aurostd::PaddedPOST("H_f_meVatom", 30);
    addplot_output_ss << aurostd::PaddedPOST("H_f_kJmol", 30);
    addplot_output_ss << aurostd::PaddedPOST("T_S", 30);
    if(PRINT_DIST2HULL_COL_TEX){
      addplot_output_ss << aurostd::PaddedPOST("Dist2hull", 30);
    }
    addplot_output_ss << endl;

    return addplot_output_ss.str();
  }

  string ConvexHull::getPlotPointContentPDF(const ChullPoint& point,bool zero_end_point,bool zero_dist_2_hull) const {  //true,false
    bool LDEBUG = (FALSE || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getPlotPointContentPDF():";
    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}

    // initializations
    stringstream addplot_output_ss;
    // no precision
    stringstream num_ss;

    // explicit dimensions
    for(int i=point.s_coords.lrows;i<=point.s_coords.urows;i++) {
      addplot_output_ss << aurostd::PaddedPOST(aurostd::utype2string(point.s_coords[i],FULL_PRECISION), 30);
    }
    // enthalpy of formation, row 4
    // fix for unaries, set to 0
    if((zero_end_point && point.isUnary()) || !point.m_has_entry) {  // IMPORTANT, these must go through 0
      // no need for precision for next few columns, leave it same way as received from AFLOW
      addplot_output_ss << aurostd::PaddedPOST(0, 30); //aurostd::PaddedPOST(aurostd::utype2string(0.0,CHULL_PRECISION,false,ROUNDOFF_TOL,FIXED_STREAM), 30);
      //H_f but in units of kJ/mol, row 5
      addplot_output_ss << aurostd::PaddedPOST(0, 30); //aurostd::PaddedPOST(aurostd::utype2string(0.0,CHULL_PRECISION,false,ROUNDOFF_TOL,FIXED_STREAM), 30);
      // entropic temperature, row 6
      addplot_output_ss << aurostd::PaddedPOST(0, 30); //aurostd::PaddedPOST(aurostd::utype2string(0.0,CHULL_PRECISION,false,ROUNDOFF_TOL,FIXED_STREAM), 30);
    } else {
      // no need for precision for next few columns, leave it same way as received from AFLOW
      num_ss << chull::H_f_atom(point, _m_);
      addplot_output_ss << aurostd::PaddedPOST(num_ss.str(), 30);
      num_ss.str("");
      //H_f but in units of kJ/mol, row 5
      num_ss << meVatom2kJmol * chull::H_f_atom(point, _m_);
      addplot_output_ss << aurostd::PaddedPOST(num_ss.str(), 30);
      num_ss.str("");
      // entropic temperature, row 6
      num_ss << chull::T_S(point);
      addplot_output_ss << aurostd::PaddedPOST(num_ss.str(), 30);
      num_ss.str("");
    }
    if(PRINT_DIST2HULL_COL_TEX){
      // dist_2_hull, row 7
      if(zero_dist_2_hull) {addplot_output_ss << aurostd::PaddedPOST(0, 30);} //aurostd::PaddedPOST(aurostd::utype2string(0.0,CHULL_PRECISION,false,ROUNDOFF_TOL,FIXED_STREAM), 30);
      else {addplot_output_ss << aurostd::PaddedPOST(aurostd::utype2string(point.getDist2Hull(_m_),CHULL_PRECISION), 30);}
    }
    // end line
    addplot_output_ss << endl;
    if(LDEBUG) {cerr << soliloquy << " done" << endl;}
    return addplot_output_ss.str();
  }

  string ConvexHull::getNodeCoordPosition(const ChullPoint& point) const {
    if(!point.m_has_entry){
      string soliloquy=XPID+"ConvexHull::getNodeCoordPosition():";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No entry found");
    }
    return getNodeCoordPosition(point.m_entry,point.m_coords);
  }

  string ConvexHull::getNodeCoordPosition(const aflowlib::_aflowlib_entry& entry,const xvector<double>& coord) const {
    bool LDEBUG = (FALSE || XHOST.DEBUG);
    // produces node latex output
    string soliloquy=XPID+"ConvexHull::getNodeCoordPosition():";
    stringstream message;
    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}

    double sum_C;
    stringstream output;
    // no precision
    stringstream num_ss;

    uint dimension=getDim();
    bool reverse_axes=DEFAULT_CHULL_LATEX_REVERSE_AXIS;

    // first do a check that the function_mode is not out of scope
    if(dimension == 2) {
      if(coord.rows != 2) {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Input dimension mode (2D) and coordinate size mismatch");}
    } else if(dimension == 3) {
      if(coord.rows != 3) {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Input dimension mode (3D) and coordinate size mismatch");}
    } else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Input dimension mode out of scope");}

    output << "axis cs:";  // define axis as relevant "coordinate system"

    if(dimension == 2) {
      // don't need for loop, just 1 coord
      if(!reverse_axes) {output << aurostd::utype2string(1.0 - coord[coord.lrows],FULL_PRECISION);}
      else {output << aurostd::utype2string(coord[coord.lrows],FULL_PRECISION);}
      output << ",";
      if(m_formation_energy_hull) {
        num_ss << chull::H_f_atom(entry, _m_);
        output << num_ss.str();
        num_ss.str("");
      } else {
        num_ss << chull::T_S(entry);
        output << num_ss.str();
        num_ss.str("");
      }
    } else {  // dimension==3
      sum_C = 0.0;
      for(int j=coord.urows-1;j>=coord.lrows;j--) {
        output << aurostd::utype2string(coord[j],FULL_PRECISION);
        output << ",";
        sum_C += coord[j];
      }
      output << aurostd::utype2string(1.0-sum_C,FULL_PRECISION);
    }
    if(LDEBUG) {cerr << soliloquy << " done" << endl;}
    return output.str();
  }

  string ConvexHull::nodeCreator(stringstream& option, stringstream& position, stringstream& content) const {
    string _option = option.str();
    string _position = position.str();
    string _content = content.str();
    option.str("");
    position.str("");
    content.str("");
    return nodeCreator(_option, _position, _content);
  }

  string ConvexHull::nodeCreator(const string& option, const string& position, const string& content) const {
    // produces node latex output
    stringstream output;
    output << "\\node ";
    if(!option.empty()) {output << "[" << option << "] ";}
    if(!position.empty()) {output << "at (" << position << ") ";}
    if(!content.empty()) {output << "{" << content << "};";}
    output << endl;
    return output.str();
  }

  bool ConvexHull::unwantedFacetLine(uint vi,uint vj,bool check_border) const {  //bool check_border = true;
    vector<vector<uint> > facet_lines;
    return unwantedFacetLine(vi, vj, facet_lines, check_border);
  }

  bool ConvexHull::unwantedFacetLine(uint vi,uint vj,vector<vector<uint> >& facet_lines,bool check_border) const {  //bool check_border = true;
    // checks if the facet created by this combination of chullPoints is necessary
    // for 3D hull
    bool LDEBUG = (FALSE || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::unwantedFacetLine():";
    if(LDEBUG) {cerr << soliloquy << " starting" << endl;}
    if(vi>m_points.size()-1 || vj>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
    if(check_border) {
      const ChullPoint& ci=m_points[vi];
      const ChullPoint& cj=m_points[vj];
      const xvector<double>& coordAR = ci.getStoichiometricCoords();
      const xvector<double>& coordBR = cj.getStoichiometricCoords();
      bool endpointA = ci.isUnary();
      bool endpointB = cj.isUnary();
      const aflowlib::_aflowlib_entry& entryA = ci.m_entry;
      const aflowlib::_aflowlib_entry& entryB = cj.m_entry;
      // unary to unary
      if(endpointA && endpointB) {
        if(LDEBUG) {cerr << soliloquy << " unary to unary" << endl;}
        return true;
      }
      // unary to binary, only if dot product of coords is not 0 (unary to crossing binary line)
      if(endpointA && entryB.vspecies.size() == 2 && scalar_product(coordAR, coordBR) >= ZERO_TOL) {
        if(LDEBUG) {cerr << soliloquy << " unary to binary" << endl;}
        return true;
      }
      // binary to unary, only if dot product of coords is not 0 (unary to crossing binary line)
      if(entryA.vspecies.size() == 2 && endpointB && scalar_product(coordAR, coordBR) >= ZERO_TOL) {
        if(LDEBUG) {cerr << soliloquy << " binary to unary" << endl;}
        return true;
      }
      // binary to binary, if same species
      if(entryA.vspecies.size() == 2 && entryA.vspecies == entryB.vspecies) {
        if(LDEBUG) {cerr << soliloquy << " binary to binary" << endl;}
        return true;
      }
    }
    // check that this combination is unique,
    // only pairs inside facet_lines!!!
    // chullPoints, so we're only interested in compositional components of
    // xvector, not the energy
    for(uint i=0,fl_size_i=facet_lines.size();i<fl_size_i;i++) {
      if(facet_lines[i][0]==vi && facet_lines[i][1]==vj){
        if(LDEBUG) {
          cerr << soliloquy << " found match! ";
          cerr << facet_lines[i][0] << "==" << vi;
          cerr << ", ";
          cerr << facet_lines[i][1] << "==" << vj;
          cerr << endl;
        }
        return true;
      }
      if(facet_lines[i][0]==vj && facet_lines[i][1]==vi){
        if(LDEBUG) {
          cerr << soliloquy << " found match! ";
          cerr << facet_lines[i][0] << "==" << vj;
          cerr << ", ";
          cerr << facet_lines[i][1] << "==" << vi;
          cerr << endl;
        }
        return true;
      }
    }
    facet_lines.push_back(vector<uint>(0));
    facet_lines.back().push_back(vi);
    facet_lines.back().push_back(vj);
    if(LDEBUG) {cerr << soliloquy << " saving facet lines: " << vi << "," << vj << endl;}
    return false;
  }

  string ConvexHull::getPointsPropertyHeaderList(filetype ftype) const {
    bool m_formation_energy_hull=!m_cflags.flag("CHULL::ENTROPIC_TEMPERATURE");    //energy vs. entropic_temperature hull
    bool compounds_column_report=false;
    if(ftype==latex_ft){
      compounds_column_report=DEFAULT_CHULL_LATEX_COMPOUNDS_COLUMN; //only grab if necessary, not an inexpensive string search
    }

    string headers="";
    if(!(ftype==latex_ft && !compounds_column_report)){headers+=(!headers.empty()?string(","):string(""))+"compound";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"reduced_compound";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"reduced_compound_latex";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"fractional_compound";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"fractional_compound_latex";}
    headers+=(!headers.empty()?string(","):string(""))+"prototype";
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"prototype_latex";}
    headers+=(!headers.empty()?string(","):string(""))+"auid";
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"aurl";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"url_entry_page";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"nspecies";}
    headers+=(!headers.empty()?string(","):string(""))+"space_group_orig";
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"space_group_orig_latex";}
    headers+=(!headers.empty()?string(","):string(""))+"space_group_relax";
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"space_group_relax_latex";}
    headers+=(!headers.empty()?string(","):string(""))+"spin_atom";
    headers+=(!headers.empty()?string(","):string(""))+"enthalpy_formation_atom";
    headers+=(!headers.empty()?string(","):string(""))+"entropic_temperature";
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"ground_state";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"equivalent_structures_auid";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"icsd_ground_state";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"icsd_canonical_auid";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"phases_equilibrium_compound";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"phases_equilibrium_auid";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"phases_decomposition_compound";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"phases_decomposition_auid";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"phases_decomposition_coefficient";}
    if(m_formation_energy_hull){headers+=(!headers.empty()?string(","):string(""))+"enthalpy_formation_atom_difference";}
    else {headers+=(!headers.empty()?string(","):string(""))+"entropic_temperature_difference";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"stability_criterion";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"relative_stability_criterion";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"N+1_enthalpy_gain";}
    if(ftype==txt_ft || ftype==json_ft){headers+=(!headers.empty()?string(","):string(""))+"entropy_stabilization_coefficient";}

    return headers;
  }

  string ConvexHull::getDelta(bool helvetica_font) const {return (helvetica_font?"\\Updelta":"\\Delta");}

  string ConvexHull::getSnapshotTableHeader(string headers,bool designate_HEADER) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getSnapshotTableHeader():";
    vector<string> vheaders,vlabels;
    vector<uint> vpaddings;
    aurostd::string2tokens(headers,vheaders,",");
    bool helvetica_font=DEFAULT_CHULL_LATEX_HELVETICA_FONT;

    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]if(0){  //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  vector<string> valignments_headertable_string;
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  for(uint i=0,fl_size_i=vheaders.size();i<fl_size_i;i++){
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    if(vheaders[i]=="compound"){vlabels.push_back("compound"); vpaddings.push_back(80); valignments_headertable_string.push_back("X[3,c,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    else if(vheaders[i]=="prototype"){vlabels.push_back("prototype"); vpaddings.push_back(80); valignments_headertable_string.push_back("X[3,c,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    else if(vheaders[i]=="auid"){vlabels.push_back("auid"); vpaddings.push_back(80); valignments_headertable_string.push_back("X[3,c,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    else if(vheaders[i]=="space_group_orig"){vlabels.push_back("original space group"); vpaddings.push_back(30); valignments_headertable_string.push_back("X[2,c,m]");} //SG original
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    else if(vheaders[i]=="space_group_relax"){vlabels.push_back("relaxed space group"); vpaddings.push_back(30); valignments_headertable_string.push_back("X[2,c,m]");} //SG relax
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    else if(vheaders[i]=="spin_atom"){vlabels.push_back("spin $\\left(\\mu_{\\mathrm{B}}\\mathrm{/atom}\\right)$"); vpaddings.push_back(30); valignments_headertable_string.push_back("X[2,c,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    else if(vheaders[i]=="enthalpy_formation_atom"){vlabels.push_back("$H_{\\mathrm{f}}$ (meV/atom)"); vpaddings.push_back(30); valignments_headertable_string.push_back("X[2,c,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    else if(vheaders[i]=="entropic_temperature"){vlabels.push_back("$T_{\\mathrm{S}}$ (K)"); vpaddings.push_back(30); valignments_headertable_string.push_back("X[2,c,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    else if(vheaders[i]=="enthalpy_formation_atom_difference"){vlabels.push_back("$"+getDelta(helvetica_font)+" H_{\\mathrm{f}}$ (meV/atom)"); vpaddings.push_back(30); valignments_headertable_string.push_back("X[2,c,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    else if(vheaders[i]=="entropic_temperature_difference"){vlabels.push_back("$"+getDelta(helvetica_font)+" T_{\\mathrm{S}}$ (K)"); vpaddings.push_back(30); valignments_headertable_string.push_back("X[2,c,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]    else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown property");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  }
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]}

    vector<uint> valignments_headertable_uint;
    uint total_alignment=0;
    for(uint i=0,fl_size_i=vheaders.size();i<fl_size_i;i++){
      if(vheaders[i]=="compound"){vlabels.push_back("compound"); vpaddings.push_back(80); valignments_headertable_uint.push_back(3); total_alignment+=valignments_headertable_uint.back();}
      else if(vheaders[i]=="prototype"){vlabels.push_back("prototype"); vpaddings.push_back(80); valignments_headertable_uint.push_back(3); total_alignment+=valignments_headertable_uint.back();}
      else if(vheaders[i]=="auid"){vlabels.push_back("auid"); vpaddings.push_back(80); valignments_headertable_uint.push_back(3); total_alignment+=valignments_headertable_uint.back();}
      else if(vheaders[i]=="space_group_orig"){vlabels.push_back("original space group"); vpaddings.push_back(30); valignments_headertable_uint.push_back(2); total_alignment+=valignments_headertable_uint.back();} //SG original
      else if(vheaders[i]=="space_group_relax"){vlabels.push_back("relaxed space group"); vpaddings.push_back(30); valignments_headertable_uint.push_back(2); total_alignment+=valignments_headertable_uint.back();} //SG relax
      else if(vheaders[i]=="spin_atom"){vlabels.push_back("spin $\\left(\\mu_{\\mathrm{B}}\\mathrm{/atom}\\right)$"); vpaddings.push_back(30); valignments_headertable_uint.push_back(2); total_alignment+=valignments_headertable_uint.back();}
      else if(vheaders[i]=="enthalpy_formation_atom"){vlabels.push_back("$H_{\\mathrm{f}}$ (meV/atom)"); vpaddings.push_back(30); valignments_headertable_uint.push_back(2); total_alignment+=valignments_headertable_uint.back();}
      else if(vheaders[i]=="entropic_temperature"){vlabels.push_back("$T_{\\mathrm{S}}$ (K)"); vpaddings.push_back(30); valignments_headertable_uint.push_back(2); total_alignment+=valignments_headertable_uint.back();}
      else if(vheaders[i]=="enthalpy_formation_atom_difference"){vlabels.push_back("$"+getDelta(helvetica_font)+" H_{\\mathrm{f}}$ (meV/atom)"); vpaddings.push_back(30); valignments_headertable_uint.push_back(2); total_alignment+=valignments_headertable_uint.back();}
      else if(vheaders[i]=="entropic_temperature_difference"){vlabels.push_back("$"+getDelta(helvetica_font)+" T_{\\mathrm{S}}$ (K)"); vpaddings.push_back(30); valignments_headertable_uint.push_back(2); total_alignment+=valignments_headertable_uint.back();}
      else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown property");}
    }

    vector<string> vlabels_styled;
    for(uint i=0,fl_size_i=vlabels.size();i<fl_size_i;i++){vlabels_styled.push_back(aurostd::PaddedPOST("{\\footnotesize "+vlabels[i]+"}", vpaddings[i]));}  //used to be small before auid

    double page_width=(LATEX_WIDTH_LETTER_STD-(LATEX_LEFT_MARGIN_LETTER_STD+LATEX_RIGHT_MARGIN_LETTER_STD));
    double penalty_tabcolsep=2*LATEX_TABCOLSEP_STD*LATEX_PT2INCH; //there are two colsep for reach column, then convert to inches
    double penalty_arrayrulewidth=(valignments_headertable_uint.size()+1)*LATEX_ARRAYRULEWIDTH_STD*LATEX_PT2INCH/(valignments_headertable_uint.size()); //there are columns+1 separators, then convert to inches, then convert to per column penalty

    vector<string> valignments_headertable_string;
    double page_width_fraction=0.0;
    for(uint i=0,fl_size_i=valignments_headertable_uint.size();i<fl_size_i;i++){
      page_width_fraction=page_width*(double)valignments_headertable_uint[i]/(double)total_alignment;
      valignments_headertable_string.push_back("X{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}"); 
      if(LDEBUG) {cerr << soliloquy << " " << valignments_headertable_string.back() << endl;}
    }

    stringstream output;
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]output << "\\begin{tabu}{|" << aurostd::joinWDelimiter(valignments_headertable_string,"|") << "|}" << (designate_HEADER?" \%HEADER":"") << endl;
    output << "\\begin{tabular}{|" << aurostd::joinWDelimiter(valignments_headertable_string,"|") << "|}" << (designate_HEADER?" \%HEADER":"") << endl;
    output << "\\toprule" << (designate_HEADER?" \%HEADER":"") << endl;
    output << aurostd::PaddedPOST("\\rowcolor{white}", 30) << " " << aurostd::joinWDelimiter(vlabels_styled," & ") << " \\\\" << (designate_HEADER?" \%HEADER":"") << endl;
    output << "\\midrule" << (designate_HEADER?" \%HEADER":"") << endl;
    output << "\\end{tabular}" << (designate_HEADER?" \%HEADER":"") << endl;
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]output << "\\end{tabu}" << (designate_HEADER?" \%HEADER":"") << endl;

    return output.str();
  }

  bool ConvexHull::addInternalHyperlinks(bool internal_links_graph2report,bool internal_links_withinreport) const {
    int links_setting=DEFAULT_CHULL_LATEX_LINKS;
    bool kill_all_links=(links_setting==0); //no links whatsoever
    bool no_internal_links=(links_setting==2);       //no jumping
    bool image_only=m_cflags.flag("CHULL::IMAGE_ONLY");
    if(image_only){kill_all_links=true;}
    if(kill_all_links){no_internal_links=true;}      //no jumping
    if((!internal_links_graph2report)&&(!internal_links_withinreport)){no_internal_links=true;}
    return !no_internal_links;
  }

  bool ConvexHull::addExternalHyperlinks() const {
    int links_setting=DEFAULT_CHULL_LATEX_LINKS;
    bool kill_all_links=(links_setting==0); //no links whatsoever
    bool no_external_links=(links_setting==3);  //no weblinks
    bool image_only=m_cflags.flag("CHULL::IMAGE_ONLY");
    if(image_only){kill_all_links=true;}
    if(kill_all_links){no_external_links=true;} //no weblinks
    return !no_external_links;
  }

  double ConvexHull::getRoundToValue(double point_range) const {
    int order_of_mag = log10(point_range);
    if(order_of_mag<1){order_of_mag=1;} //we need to work with integers since units are meV/atom, anything less is really just noise
    double round_to_value=pow(10, order_of_mag-1) * 2.5;  //round to nearest 2.5, 25, 250
    return round_to_value;
  }

  double ConvexHull::getYTickDistance(double y_range,int approx_num_ticks,double round_to_value) const {
    bool LDEBUG = (FALSE || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getYTickDistance():";
    if(LDEBUG) {
      cerr << soliloquy << " y_range=" << y_range << endl;
      cerr << soliloquy << " approx_num_ticks=" << approx_num_ticks << endl;
      cerr << soliloquy << " round_to_value=" << round_to_value << endl;
    }
    double delta,delta_pow;
    delta=delta_pow=y_range/(double)approx_num_ticks;
    int exponent=0;
    while(delta_pow<round_to_value){exponent+=1;delta_pow=delta*pow(10,exponent);}
    delta=delta_pow;
    int y_tick_distance_int;
    y_tick_distance_int=roundDouble(delta,(int)round_to_value,false);  //divisor is ~ # of ticks  //CO20190724 - explicit double->int conversion (floor is fine)
    if(y_tick_distance_int==0){ //aflow_BSm_hull.pdf, we need some NONZERO y_tick_distance_int
      y_tick_distance_int=roundDouble(delta,(int)round_to_value,true);  //divisor is ~ # of ticks //CO20190724 - explicit double->int conversion (floor is fine)
    }
    double y_tick_distance=y_tick_distance_int*pow(10,-exponent);
    if(LDEBUG) {
      cerr << soliloquy << " y_tick_distance=" << y_tick_distance << endl;
    }
    return y_tick_distance;
  }

  vector<string> ConvexHull::grabAcceptableLatexColors(bool replace_pranab_standard,bool allow_dvips_colors,uint count) const {
    vector<string> banned_colors;
    return grabAcceptableLatexColors(banned_colors,replace_pranab_standard,allow_dvips_colors,count);
  }
  vector<string> ConvexHull::grabAcceptableLatexColors(const string& banned_colors_str,bool replace_pranab_standard,bool allow_dvips_colors,uint count) const {
    vector<string> banned_colors;
    aurostd::string2tokens(banned_colors_str,banned_colors,",");
    return grabAcceptableLatexColors(banned_colors,replace_pranab_standard,allow_dvips_colors,count);
  }
  vector<string> ConvexHull::grabAcceptableLatexColors(const vector<string>& banned_colors,bool replace_pranab_standard,bool allow_dvips_colors,uint count) const{
    vector<string> _latex_colors,latex_colors;
    string color,lower_color,colors=LATEX_DEFAULT_COLORS;
    uint loop=0;
    while(true){
      aurostd::string2tokens(colors,_latex_colors,",");
      for(uint i=0,fl_size_i=_latex_colors.size();i<fl_size_i;i++){
        color=_latex_colors[i];
        lower_color=aurostd::tolower(color);
        if(aurostd::WithinList(banned_colors,lower_color)){continue;}
        if(replace_pranab_standard&&(lower_color=="green"||lower_color=="red")){color="pranab_"+lower_color;}  //now in pranab standard!
        latex_colors.push_back(color);
        if(latex_colors.size()==count){return latex_colors;}
      }
      if(allow_dvips_colors&&(loop++%2==0)){colors=LATEX_DVIPS_COLORS;}
      else {colors=LATEX_DEFAULT_COLORS;}
    }
    return latex_colors;
  }

  aurostd::xoption ConvexHull::resolvePlotLabelSettings() const {
    string soliloquy=XPID+"ConvexHull::resolvePlotLabelSettings():";
    stringstream message;

    bool labels_off_hull=DEFAULT_CHULL_LATEX_LABELS_OFF_HULL;
    bool meta_labels=DEFAULT_CHULL_LATEX_META_LABELS;
    bool compound_labels=true;  //default is to show compound labels only, for binaries this will be ground-state dependent
    bool prototype_labels=(getDim()==2 && labels_off_hull); //default is to show prototype labels for binaries, with compounds labels on ground-states for reference
    bool icsd_labels=false;
    bool no_labels=false;
    string label_options=DEFAULT_CHULL_LATEX_LABEL_NAME;
    bool plot_labels=(!label_options.empty());           //overarching flag, mostly for getting options
    if(plot_labels){
      compound_labels=prototype_labels=icsd_labels=no_labels=false; //kill defaults
      vector<string> vlabelstring;
      aurostd::string2tokens(label_options,vlabelstring, ",");
      for(uint i=0,fl_size_i=vlabelstring.size();i<fl_size_i;i++) {
        if(vlabelstring[i][0] == 'B' || vlabelstring[i][0] == 'b') {  // both
          compound_labels=true;
          prototype_labels=true;
          no_labels=false;
          break;
        } else if(vlabelstring[i][0] == 'I' || vlabelstring[i][0] == 'i') {  // ICSD
          icsd_labels=true;
          no_labels=false;
          if(!compound_labels&&!prototype_labels){compound_labels=true;}  //default for icsd
        } else if(vlabelstring[i][0] == 'N' || vlabelstring[i][0] == 'n' || vlabelstring[i][0] == 'O' || vlabelstring[i][0] == 'o') {  // none,off
          compound_labels=false;
          prototype_labels=false;
          icsd_labels=false;
          meta_labels=false;
          no_labels=true;
          break;
        } else if(vlabelstring[i][0] == 'C' || vlabelstring[i][0] == 'c') {  // compound
          compound_labels=true;
          no_labels=false;
        } else if(vlabelstring[i][0] == 'P' || vlabelstring[i][0] == 'p') {  // prototype
          prototype_labels=true;
          no_labels=false;
        } else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Incorrect input for plot labels \""+vlabelstring[i]+"\"");}
      }
    }
    if(no_labels){
      if(labels_off_hull){
        //[verbose once in writeLatex()]message << "LABEL_NAME set to NONE but LABELS_OFF_HULL requested (fix .aflow.rc), toggling LABELS_OFF_HULL off"
        //[verbose once in writeLatex()]pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        labels_off_hull=false;
      }
      if(meta_labels){
        //[verbose once in writeLatex()]message << "LABEL_NAME set to NONE but META_LABELS requested (fix .aflow.rc), toggling META_LABELS off"
        //[verbose once in writeLatex()]pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        meta_labels=false;
      }
    }
    aurostd::xoption lflags;
    lflags.flag("CHULL::PLOT_LABELS",plot_labels);
    lflags.flag("CHULL::PLOT_LABELS_OFF_HULL",labels_off_hull);
    lflags.flag("CHULL::PLOT_META_LABELS",meta_labels);
    lflags.flag("CHULL::PLOT_COMPOUND_LABELS",compound_labels);
    lflags.flag("CHULL::PLOT_PROTOTYPE_LABELS",prototype_labels);
    lflags.flag("CHULL::PLOT_ICSD_LABELS",icsd_labels);
    lflags.flag("CHULL::PLOT_NO_LABELS",no_labels);
    return lflags;
  }

  void ConvexHull::writeLatex() const {
    bool LDEBUG = (FALSE || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::writeLatex():";
    stringstream message;
    if(!aurostd::IsCommandAvailable("pdflatex")) {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"\"pdflatex\" needs to be in your path");}
    if(m_cflags.flag("CHULL::PNG_IMAGE")){
      if(!aurostd::IsCommandAvailable("convert")) {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"\"convert\" needs to be in your path");}
    }
    message << "Starting LaTeX PDF generator";
    pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);

    //////////////////////////////////////////////////////////////////////////////
    // START Getting hull attributes
    //////////////////////////////////////////////////////////////////////////////

    uint dimension=getDim();
    vector<uint> hull_points=getHullPoints(false);
    bool draw_all_facet_lines=false;  //only draw uniques, keep FALSE
    bool include_equilibrium_phases=true; //keep true

    //USER INPUTS
    bool doc_only=m_cflags.flag("CHULL::DOC_ONLY");
    bool no_doc=m_cflags.flag("CHULL::NO_DOC");
    bool image_only=m_cflags.flag("CHULL::IMAGE_ONLY");
    bool light_contrast=m_cflags.flag("CHULL::LIGHT_CONTRAST");
    bool large_font=m_cflags.flag("CHULL::LARGE_FONT");
    bool keep_tex=m_cflags.flag("CHULL::KEEP_TEX");
    bool show_latex_output=m_cflags.flag("CHULL::LATEX_OUTPUT");
    bool latex_interactive_mode=m_cflags.flag("CHULL::LATEX_INTERACTIVE");

    //FROM AFLOWRC
    bool print_aflow_logo_full=_AFLOW_CHULL_PRINT_LOGO_1;  //otherwise print aflow_text
    bool print_aflow_text_logo=false;
    if(print_aflow_logo_full&&print_aflow_text_logo){print_aflow_text_logo=false;}
    bool print_logo_2=_AFLOW_CHULL_PRINT_LOGO_2;
    bool print_aflow_webaddress_logo=true;
    if(print_logo_2&&print_aflow_webaddress_logo){print_aflow_webaddress_logo=false;}
    int banner_setting=DEFAULT_CHULL_LATEX_BANNER;
    bool no_banner=(banner_setting==0);
    bool small_banner=(banner_setting==2||image_only);
    if(no_banner&&small_banner){small_banner=false;}
    if(small_banner&&(image_only||no_doc)){print_aflow_logo_full=print_logo_2=false;}
    bool compounds_column_report=DEFAULT_CHULL_LATEX_COMPOUNDS_COLUMN;
    bool stoich_header_report=DEFAULT_CHULL_LATEX_STOICH_HEADER;
    bool plot_unaries=DEFAULT_CHULL_LATEX_PLOT_UNARIES;
    string filter_scheme=DEFAULT_CHULL_LATEX_FILTER_SCHEME;
    bool filter_by_z=(!filter_scheme.empty() && (aurostd::toupper(filter_scheme)[0]=='Z' || aurostd::toupper(filter_scheme)[0]=='E'));
    bool filter_by_distance=(!filter_scheme.empty() && aurostd::toupper(filter_scheme)[0]=='D');
    double filter_cutoff=DEFAULT_CHULL_LATEX_FILTER_VALUE;

    int plot_off_hull_setting=DEFAULT_CHULL_LATEX_PLOT_OFF_HULL;     //does not include unstable
    bool plot_off_hull;
    if(plot_off_hull_setting==-1){plot_off_hull=(getDim()==2?true:false);}
    else {plot_off_hull=(plot_off_hull_setting==0?false:true);}
    if(filter_by_z||filter_by_distance){plot_off_hull=true;}

    bool plot_unstable=DEFAULT_CHULL_LATEX_PLOT_UNSTABLE;
    bool reverse_axes=DEFAULT_CHULL_LATEX_REVERSE_AXIS;

    bool display_color_gradient=DEFAULT_CHULL_LATEX_COLOR_GRADIENT;
    bool include_color_bar=DEFAULT_CHULL_LATEX_COLOR_BAR;
    bool show_heat_map=DEFAULT_CHULL_LATEX_HEAT_MAP;
    if(!display_color_gradient){
      include_color_bar=false;
      show_heat_map=false;
    }

    bool hull_drop_shadow=DEFAULT_CHULL_LATEX_FACET_LINE_DROP_SHADOW;  //gus paper

    string ternary_label_color_setting=DEFAULT_CHULL_LATEX_TERNARY_LABEL_COLOR;
    string ternary_label_color=(ternary_label_color_setting.empty()?"white":ternary_label_color_setting);
    if(hull_drop_shadow&&ternary_label_color=="white"){ternary_label_color="yellow";} //white doesn't work here
    if(!show_heat_map&&(ternary_label_color=="white"||ternary_label_color=="yellow")){ternary_label_color="black";} //white/yellow doesn't work here

    string color_map_setting=DEFAULT_CHULL_LATEX_COLOR_MAP;
    string color_map=(color_map_setting.empty()?"rgb(0pt)=(0,0,1); rgb(63pt)=(1,0.644,0)":color_map_setting);

    //labels options
    aurostd::xoption lflags=resolvePlotLabelSettings();
    bool plot_labels=lflags.flag("CHULL::PLOT_LABELS");
    bool labels_off_hull=lflags.flag("CHULL::PLOT_LABELS_OFF_HULL");
    bool meta_labels=lflags.flag("CHULL::PLOT_META_LABELS");
    bool compound_labels=lflags.flag("CHULL::PLOT_COMPOUND_LABELS");
    bool prototype_labels=lflags.flag("CHULL::PLOT_PROTOTYPE_LABELS");
    bool icsd_labels=lflags.flag("CHULL::PLOT_ICSD_LABELS");
    bool no_labels=lflags.flag("CHULL::PLOT_NO_LABELS");
    //[MOVED to resolvePlotLabelSettings()]bool labels_off_hull=DEFAULT_CHULL_LATEX_LABELS_OFF_HULL;
    //[MOVED to resolvePlotLabelSettings()]bool meta_labels=DEFAULT_CHULL_LATEX_META_LABELS;
    //[MOVED to resolvePlotLabelSettings()]bool compound_labels=true;  //default is to show compound labels only, for binaries this will be ground-state dependent
    //[MOVED to resolvePlotLabelSettings()]bool prototype_labels=(getDim()==2 && labels_off_hull); //default is to show prototype labels for binaries, with compounds labels on ground-states for reference
    //[MOVED to resolvePlotLabelSettings()]bool icsd_labels=false;
    //[MOVED to resolvePlotLabelSettings()]bool no_labels=false;
    //[MOVED to resolvePlotLabelSettings()]string label_options=DEFAULT_CHULL_LATEX_LABEL_NAME;
    //[MOVED to resolvePlotLabelSettings()]bool plot_labels=(!label_options.empty());           //overarching flag, mostly for getting options
    //[MOVED to resolvePlotLabelSettings()]if(plot_labels){
    //[MOVED to resolvePlotLabelSettings()]  compound_labels=prototype_labels=icsd_labels=no_labels=false; //kill defaults
    //[MOVED to resolvePlotLabelSettings()]  vector<string> vlabelstring;
    //[MOVED to resolvePlotLabelSettings()]  aurostd::string2tokens(label_options,vlabelstring, ",");
    //[MOVED to resolvePlotLabelSettings()]  for(uint i=0,fl_size_i=vlabelstring.size();i<fl_size_i;i++) {
    //[MOVED to resolvePlotLabelSettings()]    if(vlabelstring[i][0] == 'B' || vlabelstring[i][0] == 'b') {  // both
    //[MOVED to resolvePlotLabelSettings()]      compound_labels=true;
    //[MOVED to resolvePlotLabelSettings()]      prototype_labels=true;
    //[MOVED to resolvePlotLabelSettings()]      icsd_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      no_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      break;
    //[MOVED to resolvePlotLabelSettings()]    } else if(vlabelstring[i][0] == 'I' || vlabelstring[i][0] == 'i') {  // ICSD
    //[MOVED to resolvePlotLabelSettings()]      compound_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      prototype_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      icsd_labels=true;
    //[MOVED to resolvePlotLabelSettings()]      no_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      break;
    //[MOVED to resolvePlotLabelSettings()]    } else if(vlabelstring[i][0] == 'N' || vlabelstring[i][0] == 'n' || vlabelstring[i][0] == 'O' || vlabelstring[i][0] == 'o') {  // none,off
    //[MOVED to resolvePlotLabelSettings()]      compound_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      prototype_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      icsd_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      meta_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      no_labels=true;
    //[MOVED to resolvePlotLabelSettings()]      break;
    //[MOVED to resolvePlotLabelSettings()]    } else if(vlabelstring[i][0] == 'C' || vlabelstring[i][0] == 'c') {  // compound
    //[MOVED to resolvePlotLabelSettings()]      compound_labels=true;
    //[MOVED to resolvePlotLabelSettings()]      icsd_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      no_labels=false;
    //[MOVED to resolvePlotLabelSettings()]    } else if(vlabelstring[i][0] == 'P' || vlabelstring[i][0] == 'p') {  // prototype
    //[MOVED to resolvePlotLabelSettings()]      prototype_labels=true;
    //[MOVED to resolvePlotLabelSettings()]      icsd_labels=false;
    //[MOVED to resolvePlotLabelSettings()]      no_labels=false;
    //[MOVED to resolvePlotLabelSettings()]    } else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Incorrect input for plot labels \""+vlabelstring[i]+"\"");}
    //[MOVED to resolvePlotLabelSettings()]  }
    //[MOVED to resolvePlotLabelSettings()]}
    if(no_labels){
      if(labels_off_hull){
        message << "LABEL_NAME set to NONE but LABELS_OFF_HULL requested (fix .aflow.rc), toggling LABELS_OFF_HULL off";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        //[turned off already in resolvePlotLabelSettings()]labels_off_hull=false;
      }
      if(meta_labels){
        message << "LABEL_NAME set to NONE but META_LABELS requested (fix .aflow.rc), toggling META_LABELS off";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        //[turned off already in resolvePlotLabelSettings()]meta_labels=false;
      }
    }
    if(labels_off_hull){plot_off_hull=true;}

    int plot_reduced_composition_setting=DEFAULT_CHULL_LATEX_PLOT_REDUCED_COMPOSITION;
    bool plot_reduced_composition;
    if(plot_reduced_composition_setting==-1){plot_reduced_composition=(!(getDim()==2&&compound_labels&&plot_labels));}
    else {plot_reduced_composition=(plot_reduced_composition_setting==0?false:true);}
    if(no_labels){
      if(plot_reduced_composition){
        message << "LABEL_NAME set to NONE but PLOT_REDUCED_COMPOSITION requested (fix .aflow.rc), toggling PLOT_REDUCED_COMPOSITION off";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        plot_reduced_composition=false;
      }
    }
    bool helvetica_font=DEFAULT_CHULL_LATEX_HELVETICA_FONT;
    string font_size=DEFAULT_CHULL_LATEX_FONT_SIZE;
    bool rotate_labels=DEFAULT_CHULL_LATEX_ROTATE_LABELS;
    if(no_labels){
      if(rotate_labels){
        message << "LABEL_NAME set to NONE but ROTATE_LABELS requested (fix .aflow.rc), toggling ROTATE_LABELS off";
        pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        rotate_labels=false;
      }
    }

    //new default option here - -1 means NO BOLD except ternaries
    //bool bold_labels=DEFAULT_CHULL_LATEX_BOLD_LABELS;
    int bold_labels_setting=DEFAULT_CHULL_LATEX_BOLD_LABELS;
    bool bold_labels=(bold_labels_setting==1);
    bool bold_labels_ternaries=(bold_labels || bold_labels_setting==-1);

    //override with user inputs
    if(light_contrast){color_map="rgb(0pt)=(0.035,0.270,0.809); rgb(63pt)=(1,0.644,0)";}
    if(font_size.empty()){
      if(large_font) {
        if(helvetica_font) {font_size="huge";}
        else {font_size="Large";}
      } else {
        if(image_only){font_size="LARGE";}
        else {font_size="large";} //safely, I can do large
      }
    }

    double opacity_watermark=0.3;
    string watermark_x_shift="2.5in";

    //////////////////////////////////////////////////////////////////////////////
    // START Getting hull attributes
    //////////////////////////////////////////////////////////////////////////////

    if(dimension>3) {
      doc_only=true;
      message << "CHULL::DOC_ONLY set to TRUE (dimension>3)";
      pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
    }

    // initializing stringstreams to use
    stringstream doc_header_TEX_ss, _doc_header_TEX_ss;               // latex header commands
    stringstream tikzpic_settings_TEX_ss,_tikzpic_settings_TEX_ss;    // settings in tikzpic
    stringstream tikzpic_TEX_ss;                         // tikzpicture commands
    stringstream convex_hull_facets_TEX_ss;              // never empty
    stringstream convex_hull_vertices_TEX_ss;            // never empty
    stringstream convex_hull_facets_drop_shadow_TEX_ss;  // never empty
    stringstream common_settings_TEX_ss;                    // use for common settings to reduce redundancy
    stringstream pseudo_preliminary_axes_TEX_ss;               // unary tikzpicture label commands
    stringstream heat_map_TEX_ss;                   // heatmap stuff
    stringstream points_data_ss;                    // points commands
    stringstream labels_data_ss;
    stringstream report_data_ss, _report_data_ss;
    stringstream equilibrium_phases_TEX_ss;
    stringstream equilibrium_phases_header_TEX_ss;
    stringstream reaction_chem_eq_TEX_ss;
    stringstream main_TEX_ss;
    stringstream node_option_ss;
    stringstream node_position_ss;
    stringstream node_content_ss;
    stringstream misc_ss;
    // no precision
    stringstream num_ss;

    // initializing some strings
    string main_TEX_file = "", main_PDF_file = "", main_PNG_file = "";
    string main_file = "", main_output_file = "";
    string input = "",input_hyphened = "";

    // creating name of output file
    input=aurostd::joinWDelimiter(m_velements,"");
    input_hyphened=aurostd::joinWDelimiter(m_velements,"-");
    main_file="aflow_"+input+"_hull";
    if(image_only) {main_TEX_file = main_file + "_IMAGEONLY.tex";}
    else {main_TEX_file = main_file + ".tex";}
    main_PDF_file = main_file + ".pdf";
    main_PNG_file = main_file + ".png";
    string aflow_logo_full_file = "aflow_logo_full.pdf";
    string aflow_logo_skinny_file = "aflow_logo_skinny.pdf";
    string logo_file_2 = "logo2.png";
    string DEFAULT_PLOT_COLUMN_HEADER = "";
    if(m_formation_energy_hull){DEFAULT_PLOT_COLUMN_HEADER="H_f_meVatom";}
    else {DEFAULT_PLOT_COLUMN_HEADER="T_S";}

    // other initialization
    uint plot_points_count = 0;                // points to put on ternary plot
    uint plot_points_count_no_end_points = 0;  // mostly for count purposes
    vector<uint> chull_points;
    vector<vector<uint> > facet_lines, facet_lines_dropshadow;
    double min_point = 0.0, max_point = 0.0, point_range = 0.0;  // saves min/max energy value to determine if we can
    // have a colorbar
    double z_filter_cutoff = 0.0, dist_filter_cutoff = 0.0;
    string plot_command = "";
    string output_name = "";
    string misc = "";
    vector<string> files_2_move; //, sg_tokens;
    stringstream command;
    uint num_horizontal_planes = 0;  // to determine whether or not we should have heatmaps
    //uint count_hull_entries=getEntriesCount(m_half_hull);
    uint count_total_entries=getEntriesCount(false);
    uint i_point=AUROSTD_MAX_UINT,i_coord_group=AUROSTD_MAX_UINT;
    bool added_header;

    string general_image_font_size="\\Large";
    string label_image_font_size="\\LARGE";
    if(image_only){
      //https://tex.stackexchange.com/questions/24599/what-point-pt-font-size-are-large-etc
      general_image_font_size="\\Huge";
      label_image_font_size="\\fontsize{28}{32}\\selectfont";
    }

    string MARGIN_PICTURE="includeheadfoot,headheight=16pt,margin=0.5in"; //do not make margin any smaller, will screw up fancyheaders elsewhere
    string MARGIN_REPORT="includeheadfoot,headheight="+(print_aflow_logo_full?string("70"):string("50"))+
      "pt,headsep=0.1in,top=0.5in,bottom=0.75in,left="+aurostd::utype2string(LATEX_LEFT_MARGIN_LETTER_STD)+"in,right="+aurostd::utype2string(LATEX_RIGHT_MARGIN_LETTER_STD)+"in,footskip=0.5in";

    string headers=getPointsPropertyHeaderList(latex_ft);
    vector<string> vheaders;
    aurostd::string2tokens(headers,vheaders,",");

    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]//get alignments
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]vector<string> valignments;
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]for(uint i=0,fl_size_i=vheaders.size();i<fl_size_i;i++){
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  if(vheaders[i]=="compound"){valignments.push_back("X[3,l,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  else if(vheaders[i]=="prototype"){valignments.push_back("X[3,l,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  else if(vheaders[i]=="auid"){valignments.push_back("X[3,l,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  else if(vheaders[i]=="space_group_orig"){valignments.push_back("X[2,l,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  else if(vheaders[i]=="space_group_relax"){valignments.push_back("X[2,l,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  else if(vheaders[i]=="spin_atom"){valignments.push_back("X[2,r,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  else if(vheaders[i]=="enthalpy_formation_atom"){valignments.push_back("X[2,r,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  else if(vheaders[i]=="entropic_temperature"){valignments.push_back("X[2,r,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  else if(vheaders[i]=="enthalpy_formation_atom_difference"){valignments.push_back("X[2,r,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  else if(vheaders[i]=="entropic_temperature_difference"){valignments.push_back("X[2,r,m]");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]  else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown property");}
    //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]}

    //get alignments
    vector<uint> valignments_entrytable_uint;
    uint total_alignment_entrytable=0;
    for(uint i=0,fl_size_i=vheaders.size();i<fl_size_i;i++){
      if(vheaders[i]=="compound"){valignments_entrytable_uint.push_back(3); total_alignment_entrytable+=valignments_entrytable_uint.back();}
      else if(vheaders[i]=="prototype"){valignments_entrytable_uint.push_back(3); total_alignment_entrytable+=valignments_entrytable_uint.back();}
      else if(vheaders[i]=="auid"){valignments_entrytable_uint.push_back(3); total_alignment_entrytable+=valignments_entrytable_uint.back();}
      else if(vheaders[i]=="space_group_orig"){valignments_entrytable_uint.push_back(2); total_alignment_entrytable+=valignments_entrytable_uint.back();}
      else if(vheaders[i]=="space_group_relax"){valignments_entrytable_uint.push_back(2); total_alignment_entrytable+=valignments_entrytable_uint.back();}
      else if(vheaders[i]=="spin_atom"){valignments_entrytable_uint.push_back(2); total_alignment_entrytable+=valignments_entrytable_uint.back();}
      else if(vheaders[i]=="enthalpy_formation_atom"){valignments_entrytable_uint.push_back(2); total_alignment_entrytable+=valignments_entrytable_uint.back();}
      else if(vheaders[i]=="entropic_temperature"){valignments_entrytable_uint.push_back(2); total_alignment_entrytable+=valignments_entrytable_uint.back();}
      else if(vheaders[i]=="enthalpy_formation_atom_difference"){valignments_entrytable_uint.push_back(2); total_alignment_entrytable+=valignments_entrytable_uint.back();}
      else if(vheaders[i]=="entropic_temperature_difference"){valignments_entrytable_uint.push_back(2); total_alignment_entrytable+=valignments_entrytable_uint.back();}
      else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown property");}
    }

    double page_width=(LATEX_WIDTH_LETTER_STD-(LATEX_LEFT_MARGIN_LETTER_STD+LATEX_RIGHT_MARGIN_LETTER_STD));
    double penalty_tabcolsep=2*LATEX_TABCOLSEP_STD*LATEX_PT2INCH; //there are two colsep for reach column, then convert to inches
    double penalty_arrayrulewidth=(valignments_entrytable_uint.size()+1)*LATEX_ARRAYRULEWIDTH_STD*LATEX_PT2INCH/(valignments_entrytable_uint.size()); //there are columns+1 separators, then convert to inches, then convert to per column penalty

    vector<string> valignments_entrytable_string;
    double page_width_fraction=0.0;
    for(uint i=0,fl_size_i=vheaders.size();i<fl_size_i;i++){
      page_width_fraction=page_width*(double)valignments_entrytable_uint[i]/(double)total_alignment_entrytable;
      if(vheaders[i]=="compound"){valignments_entrytable_string.push_back("L{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      else if(vheaders[i]=="prototype"){valignments_entrytable_string.push_back("L{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      else if(vheaders[i]=="auid"){valignments_entrytable_string.push_back("L{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      else if(vheaders[i]=="space_group_orig"){valignments_entrytable_string.push_back("L{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      else if(vheaders[i]=="space_group_relax"){valignments_entrytable_string.push_back("L{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      else if(vheaders[i]=="spin_atom"){valignments_entrytable_string.push_back("R{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      else if(vheaders[i]=="enthalpy_formation_atom"){valignments_entrytable_string.push_back("R{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      else if(vheaders[i]=="entropic_temperature"){valignments_entrytable_string.push_back("R{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      else if(vheaders[i]=="enthalpy_formation_atom_difference"){valignments_entrytable_string.push_back("R{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      else if(vheaders[i]=="entropic_temperature_difference"){valignments_entrytable_string.push_back("R{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown property");}
      if(LDEBUG) {cerr << soliloquy << " " << valignments_entrytable_string.back() << endl;}
    }

    //for compound name / ground state thermo properties (2 columns)
    uint n_cols_compoundname_thermoprops=2;
    vector<uint> valignments_compoundname_thermopropstable_uint;
    uint total_alignment_compoundname_thermoprops=0;
    for(uint i=0;i<n_cols_compoundname_thermoprops;i++){
      if(i==0){valignments_compoundname_thermopropstable_uint.push_back(3); total_alignment_compoundname_thermoprops+=valignments_compoundname_thermopropstable_uint.back();}
      if(i==1){valignments_compoundname_thermopropstable_uint.push_back(5); total_alignment_compoundname_thermoprops+=valignments_compoundname_thermopropstable_uint.back();}
    }

    vector<string> valignments_compoundname_thermopropstable_string;
    page_width_fraction=0.0;
    for(uint i=0,fl_size_i=valignments_compoundname_thermopropstable_uint.size();i<fl_size_i;i++){
      page_width_fraction=page_width*(double)valignments_compoundname_thermopropstable_uint[i]/(double)total_alignment_compoundname_thermoprops;
      if(i==0){valignments_compoundname_thermopropstable_string.push_back("L{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      if(i==1){valignments_compoundname_thermopropstable_string.push_back("R{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      if(LDEBUG) {cerr << soliloquy << " " << valignments_compoundname_thermopropstable_string.back() << endl;}
    }

    //for 1 column tables (left align)
    uint n_cols_onecol_left=1;
    vector<uint> valignments_onecol_lefttable_uint;
    uint total_alignment_onecol_left=0;
    for(uint i=0;i<n_cols_onecol_left;i++){
      if(i==0){valignments_onecol_lefttable_uint.push_back(1); total_alignment_onecol_left+=valignments_onecol_lefttable_uint.back();}
    }

    vector<string> valignments_onecol_lefttable_string;
    page_width_fraction=0.0;
    for(uint i=0,fl_size_i=valignments_onecol_lefttable_uint.size();i<fl_size_i;i++){
      page_width_fraction=page_width*(double)valignments_onecol_lefttable_uint[i]/(double)total_alignment_onecol_left;
      if(i==0){valignments_onecol_lefttable_string.push_back("L{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      if(LDEBUG) {cerr << soliloquy << " " << valignments_onecol_lefttable_string.back() << endl;}
    }

    //for equilibrium/decomposition reactions
    uint n_cols_reaction=2;
    vector<uint> valignments_reactiontable_uint;
    uint total_alignment_reaction=0;
    for(uint i=0;i<n_cols_reaction;i++){
      if(i==0){valignments_reactiontable_uint.push_back(1); total_alignment_reaction+=valignments_reactiontable_uint.back();}
      if(i==1){valignments_reactiontable_uint.push_back(3); total_alignment_reaction+=valignments_reactiontable_uint.back();}
    }

    vector<string> valignments_reactiontable_string;
    page_width_fraction=0.0;
    for(uint i=0,fl_size_i=valignments_reactiontable_uint.size();i<fl_size_i;i++){
      page_width_fraction=page_width*(double)valignments_reactiontable_uint[i]/(double)total_alignment_reaction;
      if(i==0){valignments_reactiontable_string.push_back("L{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      if(i==1){valignments_reactiontable_string.push_back("R{"+aurostd::utype2string( page_width_fraction - penalty_tabcolsep - penalty_arrayrulewidth )+"in}");}
      if(LDEBUG) {cerr << soliloquy << " " << valignments_reactiontable_string.back() << endl;}
    }

    //ymin needs to change with iso_max plot
    bool plot_iso_max_latent_heat=m_cflags.flag("CHULL::PLOT_ISO_MAX_LATENT_HEAT");
    if(plot_iso_max_latent_heat){
      if(!m_formation_energy_hull){
        message << "CHULL::PLOT_ISO_MAX_LATENT_HEAT set to FALSE (limited to formation energy hulls only)";
        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        plot_iso_max_latent_heat=false;
      }
      if(dimension!=2){
        message << "CHULL::PLOT_ISO_MAX_LATENT_HEAT set to FALSE (dimension!=2)";
        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        plot_iso_max_latent_heat=false;
      }
    }
    double iso_max_latent_heat_min=AUROSTD_MAX_DOUBLE; //absolute min
    vector<uint> g_states=getGStates(false);
    if(plot_iso_max_latent_heat){
      double iso_max;
      for(uint i=0,fl_size_i=g_states.size();i<fl_size_i;i++){
        i_point=g_states[i];
        iso_max=isoMaxLatentHeat(m_points[i_point],0.5,_m_);
        if(iso_max<iso_max_latent_heat_min){iso_max_latent_heat_min=iso_max;}
      }
      if(LDEBUG) {cerr << soliloquy << " iso-max-latent-lines min=" << iso_max_latent_heat_min << endl;}
    }

    bool unary_g_state_unstable=false;  //the only way this is true is if we plot the unary g_state and it's unstable
    vector<uint> plot_points;

    if(!doc_only && (dimension == 2 || dimension == 3)) {
      ////////////////////////////////////////////////////////////////////////////
      // START Z and DIST filter
      ////////////////////////////////////////////////////////////////////////////

      // we need to handle filters first, so we can test to see if a colorbar is
      // possible
      if(filter_by_z || !plot_unstable) {
        z_filter_cutoff = 0.0;  //default
        if(filter_by_z) {
          z_filter_cutoff = filter_cutoff;
          //let's automatically override plot_unstable if z_filter_cutoff is set appropriately
          bool plot_unstable_old=plot_unstable;
          if(m_formation_energy_hull){if(z_filter_cutoff > 0.0){plot_unstable=true;}}
          else {if(z_filter_cutoff < 0.0){plot_unstable=true;}}
          if(plot_unstable_old!=plot_unstable){
            message << "CHULL::PLOT_UNSTABLE set to TRUE, z_filter_cutoff=" << z_filter_cutoff;
            pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
          }
          //[OBSOLETE CO20180227]if(!plot_unstable) {
          //[OBSOLETE CO20180227]  if(m_formation_energy_hull){if(z_filter_cutoff > 0.0){z_filter_cutoff = 0.0;}}
          //[OBSOLETE CO20180227]  else {if(z_filter_cutoff < 0.0){z_filter_cutoff = 0.0;}}
          //[OBSOLETE CO20180227]}
          //[OBSOLETE CO20180227]else {z_filter_cutoff = 0.0;}
        }
        if(LDEBUG) {cerr << soliloquy << " z_filter_cutoff=" << z_filter_cutoff << endl;}
      }
      if(filter_by_distance) {
        dist_filter_cutoff = filter_cutoff; 
        if(LDEBUG) {cerr << soliloquy << " DIST dist_filter_cutoff=" << dist_filter_cutoff << endl;}
        if(zeroWithinTol(dist_filter_cutoff) && plot_off_hull) {
          plot_off_hull=false;
          message << "CHULL::OFF_HULL set to FALSE, filter_by_distance=0.0";
          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        }
      }

      ////////////////////////////////////////////////////////////////////////////
      // END Z and DIST filter
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // Determine if we need to plot unstable (no stable points) (ROUND 1)
      ////////////////////////////////////////////////////////////////////////////

      plot_points_count = 0;
      plot_points_count_no_end_points = 0;
      min_point = max_point = 0.0;
      plot_points.clear();
      unary_g_state_unstable=false;
      //uint i_point;
      // no way to avoid this, we need to figure out if we can have a colorbar before
      // we go through the rest of the loops
      // so let's avoid double filtering, do it once and store to plot_points

      bool point_added;
      for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
        point_added=false;
        for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i&&!(dimension==3&&point_added);i++){  //we only add one point per coordgroup for 3D
          i_point=m_coord_groups[i_coord_group].m_points[i];
          if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
          const ChullPoint& point=m_points[i_point];
          if(!point.m_has_entry){continue;}
          if(!plot_unaries && point.isUnary()){continue;}
          if(!plot_off_hull && !point.m_is_g_state){continue;}  //if point.isUnary() and it gets here, only pass g-state
          if(!point.m_is_g_state){
            if(filter_by_z || !plot_unstable) {
              if(m_formation_energy_hull) {
                if(chull::H_f_atom(point, _m_) > z_filter_cutoff) {
                  //[CO20181226 - print later]if(filter_by_z) {
                  //[CO20181226 - print later]  message << "Excluding entry " << point.m_entry.auid;
                  //[CO20181226 - print later]  message << " with H_f = " << chull::H_f_atom(point, _m_);
                  //[CO20181226 - print later]  message << " (meV/atom) from plot";
                  //[CO20181226 - print later]  pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_,!filter_by_z);  // too much output to screen
                  //[CO20181226 - print later]}
                  continue;
                }
              } else {
                if(chull::T_S(point) < z_filter_cutoff) {
                  //[CO20181226 - print later]if(filter_by_z) {
                  //[CO20181226 - print later]  message << "Excluding entry " << point.m_entry.auid;
                  //[CO20181226 - print later]  message << " with T_S = " << chull::T_S(point);
                  //[CO20181226 - print later]  message << " (K) from plot";
                  //[CO20181226 - print later]  pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_,!filter_by_z);  // too much output to screen
                  //[CO20181226 - print later]}
                  continue;
                }
              }
            }
            if(filter_by_distance) {
              if(m_formation_energy_hull) {
                if(point.getDist2Hull(_m_) > dist_filter_cutoff) {
                  //[CO20181226 - print later]message << "Excluding entry " << point.m_entry.auid;
                  //[CO20181226 - print later]message << " with enthalpy_formation_atom_difference = " << aurostd::utype2string(point.getDist2Hull(_m_),CHULL_PRECISION);
                  //[CO20181226 - print later]message << " (meV/atom) from plot";
                  //[CO20181226 - print later]pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);  // too much output to screen
                  continue;
                }
              } else {
                if(point.getDist2Hull(_std_) < dist_filter_cutoff) {
                  //[CO20181226 - print later]message << "Excluding entry " << point.m_entry.auid;
                  //[CO20181226 - print later]message << " with entropic_temperature_difference = " << aurostd::utype2string(point.getDist2Hull(_std_),CHULL_PRECISION);
                  //[CO20181226 - print later]message << " (K) from plot";
                  //[CO20181226 - print later]pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);  // too much output to screen
                  continue;
                }
              }
            }
          }
          if(point.getLastCoord()<min_point){min_point=point.getLastCoord();}
          if(point.getLastCoord()>max_point){max_point=point.getLastCoord();}
          //[CO20181226 - set later]if(point.isUnary()){
          //[CO20181226 - set later]  if(m_formation_energy_hull) {if(chull::H_f_atom(point, _m_) > z_filter_cutoff) {unary_g_state_unstable=true;}}
          //[CO20181226 - set later]  else {if(chull::T_S(point) < z_filter_cutoff) {unary_g_state_unstable=true;}}
          //[CO20181226 - set later]} else {plot_points_count_no_end_points++;}
          plot_points_count++;
          //[CO20181226 - set later]plot_points.push_back(i_point);
          point_added=true;
        }
      }
      if(!plot_points_count){
        filter_by_z=true;filter_by_distance=false;
        plot_unstable=true;
        if(m_formation_energy_hull) {z_filter_cutoff=1000.0;} //1000 meV
        else {z_filter_cutoff=1.0/(((double)KBOLTZEV)*(0.5*log(0.5)+(1.0-0.5)*log(1.0-0.5)));}  //1.0 eV / (kB * 2 * 0.5 log(0.5))
        message << "CHULL::FILTER_SCHEME set to Z-axis (no stable points found)" << endl;
        message << "CHULL::FILTER_VALUE set to " << z_filter_cutoff << " (no stable found)" << endl;
        message << "CHULL::PLOT_UNSTABLE set to TRUE (no stable found)" << endl;
        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_WARNING_);
      }

      ////////////////////////////////////////////////////////////////////////////
      // START Gathering points for plotting (ROUND 2)
      ////////////////////////////////////////////////////////////////////////////

      plot_points_count = 0;
      plot_points_count_no_end_points = 0;
      min_point = max_point = 0.0;
      plot_points.clear();
      unary_g_state_unstable=false;
      //uint i_point;
      // no way to avoid this, we need to figure out if we can have a colorbar before
      // we go through the rest of the loops
      // so let's avoid double filtering, do it once and store to plot_points

      for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
        point_added=false;
        for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i&&!(dimension==3&&point_added);i++){  //we only add one point per coordgroup for 3D
          i_point=m_coord_groups[i_coord_group].m_points[i];
          if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
          const ChullPoint& point=m_points[i_point];
          if(!point.m_has_entry){continue;}
          if(!plot_unaries && point.isUnary()){continue;}
          if(!plot_off_hull && !point.m_is_g_state){continue;}  //if point.isUnary() and it gets here, only pass g-state
          if(!point.m_is_g_state){
            if(filter_by_z || !plot_unstable) {
              if(m_formation_energy_hull) {
                if(chull::H_f_atom(point, _m_) > z_filter_cutoff) {
                  if(filter_by_z) {
                    message << "Excluding entry " << point.m_entry.auid;
                    message << " with H_f = " << chull::H_f_atom(point, _m_);
                    message << " (meV/atom) from plot";
                    pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_,!filter_by_z);  // too much output to screen
                  }
                  continue;
                }
              } else {
                if(chull::T_S(point) < z_filter_cutoff) {
                  if(filter_by_z) {
                    message << "Excluding entry " << point.m_entry.auid;
                    message << " with T_S = " << chull::T_S(point);
                    message << " (K) from plot";
                    pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_,!filter_by_z);  // too much output to screen
                  }
                  continue;
                }
              }
            }
            if(filter_by_distance) {
              if(m_formation_energy_hull) {
                if(point.getDist2Hull(_m_) > dist_filter_cutoff) {
                  message << "Excluding entry " << point.m_entry.auid;
                  message << " with enthalpy_formation_atom_difference = " << aurostd::utype2string(point.getDist2Hull(_m_),CHULL_PRECISION);
                  message << " (meV/atom) from plot";
                  pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);  // too much output to screen
                  continue;
                }
              } else {
                if(point.getDist2Hull(_std_) < dist_filter_cutoff) {
                  message << "Excluding entry " << point.m_entry.auid;
                  message << " with entropic_temperature_difference = " << aurostd::utype2string(point.getDist2Hull(_std_),CHULL_PRECISION);
                  message << " (K) from plot";
                  pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);  // too much output to screen
                  continue;
                }
              }
            }
          }
          if(point.getLastCoord()<min_point){min_point=point.getLastCoord();}
          if(point.getLastCoord()>max_point){max_point=point.getLastCoord();}
          if(point.isUnary()){
            if(m_formation_energy_hull) {if(chull::H_f_atom(point, _m_) > z_filter_cutoff) {unary_g_state_unstable=true;}}
            else {if(chull::T_S(point) < z_filter_cutoff) {unary_g_state_unstable=true;}}
          } else {plot_points_count_no_end_points++;}
          plot_points_count++;
          plot_points.push_back(i_point);
          point_added=true;
        }
      }

      //set to doc_only if a worthless image
      //[CO20181226 - OBSOLETE]if(!doc_only && (dimension == 2 || dimension == 3))
      if(!plot_points_count)
      { //CO20200106 - patching for auto-indenting
        doc_only=true;
        message << "CHULL::DOC_ONLY set to TRUE (no plot points found)";
        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
      }

      ////////////////////////////////////////////////////////////////////////////
      // END Gathering points for plotting
      ////////////////////////////////////////////////////////////////////////////
    }

    //links options
    int links_setting=DEFAULT_CHULL_LATEX_LINKS;
    bool kill_all_links=(links_setting==0);       //no links whatsoever
    bool external_links=addExternalHyperlinks();      //weblinks
    bool internal_links_graph2report=(no_doc==false&&doc_only==false); //if doc_only==true, turn off links between graph and report
    bool internal_links_withinreport=(no_doc==false); //if no_doc==true, turn off links within report
    bool internal_links=addInternalHyperlinks(internal_links_graph2report,internal_links_withinreport);       //no jumping
    if(!internal_links){internal_links_graph2report=internal_links_withinreport=false;}

    //////////////////////////////////////////////////////////////////////////////
    // START Document header
    //////////////////////////////////////////////////////////////////////////////

    //doc_header_TEX_ss << "\\documentclass[12pt]{article}" << " \%HEADER" << endl; //non-standard
    doc_header_TEX_ss << "\\documentclass[10pt]{article}" << " \%HEADER" << endl;
    doc_header_TEX_ss << "\\usepackage[utf8x]{inputenc}" << " \%HEADER" << endl;
    doc_header_TEX_ss << "\\usepackage[table,dvipsnames]{xcolor}" << " \%HEADER" << endl;
    if(helvetica_font) {
      //doc_header_TEX_ss << "\\usepackage[scaled]{helvet}" << " \%HEADER" << endl;  //CO20180301
      doc_header_TEX_ss << "\\renewcommand\\familydefault{\\sfdefault}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\usepackage{sansmath}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\sansmath" << " \%HEADER" << endl; //enable sans-serif math for rest of document
      doc_header_TEX_ss << "\\usepackage{upgreek}" << " \%HEADER" << endl; //to fix \\Delta for H_f
    }
    doc_header_TEX_ss << "\\usepackage[T1]{fontenc}" << " \%HEADER" << endl;  // accents https://tex.stackexchange.com/questions/664/why-should-i-use-usepackaget1fontenc
    doc_header_TEX_ss << "\\usepackage{anyfontsize}" << " \%HEADER" << endl;  // arbitrary font sizes
    doc_header_TEX_ss << "\\usepackage{lmodern}" << " \%HEADER" << endl;  // high quality fonts
    doc_header_TEX_ss << "\\usepackage[yyyymmdd,hhmmss]{datetime}" << " \%HEADER" << endl;
    doc_header_TEX_ss << "\\renewcommand{\\dateseparator}{-}" << " \%HEADER" << endl;
    doc_header_TEX_ss << "\\usepackage{geometry} \%showframe" << " \%HEADER" << endl;
    if(!image_only){
      doc_header_TEX_ss << "\\usepackage{fancyhdr} \%column header" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\usepackage[absolute]{textpos} %showboxes" << " \%HEADER" << endl;
    }
    if(!no_doc && !image_only) {
      doc_header_TEX_ss << "\\usepackage{longtable}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\vbadness=10000" << " \%HEADER" << endl; //patches vbadness warnings (hline issue) with longtable - https://tex.stackexchange.com/questions/71096/underfull-vbox-in-each-longtable-can-it-be-fixed-or-must-it-be-ignored
      //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]doc_header_TEX_ss << "\\usepackage{tabu}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\usepackage{booktabs} \%midrule and toprule" << " \%HEADER" << endl;
      //http://tex.stackexchange.com/questions/167948/package-rerunfilecheck-warning-file-out-has-changed
      doc_header_TEX_ss << "\\usepackage{multirow} \%column header" << " \%HEADER" << endl;
    }

    if(1||!kill_all_links) { //need for paper reference (CHULL_JOURNAL_LATEX)
      doc_header_TEX_ss << "\\usepackage{hyperref} \\hypersetup{colorlinks=true,citecolor=blue,linkcolor=blue,urlcolor=blue}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\usepackage{bookmark} \%hyperref without .out" << " \%HEADER" << endl;
    }

    doc_header_TEX_ss << "\\usepackage{array} \%m{}" << " \%HEADER" << endl;
    doc_header_TEX_ss << "\\usepackage{setspace} \%setstretch linespacing" << " \%HEADER" << endl;

    _doc_header_TEX_ss << "\\newcolumntype{L}[1]{>{\\raggedright\\arraybackslash}p{#1} }" << " \%HEADER" << endl;
    _doc_header_TEX_ss << "\\newcolumntype{C}[1]{>{\\centering  \\arraybackslash}p{#1} }" << " \%HEADER" << endl;
    _doc_header_TEX_ss << "\\newcolumntype{R}[1]{>{\\raggedleft \\arraybackslash}p{#1} }" << " \%HEADER" << endl;
    _doc_header_TEX_ss << "\\newcolumntype{X}[1]{>{\\setstretch{0.5} \\centering  \\arraybackslash}m{#1} } \%setstretch changes line spacing" << " \%HEADER" << endl;
    _doc_header_TEX_ss << "\\newcommand{\\newAlloy}[2]{%" << " \%HEADER" << endl;
    _doc_header_TEX_ss << "\\setAlloy{#1}" << " \%HEADER" << endl;
    _doc_header_TEX_ss << "\\setCountTotalEntries{#2}" << " \%HEADER" << endl;
    _doc_header_TEX_ss << "}" << " \%HEADER" << endl;

    if(!image_only){
      //to set count variable, we need to create a "section" where it is defined
      //alloys are de facto subsections, section usually "binaries" or "Co-type", etc.
      //https://tex.stackexchange.com/questions/186582/defining-a-dynamic-variable
      //_doc_header_TEX_ss << "\\newcommand{\\newAlloyFormatted}[3]{%" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\newcommand{\\newAlloyFormatted}[2]{%" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\clearpage" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\phantomsection" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\addcontentsline{toc}{subsection}{#1}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\newAlloy{#1}{#2}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "}" << " \%HEADER" << endl;
      //_doc_header_TEX_ss << "\\setAlloy{#1}" << " \%HEADER" << endl;
      //_doc_header_TEX_ss << "\\setCountTotalEntries{#2}" << " \%HEADER" << endl;
      //_doc_header_TEX_ss << "\\setCountHullEntries{#2}" << " \%HEADER" << endl;
      //_doc_header_TEX_ss << "\\setCountTotalEntries{#3}" << " \%HEADER" << endl;
    }

    //alloy needs to be dynamic as it sets in the header/footer!
    _doc_header_TEX_ss << "\\newcommand{\\alloy}{}"<< " \%HEADER" << endl;
    _doc_header_TEX_ss << "\\newcommand{\\setAlloy}[1]{\\renewcommand{\\alloy}{#1}}" << " \%HEADER" << endl;
    _doc_header_TEX_ss << "\\newcommand{\\printAlloy}{\\alloy}" << " \%HEADER" << endl;
    //count variable needs to be dynamic as it sets in the header/footer!
    //_doc_header_TEX_ss << "\\newcommand{\\countHullEntries}{}"<< " \%HEADER" << endl;
    //_doc_header_TEX_ss << "\\newcommand{\\setCountHullEntries}[1]{\\renewcommand{\\countHullEntries}{#1}}" << " \%HEADER" << endl;
    //_doc_header_TEX_ss << "\\newcommand{\\printCountHullEntries}{\\countHullEntries}" << " \%HEADER" << endl;
    //total count variable needs to be dynamic as it sets in the header/footer!
    _doc_header_TEX_ss << "\\newcommand{\\countTotalEntries}{}"<< " \%HEADER" << endl;
    _doc_header_TEX_ss << "\\newcommand{\\setCountTotalEntries}[1]{\\renewcommand{\\countTotalEntries}{#1}}" << " \%HEADER" << endl;
    _doc_header_TEX_ss << "\\newcommand{\\printCountTotalEntries}{\\countTotalEntries}" << " \%HEADER" << endl;

    // things to add later, depending on we include hull image on first page
    _doc_header_TEX_ss << "\\begin{document}" << " \%HEADER" << endl;

    // BEAUTIFUL SOLUTION to use links with labels
    if(!plot_unaries && internal_links_graph2report) {
      _doc_header_TEX_ss << "\\newcommand{\\hyperrefTitle}[2]{\\hyperref[#1]{#2}} \%we need this because axis doesn't like []" << " \%HEADER" << endl;
    }
    if(!doc_only && (dimension == 2 || dimension == 3)) {
      _doc_header_TEX_ss << "\\definecolor{pranab_green}{rgb}{0.31,0.53,0.10}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\definecolor{pranab_red}{rgb}{0.85,0.23,0.11}" << " \%HEADER" << endl;
    }

    //moving from bottom so header stuff stays together
    if(!image_only){
      // fancypagestyle1 for convex hull illustration
      _doc_header_TEX_ss << "\\setlength{\\TPHorizModule}{\\paperwidth}\\setlength{\\TPVertModule}{\\paperheight}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\fancypagestyle{hullImage}{" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\fancyhf{}" << " \%HEADER" << endl;
      if(!(small_banner || no_banner)){
        _doc_header_TEX_ss << "\\fancyhead[C]{" << " \%HEADER" << endl;
        if(print_aflow_logo_full||print_aflow_text_logo){
          _doc_header_TEX_ss << "\\begin{textblock}{0.1}[0.5,1.0](0.09,0.95){\\rotatebox{90}{";
          if(!print_aflow_logo_full){_doc_header_TEX_ss << "\\shortstack[l]{";}
          if(external_links) {_doc_header_TEX_ss << "\\href{http://aflow.org}";}
          if(print_aflow_logo_full) {_doc_header_TEX_ss << "{\\includegraphics[scale=0.2]{" << aflow_logo_full_file << "}}";}
          else {
            _doc_header_TEX_ss << "{\\LARGE AFLOW V" << string(AFLOW_VERSION) << "}";
            _doc_header_TEX_ss << "\\\\";
            _doc_header_TEX_ss << "{\\large C. Oses and S. Curtarolo}";
            _doc_header_TEX_ss << "}";
          }
          _doc_header_TEX_ss << "}}\\end{textblock}" << " \%HEADER" << endl;
        }

        if(print_logo_2||print_aflow_webaddress_logo){
          _doc_header_TEX_ss << "\\begin{textblock}{0.1}[0.5,0.0](0.09,0.05){\\rotatebox{90}{";
          if(print_logo_2){
            if(external_links) {_doc_header_TEX_ss << "\\href{http://www.nomad-coe.eu/}";}
            _doc_header_TEX_ss << "{\\includegraphics[scale=0.1]{" << logo_file_2 << "}}";
          } else {  //print_aflow_webaddress_logo
            if(external_links) {_doc_header_TEX_ss << "\\href{http://aflow.org}";}
            _doc_header_TEX_ss << "{" << label_image_font_size << "{\\fontfamily{\\sfdefault}\\selectfont{aflow.org}}}";  //\\fontfamily{\\phv}\\selectfont
          }
          _doc_header_TEX_ss << "}}\\end{textblock}" << " \%HEADER" << endl;
        }
        _doc_header_TEX_ss << "}" << " \%HEADER" << endl;

        _doc_header_TEX_ss << "\\fancyfoot[C]{" << " \%HEADER" << endl;
        _doc_header_TEX_ss << "\\begin{textblock}{0.05}[0.5,1.0](0.925,0.95){\\rotatebox{90}{" << general_image_font_size << " " << string("\\printCountTotalEntries\\") << " entries}}\\end{textblock}" << " \%HEADER" << endl; //string("\\printCountHullEntries") //hull count
        _doc_header_TEX_ss << "\\begin{textblock}{0.05}[0.5,0.0](0.925,0.05){\\rotatebox{90}{" << general_image_font_size << " \\today}}\\end{textblock}" << " \%HEADER" << endl; //\\today~\\currenttime
        _doc_header_TEX_ss << "}" << " \%HEADER" << endl;
      }
      _doc_header_TEX_ss << "\\renewcommand{\\headrulewidth}{0pt}     \% size of header line" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\renewcommand{\\footrulewidth}{0pt}     \% size of header line" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "}" << " \%HEADER" << endl;
    }
    if(!no_doc && !image_only) {
      _doc_header_TEX_ss << "\\newsavebox{\\snapshotTableHeaderOne}" << " \%this IS dynamic (countTotalEntries), so define command to update it (must be in right environment)" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\newcommand{\\updateSnapshotTableHeaderOne}{" << " \%HEADER" << endl;
      //LRBOXES store as text, so whatever inherits it doesn't know it's a XX (tabu in this case, which conflicts with fancyheader)
      _doc_header_TEX_ss << "\\begin{lrbox}{\\snapshotTableHeaderOne}" << " \%store as text \%HEADER" << endl;
      //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]_doc_header_TEX_ss << "\\begin{tabu}{X[1,l,m]" << (print_logo_2?string("X[1,c,m]"):string("")) << "X[1,r,m]}" << " \%HEADER" << endl;
      double tableheaderone_colsize=(LATEX_WIDTH_LETTER_STD-(LATEX_LEFT_MARGIN_LETTER_STD+LATEX_RIGHT_MARGIN_LETTER_STD))/(print_logo_2?3.0:2.0);
      _doc_header_TEX_ss << "\\noindent\\begin{tabular}{";
      _doc_header_TEX_ss << "@{}L{" << tableheaderone_colsize << "in}";
      if(print_logo_2){_doc_header_TEX_ss << "@{}C{" << tableheaderone_colsize << "in}";}
      _doc_header_TEX_ss << "@{}R{" << tableheaderone_colsize << "in}@{}}" << " \%HEADER" << endl;
      if(!print_aflow_logo_full){_doc_header_TEX_ss << "\\shortstack[l]{";}
      if(external_links) {_doc_header_TEX_ss << "\\href{" << AFLOW_WEB << "}";}
      if(print_aflow_logo_full) {_doc_header_TEX_ss << "{\\raisebox{-.5\\height}{\\includegraphics[scale=0.25]{" << aflow_logo_full_file << "}}}";}
      else {
        _doc_header_TEX_ss << "{\\LARGE AFLOW V" << string(AFLOW_VERSION) << "}";
        _doc_header_TEX_ss << "\\\\";
        _doc_header_TEX_ss << "{\\large C. Oses and S. Curtarolo}";
        _doc_header_TEX_ss << "}";
      }
      _doc_header_TEX_ss << " & ";
      if(print_logo_2){
        if(external_links) {_doc_header_TEX_ss << "\\href{" << NOMAD_WEB << "}";}
        _doc_header_TEX_ss << "{\\raisebox{-.5\\height}{\\includegraphics[scale=0.125]{" << logo_file_2 << "}}}";
        _doc_header_TEX_ss << " & ";
      }
      //include small redundant header - START
      _doc_header_TEX_ss << "\\begin{tabular}{@{}r@{}}";
      _doc_header_TEX_ss << "\\large " << string("\\printAlloy") << "\\ summary"; // (V" << string(AFLOW_VERSION) << ")"; //Materials Snapshot";
      _doc_header_TEX_ss << "\\\\";
      _doc_header_TEX_ss << "\\large " << string("\\printCountTotalEntries\\") << " entries";
      _doc_header_TEX_ss << "\\\\";
      _doc_header_TEX_ss << "\\large \\today";  //\\today~\\currenttime
      _doc_header_TEX_ss << "\\end{tabular}" << " \%HEADER" << endl;
      //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]_doc_header_TEX_ss << "\\end{tabu}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\end{tabular}" << " \%HEADER" << endl;
      //include small redundant header - END
      _doc_header_TEX_ss << "\\end{lrbox}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\newsavebox{\\snapshotTableHeaderTwo}" << " \%this is NOT dynamic, so simply define once with right geometry and keep forever" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\newgeometry{" << MARGIN_REPORT << "}" << " \%HEADER" << endl;  //force geometry of the table early, so columns are properly sized in headers //new geometry introduces \\newpage automatically
      //LRBOXES store as text, so whatever inherits it doesn't know it's a XX (tabu in this case, which conflicts with fancyheader)
      _doc_header_TEX_ss << "\\begin{lrbox}{\\snapshotTableHeaderTwo}" << " \%store as text \%HEADER" << endl;
      _doc_header_TEX_ss << getSnapshotTableHeader(headers,true);
      _doc_header_TEX_ss << "\\end{lrbox}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\restoregeometry" << " \%HEADER" << endl;
      // fancypagestyle2 for first page of report
      _doc_header_TEX_ss << "\\fancypagestyle{reportPage1}{" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\fancyhf{}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\fancyhead[C]{\\usebox{\\snapshotTableHeaderOne}}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\fancyfoot[C]{\\thepage}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\renewcommand{\\headrulewidth}{0pt}     \% size of header line" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\renewcommand{\\footrulewidth}{0pt}     \% size of header line" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "}" << " \%HEADER" << endl;
      // fancypagestyle3 for beyond first page
      _doc_header_TEX_ss << "\\fancypagestyle{reportPage2}{" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\fancyhf{}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\fancyhead[C]{\\usebox{\\snapshotTableHeaderTwo}}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\fancyfoot[C]{\\thepage}" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\renewcommand{\\headrulewidth}{0pt}     \% size of header line" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "\\renewcommand{\\footrulewidth}{0pt}     \% size of header line" << " \%HEADER" << endl;
      _doc_header_TEX_ss << "}" << " \%HEADER" << endl;
    }
    if(!image_only){_doc_header_TEX_ss << "\\newAlloyFormatted{" << input_hyphened << "}{" << count_total_entries << "}" << endl;} //{" << count_total_entries << "}" << endl;

    //////////////////////////////////////////////////////////////////////////////
    // END Document header (for now)
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Image on first page
    //////////////////////////////////////////////////////////////////////////////

    if(!doc_only && (dimension == 2 || dimension == 3)) {
      ////////////////////////////////////////////////////////////////////////////
      // START More header commands specific to tikz pic
      ////////////////////////////////////////////////////////////////////////////

      doc_header_TEX_ss << "\\usepackage{pgfplots}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\usepackage{pdflscape}" << " \%HEADER" << endl;
      //[MOVED UP]doc_header_TEX_ss << "\\usepackage{array} \%m" << " \%HEADER" << endl;  %brackets
      //[MOVED UP]doc_header_TEX_ss << "\\usepackage{setspace} \%setstretch linespacing" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\pgfplotsset{compat=1.10}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\usepgfplotslibrary{ternary,units}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\usetikzlibrary{decorations.pathmorphing,pgfplots.units,backgrounds}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\usepackage{tikz}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\usetikzlibrary{positioning}" << " \%HEADER" << endl;

      if(dimension == 3) {
        doc_header_TEX_ss << "\\usetikzlibrary{pgfplots.ternary}" << " \%HEADER" << endl;
      }
      if(image_only) {
        doc_header_TEX_ss << "\\pgfrealjobname{CHull}" << " \%HEADER" << endl;  // dummy name
      }
      doc_header_TEX_ss << "\\pgfdeclarelayer{background}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\pgfdeclarelayer{foreground}" << " \%HEADER" << endl;
      doc_header_TEX_ss << "\\pgfsetlayers{background,main,foreground}" << " \%HEADER" << endl;

      //[MOVED UP]doc_header_TEX_ss << "\\newcolumntype{L}[1]{>{\\raggedright\\arraybackslash}p{#1} }" << " \%HEADER" << endl;
      //[MOVED UP]doc_header_TEX_ss << "\\newcolumntype{C}[1]{>{\\centering  \\arraybackslash}p{#1} }" << " \%HEADER" << endl;
      //[MOVED UP]doc_header_TEX_ss << "\\newcolumntype{R}[1]{>{\\raggedleft \\arraybackslash}p{#1} }" << " \%HEADER" << endl;
      //[MOVED UP]doc_header_TEX_ss << "\\newcolumntype{X}[1]{>{\\setstretch{0.5} \\centering  \\arraybackslash}m{#1} } \%setstretch changes line spacing" << " \%HEADER" << endl;

      doc_header_TEX_ss << _doc_header_TEX_ss.str();
      _doc_header_TEX_ss.str("");  // don't repeat

      doc_header_TEX_ss << "\\newgeometry{" << MARGIN_PICTURE << "}" << endl; //new geometry introduces \\newpage automatically
      if(image_only) {doc_header_TEX_ss << "\\beginpgfgraphicnamed{aflow_" << input << "_hull}" << " \%HEADER" << endl;}
      if(!image_only){
        doc_header_TEX_ss << "\\thispagestyle{hullImage}" << endl;  //empty
        doc_header_TEX_ss << "\\begin{landscape}" << endl;
        doc_header_TEX_ss << "\\centering{" << endl;
        doc_header_TEX_ss << "\\topskip0pt" << endl;
        doc_header_TEX_ss << "\\vspace*{\\fill}" << endl;
      }

      ////////////////////////////////////////////////////////////////////////////
      // END More header commands specific to tikz pic
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START Determining if points range enough to have color/heat map
      // functionality
      ////////////////////////////////////////////////////////////////////////////

      int approx_num_ticks=5;
      double extra_padding_multiplier=(rotate_labels?0.225:0.1);

      if(m_formation_energy_hull) {
        min_point = chull::convertUnits(min_point, _m_);
        if(plot_iso_max_latent_heat){ //min_point might change with iso_max
          double old_min_point=min_point;
          min_point=min(min_point,iso_max_latent_heat_min);
          if(abs(old_min_point-min_point)>abs(max_point - old_min_point)/(double)approx_num_ticks){ //is it bigger than ~tic distance?
            extra_padding_multiplier/=2.0; //don't need so much MORE padding, T_S label is flat, and we just made sure T_S is well below rotated labels
          }
        }
        max_point = chull::convertUnits(max_point, _m_);
      }

      //do after everything
      if(image_only){extra_padding_multiplier*=1.5;}

      point_range = max_point - min_point;
      //bool set_max_tick_spacing_2D=false;//true; //max space between ticks=XX (in yticklabel style),  //CO20180227  //this hardly works, we need to set it exactly, COMPLETELY REMOVED
      //int max_tick_spacing=1;
      bool set_y_range_exactly=true;
      double y_tick_distance=0.25;
      double y_tick_distance_right=y_tick_distance; ///10.0;
      double ymin=(m_formation_energy_hull?-ZERO_RANGE_TOL:0);//-ZERO_RANGE_TOL;
      double ymax=(m_formation_energy_hull?0:ZERO_RANGE_TOL);//ZERO_RANGE_TOL;
      double y_range=abs(ymax-ymin);
      double round_to_value=getRoundToValue(point_range);
      double extra_padding=(point_range)*extra_padding_multiplier; //to avoid label clashing with axis, 20% should be enough
      //int extra_padding=roundDouble((point_range)*0.2, (int)round_to_value, false);  //round down to keep tight, unless you get 0, need more padding  //CO20190724 - explicit double->int conversion (floor is fine)
      //if(extra_padding==0){extra_padding=roundDouble((point_range)*0.2, (int)round_to_value, true);}  //CO20190724 - explicit double->int conversion (floor is fine)

      //adding conversion between meV/atom to kJ/mol
      bool showkJmolaxis = m_formation_energy_hull;  //default
      double kJmol_threshold = 1.0/((double)meVatom2kJmol); //should give about 10, 1 kJ/mol -> 10 meV/atom
      if(0 && showkJmolaxis && y_range<kJmol_threshold){showkJmolaxis=false;}  //we need integer y tick distance, don't show if it's not at least as big as ~10meV/atom, we should now be able to handle fractional y_dist

      if(showkJmolaxis){y_tick_distance_right/=10.0;} //default value, store AFTER setting showkJmolaxis

      if(LDEBUG) {
        cerr << soliloquy << " range" << endl;
        cerr << soliloquy << " max:     " << max_point << endl;
        cerr << soliloquy << " min:     " << min_point << endl;
        cerr << soliloquy << " point_range: " << point_range << endl;
      }

      // range functionality
      // http://tex.stackexchange.com/questions/69248/set-ticklabels-for-colorbar

      if(dimension == 2) {
        include_color_bar=false;
        message << "CHULL::COLOR_BAR set to FALSE (dimension==2)";
        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);

        show_heat_map=false;
        message << "CHULL::HEAT_MAP set to FALSE (dimension==2)";
        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
      }
      // determine whether we can have a colorbar
      // recently added: (plot_points_count==1&&!show_heat_map)
      // we need difference data, so if there's only one "colored" data, no way to establish a color spectrum
      if( !plot_points_count || (dimension==3 && !show_heat_map && plot_points_count<2) || (abs(point_range) < ZERO_TOL)) {
        include_color_bar=false;
        show_heat_map=false;
        display_color_gradient=false;
        if(LDEBUG) {
          cerr << soliloquy << " plot points count = " << plot_points_count << endl;
          cerr << soliloquy << " plot points count no end points = " << plot_points_count_no_end_points << endl;
        }
        if(!plot_points_count) {
          message << "CHULL::COLOR_BAR set to FALSE, no entries found";
          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
          message << "CHULL::COLOR_GRADIENT set to FALSE, no entries found";
          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
          message << "CHULL::HEAT_MAP set to FALSE, no entries found";
          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        }
        if(dimension==3 && !show_heat_map && plot_points_count<2) {
          message << "CHULL::COLOR_BAR set to FALSE, not enough non-unary entries found";
          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
          message << "CHULL::COLOR_GRADIENT set to FALSE, not enough non-unary entries found";
          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
          message << "CHULL::HEAT_MAP set to FALSE, not enough non-unary entries found";
          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        }
        if(zeroWithinTol(point_range)) {
          message << "CHULL::COLOR_BAR set to FALSE, hull has no depth";
          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
          message << "CHULL::COLOR_GRADIENT set to FALSE, hull has no depth";
          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
          message << "CHULL::HEAT_MAP set to FALSE, hull has no depth";
          pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_OPTION_);
        }
      }

      ////////////////////////////////////////////////////////////////////////////
      // END Determining if points range enough to have color/heat map
      // functionality
      ////////////////////////////////////////////////////////////////////////////

      // doc_header_TEX_ss ends here, we need to get data first, see
      // pseudo_preliminary_axes_TEX_ss (hrefs)

      ////////////////////////////////////////////////////////////////////////////
      // START Tikz pic settings
      ////////////////////////////////////////////////////////////////////////////

      //_tikzpic_settings_TEX_ss comes before tikzpic_TEX_ss
      _tikzpic_settings_TEX_ss << "\\begin{tikzpicture}[font=" << general_image_font_size;
      _tikzpic_settings_TEX_ss << "]";
      _tikzpic_settings_TEX_ss << endl;
      // end of _tikzpic_settings_TEX_ss, we need to get data first, see
      // pseudo_preliminary_axes_TEX_ss (hrefs)
      // common settings between two axes
      if((!plot_points_count) || (abs(point_range) < ZERO_RANGE_TOL)) {
        //simply do not calculate ymin, ymax (ints)
        //
        //ymin=-ZERO_RANGE_TOL;
        //ymax=ZERO_RANGE_TOL;
      } else {
        // easier to figure out ranges in meV, stays meV
        // between lowest label and bottom line, increase if need more
        // we might have hull endpoints higher than 0
        if(!m_formation_energy_hull && !(plot_unaries && unary_g_state_unstable) && (!plot_unstable || abs(min_point) < ZERO_TOL)) {ymin=0;}
        else {
          ymin=min_point;
          if(dimension==2){ //only do rounding for dim==2, dim==3 we need EXACT values or colorbar gets screwed up
            if(m_formation_energy_hull){ymin-=extra_padding;}  //CO20180227 - we need to avoid labels here
            ymin=roundDouble(ymin,(int)round_to_value,false);  //we want min to be MORE NEGATIVE, so round DOWN //CO20190724 - explicit double->int conversion (floor is fine)
          }
        }
        // between highest label and top line, increase if need more
        // we might have hull endpoints higher than 0
        if(m_formation_energy_hull && !(plot_unaries && unary_g_state_unstable) && (!plot_unstable || abs(max_point) < ZERO_TOL)) {ymax=0;}
        else {
          ymax=max_point;
          if(dimension==2){ //only do rounding for dim==2, dim==3 we need EXACT values or colorbar gets screwed up
            if(!m_formation_energy_hull){ymax+=extra_padding;}  //CO20180227 - we need to avoid labels here
            ymax=roundDouble(ymax,(int)round_to_value,true);  //we want max to be MORE POSITIVE, so round UP  //CO20190724 - explicit double->int conversion (floor is fine)
          }
        }
        y_range=abs(ymax-ymin);
        //max_tick_spacing=int(y_range/4);
        y_tick_distance=y_tick_distance_right=getYTickDistance(y_range,approx_num_ticks,round_to_value);

        //need new y_tick_distance if showkJmolaxis
        if(showkJmolaxis){
          double round_to_value_right=getRoundToValue(meVatom2kJmol*point_range);
          y_tick_distance_right=getYTickDistance(meVatom2kJmol*y_range,approx_num_ticks,round_to_value_right);
        }

        if(0||LDEBUG) {
          cerr << soliloquy << " point_range                                        = " << point_range << endl;
          cerr << soliloquy << " min_point                                          = " << min_point << endl;
          cerr << soliloquy << " max_point                                          = " << max_point << endl;
          cerr << soliloquy << " round_to_value                                     = " << round_to_value << endl;
          //cerr << soliloquy << " roundDouble(min_point,(int)round_to_value,false)        = " << roundDouble(min_point, (int)round_to_value, false) << endl; //CO20190724 - explicit double->int conversion (floor is fine)
          //cerr << soliloquy << " roundDouble(max_point,(int)round_to_value,true)         = " << roundDouble(max_point, (int)round_to_value, true) << endl;  //CO20190724 - explicit double->int conversion (floor is fine)
          cerr << soliloquy << " extra_padding                                      = " << extra_padding << endl;
          cerr << soliloquy << " ymin                                               = " << ymin << endl;
          cerr << soliloquy << " ymax                                               = " << ymax << endl;
          //cerr << soliloquy << " max_tick_spacing                                   = " << max_tick_spacing << endl;
          cerr << soliloquy << " y_tick_distance                                    = " << y_tick_distance << endl;
          cerr << soliloquy << " y_tick_distance_right                              = " << y_tick_distance_right << endl;
        }
        //need to convert to kJ/mol for right axis
        //if(dimension==2){
        //  common_settings_TEX_ss << "ymin=" << ymin << "," << endl;
        //  common_settings_TEX_ss << "ymax=" << ymax << "," << endl;
        //}
      }
      common_settings_TEX_ss << "clip=false," << endl;  // for labels

      double image_width=19;
      if(dimension==3){image_width=17;}
      common_settings_TEX_ss << "width=" << image_width << "cm," << endl;

      //hsize is not well defined, especially for image only
      //double image_height_proportion=0.65;
      //if(dimension==3){image_height_proportion=1.0;}
      //string image_height_str=aurostd::utype2string(image_height_proportion)+"\\hsize";  //better to define in terms of page, since this is what we are confined to
      //better to use cm
      double image_width_proportion=0.8;                //approx 15cm given 19cm width
      if(dimension==3){image_width_proportion=1.2;}     //approx 20cm given 17cm width
      common_settings_TEX_ss << "height=" << image_width_proportion*image_width << "cm," << endl;

      if(dimension==3){common_settings_TEX_ss << "axis line style={line width=3pt}," << endl;}
      //if(dimension == 2) {common_settings_TEX_ss << 20;}
      //else {  // dimension==3
      //  //CO change me if we see otherwise
      //  //if(include_color_bar) {
      //  //  if(image_only) {common_settings_TEX_ss << 21;}
      //  //  else {common_settings_TEX_ss << 17;}  // only time we change size
      //  //} else {common_settings_TEX_ss << 21;}
      //}
      //common_settings_TEX_ss << "cm," << endl;
      //if(dimension == 2) {
      //  if(image_only) {common_settings_TEX_ss << "height=0.8\\hsize," << endl;}
      //  else {common_settings_TEX_ss << "height=0.55\\hsize," << endl;}
      //} else {
      //  common_settings_TEX_ss << "height=\\hsize," << endl;
      //  common_settings_TEX_ss << "axis line style={line width=3pt}," << endl;
      //}
      common_settings_TEX_ss << "grid=none," << endl;
      common_settings_TEX_ss << "axis on top," << endl;  // prevents heat map overlap issues

      ////////////////////////////////////////////////////////////////////////////
      // START Axis
      ////////////////////////////////////////////////////////////////////////////

      double unary_distance_axis_3D=0.25;
      if(image_only){unary_distance_axis_3D=0.35;} //CO FIX

      uint g_state;
      if(dimension == 2) {
        uint top_axis_point, bottom_axis_point;
        if(!reverse_axes) {
          top_axis_point = 0;
          bottom_axis_point = 1;
        } else {
          top_axis_point = 1;
          bottom_axis_point = 0;
        }
        // first axis - kJ/atom, top and right axes, x label only for padding
        if(showkJmolaxis) //||!image_only)   //padding purposes
        { //CO20200106 - patching for auto-indenting
          //only needed if we want to pad for pseudo-centering (by eye), it is perfectly centered, but logos are different shapes
          //no need to pad for eye, waste of time
          if(0){ 
            pseudo_preliminary_axes_TEX_ss << "\\begin{axis}[" << endl;
            //BETTER CENTERING without labels
            //if(!image_only){
            //  pseudo_preliminary_axes_TEX_ss << "xlabel={";
            //  g_state=getUnaryGState(top_axis_point);
            //  //opacity==0
            //  //if(!plot_unaries && isViableGState(g_state)) {
            //  //  if(internal_links_graph2report) {
            //  //    pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
            //  //  } else if(no_doc && external_links) {
            //  //    pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
            //  //  }
            //  //}
            //  pseudo_preliminary_axes_TEX_ss << "{" << m_velements[top_axis_point] << "}";
            //  pseudo_preliminary_axes_TEX_ss << "}," << endl;
            //  pseudo_preliminary_axes_TEX_ss << "xlabel style={font=" << label_image_font_size << ",at={(xticklabel cs:" << top_axis_point << ")}";
            //  pseudo_preliminary_axes_TEX_ss << ",opacity=0}, \%we need labels for proper padding, but avoid bolder labels with opacity==0" << endl;
            //}
            pseudo_preliminary_axes_TEX_ss << "ylabel={{(kJ/mol)}}," << endl;
            pseudo_preliminary_axes_TEX_ss << "ylabel style={font=" << label_image_font_size; // << ",rotate=180";
            pseudo_preliminary_axes_TEX_ss << ",opacity=0}, \%we need labels for proper padding, but avoid bolder labels with opacity==0" << endl;
            pseudo_preliminary_axes_TEX_ss << "axis x line*=top," << endl;
            pseudo_preliminary_axes_TEX_ss << "axis y line*=right," << endl;
            pseudo_preliminary_axes_TEX_ss << "tick pos=right," << endl;
            pseudo_preliminary_axes_TEX_ss << "xtick={1,0.8,0.6,0.4,0.2,0}," << endl;
            pseudo_preliminary_axes_TEX_ss << "xticklabels={}," << endl;
            pseudo_preliminary_axes_TEX_ss << "xticklabel shift=6pt," << endl;
            pseudo_preliminary_axes_TEX_ss << "yticklabel shift=6pt," << endl;
            pseudo_preliminary_axes_TEX_ss << "yticklabel style={/pgf/number format/fixed,/pgf/number format/precision=5";
            pseudo_preliminary_axes_TEX_ss << ",opacity=0}, \%we need labels for proper padding, but avoid bolder labels with opacity==0" << endl;
            if(set_y_range_exactly){pseudo_preliminary_axes_TEX_ss << "ytick distance={" << y_tick_distance_right << "}," << endl;}
            pseudo_preliminary_axes_TEX_ss << "scaled y ticks=false," << endl;
            pseudo_preliminary_axes_TEX_ss << "xmin=0," << endl;
            pseudo_preliminary_axes_TEX_ss << "xmax=1," << endl;
            //removed ymin/ymax from common settings
            pseudo_preliminary_axes_TEX_ss << "ymin=" << (showkJmolaxis?meVatom2kJmol:1.0) * ymin << "," << endl;
            pseudo_preliminary_axes_TEX_ss << "ymax=" << (showkJmolaxis?meVatom2kJmol:1.0) * ymax << "," << endl;
            // insert common settings
            pseudo_preliminary_axes_TEX_ss << common_settings_TEX_ss.str();
            pseudo_preliminary_axes_TEX_ss << "]" << endl;
            pseudo_preliminary_axes_TEX_ss << "\\end{axis}" << endl;
          }

          // second axis - kJ/atom, top and right axes, x label only for padding
          pseudo_preliminary_axes_TEX_ss << "\\begin{axis}[" << endl;
          //BETTER CENTERING without labels
          //if(!image_only){
          //  pseudo_preliminary_axes_TEX_ss << "xlabel={";
          //  g_state=getUnaryGState(bottom_axis_point);
          //  //opacity==0
          //  //if(!plot_unaries && isViableGState(g_state)) {
          //  //  if(internal_links_graph2report) {
          //  //    pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
          //  //  } else if(no_doc && external_links) {
          //  //    pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
          //  //  }
          //  //}
          //  pseudo_preliminary_axes_TEX_ss << "{" << m_velements[bottom_axis_point] << "}";
          //  pseudo_preliminary_axes_TEX_ss << "}," << endl;
          //  pseudo_preliminary_axes_TEX_ss << "xlabel style={font=" << label_image_font_size << ",at={(xticklabel cs:" << bottom_axis_point << ")}";
          //  pseudo_preliminary_axes_TEX_ss << ",opacity=0}, \%we need labels for proper padding, but avoid bolder labels with opacity==0" << endl;
          //}
          pseudo_preliminary_axes_TEX_ss << "ylabel={{(kJ/mol)}}," << endl;
          pseudo_preliminary_axes_TEX_ss << "ylabel style={font=" << label_image_font_size; // << ",rotate=180";
          pseudo_preliminary_axes_TEX_ss << "}," << endl;
          pseudo_preliminary_axes_TEX_ss << "axis x line*=top," << endl;
          pseudo_preliminary_axes_TEX_ss << "axis y line*=right," << endl;
          pseudo_preliminary_axes_TEX_ss << "tick pos=right," << endl;
          pseudo_preliminary_axes_TEX_ss << "xtick={1,0.8,0.6,0.4,0.2,0}," << endl;
          pseudo_preliminary_axes_TEX_ss << "xticklabels={}," << endl;
          pseudo_preliminary_axes_TEX_ss << "xticklabel shift=6pt," << endl;
          pseudo_preliminary_axes_TEX_ss << "yticklabel shift=6pt," << endl;
          pseudo_preliminary_axes_TEX_ss << "yticklabel style={/pgf/number format/fixed,/pgf/number format/precision=5";
          pseudo_preliminary_axes_TEX_ss << "}," << endl;
          if(set_y_range_exactly){pseudo_preliminary_axes_TEX_ss << "ytick distance={" << y_tick_distance_right << "}," << endl;}
          pseudo_preliminary_axes_TEX_ss << "scaled y ticks=false," << endl;
          pseudo_preliminary_axes_TEX_ss << "xmin=0," << endl;
          pseudo_preliminary_axes_TEX_ss << "xmax=1," << endl;
          //removed ymin/ymax from common settings
          pseudo_preliminary_axes_TEX_ss << "ymin=" << (showkJmolaxis?meVatom2kJmol:1.0) * ymin << "," << endl;
          pseudo_preliminary_axes_TEX_ss << "ymax=" << (showkJmolaxis?meVatom2kJmol:1.0) * ymax << "," << endl;
          // insert common settings
          pseudo_preliminary_axes_TEX_ss << common_settings_TEX_ss.str();
          pseudo_preliminary_axes_TEX_ss << "]" << endl;
          pseudo_preliminary_axes_TEX_ss << "\\end{axis}" << endl;
        }

        //third axis - meV/atom, left x label only, make other stuff color white so it's not seen (exists for positioning purposes)
        if(0){
          //this axis is NO longer needed, we use xticklabel exclusive now
          pseudo_preliminary_axes_TEX_ss << "\\begin{axis}[" << endl;
          pseudo_preliminary_axes_TEX_ss << "xlabel={";
          g_state=getUnaryGState(top_axis_point);
          if(!plot_unaries && isViableGState(g_state)) {
            if(internal_links_graph2report) {
              pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
            } else if(no_doc && external_links) {
              pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
            }
          }
          pseudo_preliminary_axes_TEX_ss << "{" << m_velements[top_axis_point] << "}";
          pseudo_preliminary_axes_TEX_ss << "}," << endl;
          pseudo_preliminary_axes_TEX_ss << "xlabel style={font=" << label_image_font_size << ",at={(axis cs:" << top_axis_point << "," << ymin << ")}}," << endl; //{(xticklabel cs:" << top_axis_point << ")}," << endl;  //CO20200106 - patching for auto-indenting
          //add "max space between ticks=60" to change colorbar tick density
          if(showkJmolaxis){
            pseudo_preliminary_axes_TEX_ss << "axis x line*=bottom," << endl;
            pseudo_preliminary_axes_TEX_ss << "axis y line*=left," << endl;
            pseudo_preliminary_axes_TEX_ss << "tick pos=left," << endl;
          }
          pseudo_preliminary_axes_TEX_ss << "xtick={1,0.8,0.6,0.4,0.2,0}," << endl;
          pseudo_preliminary_axes_TEX_ss << "xticklabel style={opacity=0},  \%we need labels for proper padding, but avoid bolder labels with opacity==0" << endl;
          pseudo_preliminary_axes_TEX_ss << "xticklabel shift=6pt," << endl;
          pseudo_preliminary_axes_TEX_ss << "yticklabel shift=6pt," << endl;
          pseudo_preliminary_axes_TEX_ss << "yticklabel style={/pgf/number format/fixed,/pgf/number format/precision=5";
          pseudo_preliminary_axes_TEX_ss << ",opacity=0}, \%we need labels for proper padding, but avoid bolder labels with opacity==0" << endl;
          if(set_y_range_exactly){pseudo_preliminary_axes_TEX_ss << "ytick distance={" << y_tick_distance << "}," << endl;}
          pseudo_preliminary_axes_TEX_ss << "scaled y ticks=false," << endl;
          pseudo_preliminary_axes_TEX_ss << "xmin=0," << endl;
          pseudo_preliminary_axes_TEX_ss << "xmax=1," << endl;
          //removed ymin/ymax from common settings
          pseudo_preliminary_axes_TEX_ss << "ymin=" << ymin << "," << endl;
          pseudo_preliminary_axes_TEX_ss << "ymax=" << ymax << "," << endl;
          // insert common settings
          pseudo_preliminary_axes_TEX_ss << common_settings_TEX_ss.str();
          pseudo_preliminary_axes_TEX_ss << "]" << endl;
          pseudo_preliminary_axes_TEX_ss << "\\end{axis}" << endl;
        }

        // real axis - meV/atom, right x label and all points data
        pseudo_preliminary_axes_TEX_ss << "\\begin{axis}[" << endl;
        //xlabel is NO longer needed, we use xticklabel exclusive now
        //pseudo_preliminary_axes_TEX_ss << "xlabel={";
        //g_state=getUnaryGState(bottom_axis_point);
        //if(!plot_unaries && isViableGState(g_state)) {
        //  if(internal_links_graph2report) {
        //    pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
        //  } else if(no_doc && external_links) {
        //    pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
        //  }
        //}
        //pseudo_preliminary_axes_TEX_ss << "{" << m_velements[bottom_axis_point] << "}";
        //pseudo_preliminary_axes_TEX_ss << "}," << endl;
        //pseudo_preliminary_axes_TEX_ss << "xlabel style={font=" << label_image_font_size << ",at={(axis cs:" << bottom_axis_point << "," << ymin << ")}}," << endl; //{(xticklabel cs:" << bottom_axis_point << ")}," << endl;
        pseudo_preliminary_axes_TEX_ss << "ylabel={{" << (m_formation_energy_hull?"$H_{\\mathrm{f}}$ (meV/atom)":"$T_{\\mathrm{S}}$ (K)") << "}}," << endl;
        //pseudo_preliminary_axes_TEX_ss << "ylabel={{" << (m_formation_energy_hull?"formation enthalpy (meV/atom)":"entropic temperature (K)") << "}}," << endl;
        //if(m_formation_energy_hull) {pseudo_preliminary_axes_TEX_ss << "{formation enthalpy (meV/atom)}";}
        //else {pseudo_preliminary_axes_TEX_ss << "{entropic temperature (K)}";}
        //pseudo_preliminary_axes_TEX_ss << "}," << endl;
        pseudo_preliminary_axes_TEX_ss << "ylabel style={font=" << label_image_font_size << "}," << endl;
        //add "max space between ticks=60" to change colorbar tick density
        if(showkJmolaxis){
          pseudo_preliminary_axes_TEX_ss << "axis x line*=bottom," << endl;
          pseudo_preliminary_axes_TEX_ss << "axis y line*=left," << endl;
          pseudo_preliminary_axes_TEX_ss << "tick pos=left," << endl;
        }
        pseudo_preliminary_axes_TEX_ss << "xtick={1,0.8,0.6,0.4,0.2,0}," << endl;
        pseudo_preliminary_axes_TEX_ss << "xticklabels={";

        g_state=getUnaryGState(bottom_axis_point);
        if(!plot_unaries && isViableGState(g_state)) {
          if(internal_links_graph2report) {
            pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
          } else if(no_doc && external_links) {
            pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
          }
        }
        pseudo_preliminary_axes_TEX_ss << "{" << label_image_font_size << " " << m_velements[bottom_axis_point] << "}";

        pseudo_preliminary_axes_TEX_ss << ",0.8,0.6,0.4,0.2,";

        g_state=getUnaryGState(top_axis_point);
        if(!plot_unaries && isViableGState(g_state)) {
          if(internal_links_graph2report) {
            pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
          } else if(no_doc && external_links) {
            pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
          }
        }
        pseudo_preliminary_axes_TEX_ss << "{" << label_image_font_size << " " << m_velements[top_axis_point] << "}";

        pseudo_preliminary_axes_TEX_ss << "}," << endl;
        pseudo_preliminary_axes_TEX_ss << "xticklabel shift=6pt," << endl;
        pseudo_preliminary_axes_TEX_ss << "yticklabel shift=6pt," << endl;
        pseudo_preliminary_axes_TEX_ss << "yticklabel style={/pgf/number format/fixed,/pgf/number format/precision=5";
        pseudo_preliminary_axes_TEX_ss << "}," << endl;
        if(set_y_range_exactly){pseudo_preliminary_axes_TEX_ss << "ytick distance={" << y_tick_distance << "}," << endl;}
        pseudo_preliminary_axes_TEX_ss << "scaled y ticks=false," << endl;
      } else {  // dimension==3
        //first axis - kJ/mol, only for right color bar
        if(showkJmolaxis){
          if(display_color_gradient) {
            if(include_color_bar) {
              pseudo_preliminary_axes_TEX_ss << "\\begin{ternaryaxis}[" << endl;
              // Ylabel
              pseudo_preliminary_axes_TEX_ss << "ylabel={";
              g_state=getUnaryGState(0);
              if(!plot_unaries && isViableGState(g_state)) {
                if(internal_links_graph2report) {
                  pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
                } else if(no_doc && external_links) {
                  pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
                }
              }
              pseudo_preliminary_axes_TEX_ss << "{" << m_velements[0] << "}";
              pseudo_preliminary_axes_TEX_ss << "}," << endl;
              pseudo_preliminary_axes_TEX_ss << "ylabel style={font=" << label_image_font_size << ",at={(axis cs:0,1,0)},anchor=north east,below=" << unary_distance_axis_3D << "cm,left=" << unary_distance_axis_3D << "cm,opacity=0}, \%we need labels for proper padding, but avoid bolder labels with opacity==0" << endl;
              // Xlabel
              pseudo_preliminary_axes_TEX_ss << "xlabel={";
              g_state=getUnaryGState(1);
              if(!plot_unaries && isViableGState(g_state)) {
                if(internal_links_graph2report) {
                  pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
                } else if(no_doc && external_links) {
                  pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
                }
              }
              pseudo_preliminary_axes_TEX_ss << "{" << m_velements[1] << "}";
              pseudo_preliminary_axes_TEX_ss << "}," << endl;
              pseudo_preliminary_axes_TEX_ss << "xlabel style={font=" << label_image_font_size << ",at={(axis cs:1,0,0)},anchor=south,above=" << sqrt(2.0*unary_distance_axis_3D*unary_distance_axis_3D) << "cm,opacity=0}, \%we need labels for proper padding, but avoid bolder labels with opacity==0" << endl;
              // Zlabel
              pseudo_preliminary_axes_TEX_ss << "zlabel={";
              g_state=getUnaryGState(2);
              if(!plot_unaries && isViableGState(g_state)) {
                if(internal_links_graph2report) {
                  pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
                } else if(no_doc && external_links) {
                  pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
                }
              }
              pseudo_preliminary_axes_TEX_ss << "{" << m_velements[2] << "}";
              //if(!plot_unaries && isViableGState(g_state)) {
              //  if(internal_links_graph2report) {pseudo_preliminary_axes_TEX_ss << "}";}
              //  else if(no_doc && external_links) {pseudo_preliminary_axes_TEX_ss << "}";}
              //}
              pseudo_preliminary_axes_TEX_ss << "}," << endl;
              pseudo_preliminary_axes_TEX_ss << "zlabel style={font=" << label_image_font_size << ",at={(axis cs:0,0,1)},anchor=north west,below=" << unary_distance_axis_3D << "cm,right=" << unary_distance_axis_3D << "cm,opacity=0},  \%we need labels for proper padding, but avoid bolder labels with opacity==0" << endl;
              pseudo_preliminary_axes_TEX_ss << "xmin=0," << endl;
              pseudo_preliminary_axes_TEX_ss << "xmax=1," << endl;
              pseudo_preliminary_axes_TEX_ss << "ymin=0," << endl;
              pseudo_preliminary_axes_TEX_ss << "ymax=1," << endl;
              pseudo_preliminary_axes_TEX_ss << "zmin=0," << endl;
              pseudo_preliminary_axes_TEX_ss << "zmax=1," << endl;
              pseudo_preliminary_axes_TEX_ss << "ticks=none," << endl;
              //removed ymin/ymax from common settings
              pseudo_preliminary_axes_TEX_ss << common_settings_TEX_ss.str();
              // start colorbar
              // http://tex.stackexchange.com/questions/73025/how-to-change-label-and-ticks-of-a-pgfplots-colorbar
              pseudo_preliminary_axes_TEX_ss << "colorbar," << endl;
              pseudo_preliminary_axes_TEX_ss << "colorbar style={" << endl;
              pseudo_preliminary_axes_TEX_ss << "shift={(1.75cm,0cm)}," << endl; //-0cm
              pseudo_preliminary_axes_TEX_ss << "ylabel={{(kJ/mol)}}," << endl;
              pseudo_preliminary_axes_TEX_ss << "ylabel style={font=" << label_image_font_size << "}," << endl;
              pseudo_preliminary_axes_TEX_ss << "axis y line*=left," << endl;
              // ytick={18,20,25,...,45}
              pseudo_preliminary_axes_TEX_ss << "yticklabel style={/pgf/number format/fixed,/pgf/number format/precision=5}," << endl;
              pseudo_preliminary_axes_TEX_ss << "yticklabel shift=6pt," << endl;
              double round_to_value_right=getRoundToValue(meVatom2kJmol*point_range);
              double y_tick_distance_right=getYTickDistance(meVatom2kJmol*y_range,approx_num_ticks,round_to_value_right);
              if(set_y_range_exactly){pseudo_preliminary_axes_TEX_ss << "ytick distance={" << y_tick_distance_right << "}," << endl;}
              pseudo_preliminary_axes_TEX_ss << "ytick align=outside," << endl;
              pseudo_preliminary_axes_TEX_ss << "scaled y ticks=false," << endl;
              pseudo_preliminary_axes_TEX_ss << "ymin=" << meVatom2kJmol * ymin << "," << endl;
              pseudo_preliminary_axes_TEX_ss << "ymax=" << meVatom2kJmol * ymax << "," << endl;
              pseudo_preliminary_axes_TEX_ss << "}," << endl;
              // end colorbar
              pseudo_preliminary_axes_TEX_ss << "colormap={mymap}{" << color_map << "}," << endl;  // https://www.sharelatex.com/learn/Pgfplots_package
              // pseudo_preliminary_axes_TEX_ss << "colorbar, colormap/jet," << endl;
              pseudo_preliminary_axes_TEX_ss << "]" << endl;
              // add hullPoints and heat map data
              // there might only be one hullPoint, which breaks the colorbar code
              //heat map data first
              num_horizontal_planes=0;
              added_header=false;
              if(show_heat_map) {
                for(uint i=0,fl_size_i=m_i_facets.size();i<fl_size_i;i++) {
                  const ChullFacet& facet=m_facets[m_i_facets[i]];
                  if(facet.m_is_artificial){continue;}
                  if(facet.m_is_vertical) {
                    if(LDEBUG) {cerr << soliloquy << " NOT plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
                  } else {
                    if(LDEBUG) {cerr << soliloquy << " plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
                    num_horizontal_planes++;
                  }
                  chull_points = facet.getCHIndices();
                  added_header=false;
                  for(uint j=0,fl_size_j=chull_points.size();j<fl_size_j;j++) {
                    const ChullPoint& point = m_points[chull_points[j]];
                    // convex hull facets color
                    if(j == 0) {
                      pseudo_preliminary_axes_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HEAT_MAPS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
                      added_header=true;
                    }
                    pseudo_preliminary_axes_TEX_ss << getPlotPointContentPDF(point, true, true);
                  }
                  if(added_header){pseudo_preliminary_axes_TEX_ss << "};" << endl;}
                }
              }
              //now hullPoints
              added_header=false;
              for(uint i=0,fl_size_i=hull_points.size();i<fl_size_i;i++) {
                const ChullPoint& point = m_points[hull_points[i]];
                if(!point.m_has_entry) {continue;}
                if(!plot_unaries && point.isUnary()) {continue;}
                if(!added_header){
                  pseudo_preliminary_axes_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_POINTS,"H_f_kJmol",display_color_gradient);
                  added_header=true;
                }
                pseudo_preliminary_axes_TEX_ss << getPlotPointContentPDF(point, false, true);
              }
              if(plot_unaries){
                for(uint i=0;i<dimension;i++) {
                  g_state=getUnaryGState(i);
                  if(g_state>m_points.size()-1){continue;}
                  const ChullPoint& point = m_points[g_state];
                  if(!point.m_has_entry) {continue;}
                  if(!added_header){
                    pseudo_preliminary_axes_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_POINTS,"H_f_kJmol",display_color_gradient);
                    added_header=true;
                  }
                  pseudo_preliminary_axes_TEX_ss << getPlotPointContentPDF(point, false, true);
                }
              }
              if(added_header){pseudo_preliminary_axes_TEX_ss << "};" << endl;}
              if(plot_off_hull){
                added_header=false;
                for(uint i=0,fl_size_i=plot_points.size();i<fl_size_i;i++){
                  const ChullPoint& point=m_points[plot_points[i]];
                  if(point.m_is_g_state) {continue;}  // we already plotted these points
                  if(!added_header){
                    pseudo_preliminary_axes_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_OFF_HULL_POINTS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
                    added_header=true;
                  }
                  pseudo_preliminary_axes_TEX_ss << getPlotPointContentPDF(point, false, false);
                }
                if(added_header){pseudo_preliminary_axes_TEX_ss << "};" << endl;}
              }
              //add entry count, date, and logo here (all opacity = 0)
              if(1){
                node_option_ss << "opacity=" << 0 << ",shift={(" << watermark_x_shift << ",0cm)},anchor=north"; // << ",anchor=north west";
                //if(include_banner){node_position_ss << "axis cs:0.75,0.125,0.125";} //more complicated than necessary
                //else {
                node_position_ss << "axis cs:1,0,0";
                //}
                node_content_ss << "\\includegraphics[scale=0.25]{" << aflow_logo_skinny_file << "}";
                pseudo_preliminary_axes_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
              }
              if(small_banner)  //image_only)
              { //CO20200106 - patching for auto-indenting
                pseudo_preliminary_axes_TEX_ss << "\\begin{pgfonlayer}{background}" << endl;  // for overlap
                node_option_ss << "opacity=0.0,anchor=south,shift={(-" << watermark_x_shift << "," << sqrt(2.0*unary_distance_axis_3D*unary_distance_axis_3D) << "cm)}";
                node_position_ss << "axis cs:1,0,0";
                node_content_ss << general_image_font_size << " " << count_total_entries << " entries"; // doesn't work with externalizing images printCountTotalEntries
                pseudo_preliminary_axes_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);

                node_option_ss << "opacity=0.0,anchor=south,shift={(" << watermark_x_shift << "," << sqrt(2.0*unary_distance_axis_3D*unary_distance_axis_3D) << "cm)}";
                node_position_ss << "axis cs:1,0,0";
                node_content_ss << general_image_font_size << " \\today";
                pseudo_preliminary_axes_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
                pseudo_preliminary_axes_TEX_ss << "\\end{pgfonlayer}{background}" << endl;
              }
              pseudo_preliminary_axes_TEX_ss << "\\end{ternaryaxis}" << endl;
            }
          }
        }

        //real axis - meV/atom
        pseudo_preliminary_axes_TEX_ss << "\\begin{ternaryaxis}[" << endl;
        // Ylabel
        pseudo_preliminary_axes_TEX_ss << "ylabel={";
        g_state=getUnaryGState(0);
        if(!plot_unaries && isViableGState(g_state)) {
          if(internal_links_graph2report) {
            pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
          } else if(no_doc && external_links) {
            pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
          }
        }
        pseudo_preliminary_axes_TEX_ss << "{" << m_velements[0] << "}";
        pseudo_preliminary_axes_TEX_ss << "}," << endl;
        pseudo_preliminary_axes_TEX_ss << "ylabel style={font=" << label_image_font_size << ",at={(axis cs:0,1,0)},anchor=north east,below=" << unary_distance_axis_3D << "cm,left=" << unary_distance_axis_3D << "cm}," << endl;
        // Xlabel
        pseudo_preliminary_axes_TEX_ss << "xlabel={";
        g_state=getUnaryGState(1);
        if(!plot_unaries && isViableGState(g_state)) {
          if(internal_links_graph2report) {
            pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
          } else if(no_doc && external_links) {
            pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
          }
        }
        pseudo_preliminary_axes_TEX_ss << "{" << m_velements[1] << "}";
        pseudo_preliminary_axes_TEX_ss << "}," << endl;
        pseudo_preliminary_axes_TEX_ss << "xlabel style={font=" << label_image_font_size << ",at={(axis cs:1,0,0)},anchor=south,above=" << sqrt(2.0*unary_distance_axis_3D*unary_distance_axis_3D) << "cm}," << endl;
        // Zlabel
        pseudo_preliminary_axes_TEX_ss << "zlabel={";
        g_state=getUnaryGState(2);
        if(!plot_unaries && isViableGState(g_state)) {
          if(internal_links_graph2report) {
            pseudo_preliminary_axes_TEX_ss << "\\hyperrefTitle{" << input << "_" << m_points[g_state].m_entry.auid << "}";
          } else if(no_doc && external_links) {
            pseudo_preliminary_axes_TEX_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << m_points[g_state].m_entry.auid << "}";
          }
        }
        pseudo_preliminary_axes_TEX_ss << "{" << m_velements[2] << "}";
        pseudo_preliminary_axes_TEX_ss << "}," << endl;
        pseudo_preliminary_axes_TEX_ss << "zlabel style={font=" << label_image_font_size << ",at={(axis cs:0,0,1)},anchor=north west,below=" << unary_distance_axis_3D << "cm,right=" << unary_distance_axis_3D << "cm}," << endl;
      }
      // tikzpic_settings_TEX starts here
      tikzpic_settings_TEX_ss << "xmin=0," << endl;
      tikzpic_settings_TEX_ss << "xmax=1," << endl;
      if(dimension == 2) {
        tikzpic_settings_TEX_ss << "ymin=" << ymin << "," << endl;
        tikzpic_settings_TEX_ss << "ymax=" << ymax << "," << endl;
      } else {  // dimension==3
        tikzpic_settings_TEX_ss << "ymin=0," << endl;
        tikzpic_settings_TEX_ss << "ymax=1," << endl;
        tikzpic_settings_TEX_ss << "zmin=0," << endl;
        tikzpic_settings_TEX_ss << "zmax=1," << endl;
        tikzpic_settings_TEX_ss << "ticks=none," << endl;
      }
      //removed ymin/ymax from common settings
      tikzpic_settings_TEX_ss << common_settings_TEX_ss.str();

      ////////////////////////////////////////////////////////////////////////////
      // END Tikz pic settings
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START Colorbar settings
      ////////////////////////////////////////////////////////////////////////////

      // won't enter if dimension==2, colorbar automatically turned off
      // start colorbar
      // http://tex.stackexchange.com/questions/73025/how-to-change-label-and-ticks-of-a-pgfplots-colorbar
      if(display_color_gradient) {
        if(include_color_bar) {
          tikzpic_settings_TEX_ss << "colorbar," << endl;
          tikzpic_settings_TEX_ss << "colorbar style={" << endl;
          tikzpic_settings_TEX_ss << "shift={(1.75cm,0cm)}," << endl;  //-0cm
          tikzpic_settings_TEX_ss << "ylabel={{" << (m_formation_energy_hull?"formation enthalpy (meV/atom)":"entropic temperature (K)") << "}}," << endl;
          tikzpic_settings_TEX_ss << "ylabel style={font=" << label_image_font_size; // << ",rotate=180";
          tikzpic_settings_TEX_ss << "}," << endl;
          if(showkJmolaxis){tikzpic_settings_TEX_ss << "axis y line*=right," << endl;}
          // ytick={18,20,25,...,45}
          tikzpic_settings_TEX_ss << "yticklabel style={/pgf/number format/fixed,/pgf/number format/precision=5}," << endl;
          tikzpic_settings_TEX_ss << "yticklabel shift=6pt," << endl;
          if(set_y_range_exactly){tikzpic_settings_TEX_ss << "ytick distance={" << y_tick_distance << "}," << endl;}
          tikzpic_settings_TEX_ss << "ytick align=outside," << endl;
          tikzpic_settings_TEX_ss << "scaled y ticks=false," << endl;
          tikzpic_settings_TEX_ss << "ymin=" << ymin << "," << endl;
          tikzpic_settings_TEX_ss << "ymax=" << ymax << "," << endl;
          tikzpic_settings_TEX_ss << "}," << endl;
        }
        // end colorbar
        tikzpic_settings_TEX_ss << "colormap={mymap}{" << color_map << "}," << endl;  // https://www.sharelatex.com/learn/Pgfplots_package
        // tikzpic_settings_TEX_ss << "colorbar, colormap/jet," << endl;
      }
      tikzpic_settings_TEX_ss << "]" << endl;

      ////////////////////////////////////////////////////////////////////////////
      // END Colorbar settings
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START Plotting everything on the hull (facet lines, colors, etc.)
      ////////////////////////////////////////////////////////////////////////////

      // for 2d, we go through points2d (in order by stoichiometry), otherwise, we
      // go through planes (order doesn't matter)
      if(dimension == 2) {
        // we use vertices vs. hull_points for facets because vertices
        // contain artificial end points for plotting

        added_header=false;
        for(uint i=0,fl_size_i=hull_points.size();i<fl_size_i;i++) {
          if(!added_header){
            tikzpic_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_FACETS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
            added_header=true;
          }
          tikzpic_TEX_ss << getPlotPointContentPDF(m_points[hull_points[i]], true, true);
        }
        if(added_header){tikzpic_TEX_ss << "};" << endl;}

        // we plot hullpoints for points on hull ONLY (not lines)
        added_header=false;
        for(uint i=0,fl_size_i=hull_points.size();i<fl_size_i;i++) {
          const ChullPoint point=m_points[hull_points[i]];
          if(!point.m_has_entry) {continue;}
          if(!plot_unaries && point.isUnary()) {continue;}
          if(!added_header){
            tikzpic_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_POINTS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
            added_header=true;
          }
          tikzpic_TEX_ss << getPlotPointContentPDF(point, false, true);
        }
        if(plot_unaries){
          for(uint i=0;i<dimension;i++) {
            g_state=getUnaryGState(i);
            if(g_state>m_points.size()-1){continue;}
            const ChullPoint& point = m_points[g_state];
            if(!point.m_has_entry) {continue;}
            if(!added_header){
              tikzpic_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_POINTS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
              added_header=true;
            }
            tikzpic_TEX_ss << getPlotPointContentPDF(point, false, true);
          }
        }
        if(added_header){tikzpic_TEX_ss << "};" << endl;}
      } else {  // dimension==3
        //////////////////////////////////////////////////////////////////////////
        // START 3D Heat maps and facet lines
        //////////////////////////////////////////////////////////////////////////

        // this option allows for overlapping facet lines (may or may not be desired)
        if(draw_all_facet_lines) {
          num_horizontal_planes=0;
          for(uint i=0,fl_size_i=m_i_facets.size();i<fl_size_i;i++) {
            const ChullFacet& facet=m_facets[m_i_facets[i]];
            if(facet.m_is_artificial){continue;}
            if(facet.m_is_vertical) {
              if(LDEBUG) {cerr << soliloquy << " NOT plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
            } else {
              if(LDEBUG) {cerr << soliloquy << " plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
              num_horizontal_planes++;
            }
            chull_points = facet.getCHIndices();
            chull_points.push_back(chull_points[0]);  // that way we get full facet
            added_header=false;
            for(uint j=0,fl_size_j=chull_points.size();j<fl_size_j;j++) {
              const ChullPoint& point = m_points[chull_points[j]];
              // keep first coord
              if(j == 0) {
                // convex hull facets color
                heat_map_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HEAT_MAPS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
                // convex hull facets (lines)
                convex_hull_facets_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_FACETS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
                // thick white line for contrast
                convex_hull_facets_drop_shadow_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
                added_header=true;
              }
              convex_hull_facets_TEX_ss << getPlotPointContentPDF(point, true, true);
              convex_hull_facets_drop_shadow_TEX_ss << getPlotPointContentPDF(point, true, true);
              if(j!=chull_points.size()-1) {  // heatmap doesn't need first coord repeated
                heat_map_TEX_ss << getPlotPointContentPDF(point, true, true);
              }
            }
            // end line for connecting facet lines
            if(added_header){
              convex_hull_facets_TEX_ss << "};" << endl;
              convex_hull_facets_drop_shadow_TEX_ss << "};" << endl;
              heat_map_TEX_ss << "};" << endl;
            }
          }
        } else {
          // no choice but to go through planes twice, once for
          // heatmap, the other for facet lines/drop shadows

          // heatmap
          num_horizontal_planes=0;
          if(show_heat_map) {
            for(uint i=0,fl_size_i=m_i_facets.size();i<fl_size_i;i++) {
              const ChullFacet& facet=m_facets[m_i_facets[i]];
              if(facet.m_is_artificial){continue;}
              if(facet.m_is_vertical) {
                if(LDEBUG) {cerr << soliloquy << " NOT plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
              } else {
                if(LDEBUG) {cerr << soliloquy << " plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
                num_horizontal_planes++;
              }
              chull_points = facet.getCHIndices();
              added_header=false;
              for(uint j=0,fl_size_j=chull_points.size();j<fl_size_j;j++) {
                const ChullPoint& point = m_points[chull_points[j]];
                // convex hull facets color
                if(j == 0) {
                  heat_map_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HEAT_MAPS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
                  added_header=true;
                }
                heat_map_TEX_ss << getPlotPointContentPDF(point, true, true);
              }
              if(added_header){heat_map_TEX_ss << "};" << endl;}
            }
          }
          // save time by not saving WHOLE chullPoints, just compositional part of
          // xvector for facet lines
          //vector<vector<xvector<double> > > facet_lines, facet_lines_dropshadow;
          //fix UNWANTEDFACETLINE to check indices, not actual coords
          num_horizontal_planes=0;
          for(uint ii=0,fl_size_ii=facet_lines.size();ii<fl_size_ii;ii++){facet_lines[ii].clear();} facet_lines.clear();
          for(uint ii=0,fl_size_ii=facet_lines_dropshadow.size();ii<fl_size_ii;ii++){facet_lines_dropshadow[ii].clear();} facet_lines_dropshadow.clear();
          for(uint i=0,fl_size_i=m_i_facets.size();i<fl_size_i;i++) {
            const ChullFacet& facet=m_facets[m_i_facets[i]];
            if(facet.m_is_artificial){continue;}
            if(facet.m_is_vertical) {
              if(LDEBUG) {cerr << soliloquy << " NOT plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
            } else {
              if(LDEBUG) {cerr << soliloquy << " plane: " << abs(facet.m_normal[facet.m_normal.urows]) << endl;}
              num_horizontal_planes++;
            }
            chull_points = facet.getCHIndices();
            chull_points.push_back(chull_points[0]);  // that way we get full facet
            if(LDEBUG) {cerr << soliloquy << " looking for all unwanted facets" << endl;}
            for(uint l=0,fl_size_l=chull_points.size();l<fl_size_l - 1;l++) {
              if(LDEBUG) {cerr << soliloquy << " looking at point l=" << l << " and l=" << l + 1 << endl;}
              if(!unwantedFacetLine(chull_points[l], chull_points[l+1], facet_lines, true)) {
                if(LDEBUG) {cerr << soliloquy << " plotting point l=" << l << " and l=" << l + 1 << endl;}
                // convex hull facets (lines)
                convex_hull_facets_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_FACETS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
                for(uint j=0;j<2;j++) {
                  const ChullPoint& point = m_points[chull_points[l+j]];
                  convex_hull_facets_TEX_ss << getPlotPointContentPDF(point, true, true);
                }
                // end line for connecting facet lines
                convex_hull_facets_TEX_ss << "};" << endl;
              } else {
                if(LDEBUG) {
                  cerr << soliloquy << " skipping l=" << l << " and l=" << l + 1 << endl;
                  cerr << soliloquy << " l=" << l << " is " << m_points[chull_points[l]].m_coords << endl;
                  cerr << soliloquy << " l=" << l+1 << " is " << m_points[chull_points[l+1]].m_coords << endl;
                }
              }
              if(hull_drop_shadow) {
                if(!unwantedFacetLine(chull_points[l], chull_points[l+1], facet_lines_dropshadow, false)){
                  if(LDEBUG) {cerr << soliloquy << " plotting drop shadow l=" << l << " and l=" << l + 1 << endl;}
                  // thick white line for contrast
                  convex_hull_facets_drop_shadow_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_FACETSDROP_SHADOWS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
                  for(uint j=0;j<2;j++) {
                    const ChullPoint& point = m_points[chull_points[l+j]];
                    convex_hull_facets_drop_shadow_TEX_ss << getPlotPointContentPDF(point, true, true);
                  }
                  // end line for connecting facet lines
                  convex_hull_facets_drop_shadow_TEX_ss << "};" << endl;
                } else {
                  if(LDEBUG) {
                    cerr << soliloquy << " skipping drop shadow l=" << l << " and l=" << l + 1 << endl;
                    cerr << soliloquy << " l=" << l << " is " << m_points[chull_points[l]].m_coords << endl;
                    cerr << soliloquy << " l=" << l+1 << " is " << m_points[chull_points[l+1]].m_coords << endl;
                  }
                }
              }
            }
          }
        }

        //////////////////////////////////////////////////////////////////////////
        // END 3D Heat maps and facet lines
        //////////////////////////////////////////////////////////////////////////

        // hullPoints only, so they don't repeat
        added_header=false;
        for(uint i=0,fl_size_i=hull_points.size();i<fl_size_i;i++) {
          const ChullPoint& point = m_points[hull_points[i]];
          if(!point.m_has_entry) {continue;}
          if(!plot_unaries && point.isUnary()) {continue;}
          if(!added_header){
            convex_hull_vertices_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_POINTS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
            added_header=true;
          }
          convex_hull_vertices_TEX_ss << getPlotPointContentPDF(point, false, true);
        }
        if(plot_unaries){
          for(uint i=0;i<dimension;i++) {
            g_state=getUnaryGState(i);
            if(g_state>m_points.size()-1){continue;}
            const ChullPoint& point = m_points[g_state];
            if(!point.m_has_entry) {continue;}
            if(!added_header){
              convex_hull_vertices_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_HULL_POINTS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient);
              added_header=true;
            }
            convex_hull_vertices_TEX_ss << getPlotPointContentPDF(point, false, true);
          }
        }
        if(added_header){convex_hull_vertices_TEX_ss << "};" << endl;}

        // big merge
        // white lines first, then black
        if(hull_drop_shadow) {tikzpic_TEX_ss << convex_hull_facets_drop_shadow_TEX_ss.str();}
        tikzpic_TEX_ss << convex_hull_facets_TEX_ss.str();
        tikzpic_TEX_ss << convex_hull_vertices_TEX_ss.str();
        convex_hull_facets_TEX_ss.str("");
        convex_hull_vertices_TEX_ss.str("");
        convex_hull_facets_drop_shadow_TEX_ss.str("");
      }

      ////////////////////////////////////////////////////////////////////////////
      // END Plotting everything on the hull (facet lines, colors, etc.)
      ////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////
      // START Plotting off hull points
      ////////////////////////////////////////////////////////////////////////////

      if(LDEBUG) {cerr << soliloquy << " start plotting off hull points" << endl;}
      if(plot_off_hull || !no_labels || internal_links_graph2report || no_doc) {
        string compound_label;
        bool found_icsd_label=false;
        for(uint i=0,fl_size_i=plot_points.size();i<fl_size_i;i++){
          const ChullPoint& point=m_points[plot_points[i]];
          const aflowlib::_aflowlib_entry& entry = point.m_entry;
          // get coords for table
          if(plot_off_hull) {
            if(!point.m_is_g_state) {  // we already plotted these points
              points_data_ss << getPlotPointContentPDF(point, false, false);
            }
          }
          if(!plot_off_hull && !point.m_is_g_state) {continue;}

          //////////////////////////////////////////////////////////////////////
          // START Creating clickable links at points
          //////////////////////////////////////////////////////////////////////

          if(internal_links_graph2report || (no_doc && external_links)) {
            node_option_ss << "opacity=0.0";// get node option
            node_position_ss << getNodeCoordPosition(point); // get node position
            // get node content
            node_content_ss << "\\tiny";
            node_content_ss << "{";
            if(no_doc && external_links) {node_content_ss << "\\href{" << ENTRY_PAGE_URL_PREFIX << entry.auid << "}";}
            else {
              //uint i_coord_group;
              if(getCoordGroupIndex(point,i_coord_group)){
                uint ref_state=m_coord_groups[i_coord_group].m_ref_state;
                if(isViablePoint(ref_state)){
                  node_content_ss << "\\hyperref[" << input << "_" << m_points[ref_state].m_entry.auid << "]";  // for hyperref to right part of document
                }
              }
            }
            node_content_ss << "{O}";
            node_content_ss << "}";
            labels_data_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss); // create node
          }

          //////////////////////////////////////////////////////////////////////
          // END Creating clickable links at points
          //////////////////////////////////////////////////////////////////////

          // now we create labels
          // do not create another node for unaries unless metalabels or
          // protolables
          if(!no_labels && !(!labels_off_hull && !point.m_is_g_state) && !(point.isUnary() && !(meta_labels || prototype_labels))) {
            ////////////////////////////////////////////////////////////////////
            // START Meta-labels (lots of info)
            ////////////////////////////////////////////////////////////////////

            if(meta_labels) {
              uint precision_tmp=0;
              double tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);
              // no node option

              // get node position
              node_position_ss << getNodeCoordPosition(point);

              // get node content
              if(dimension == 3 && entry.vspecies.size() == 3) {node_content_ss << "\\color{" << ternary_label_color << "}";}

              node_content_ss << "\\tiny{";   //these are sort of "special" font settings meant to reduce clutter, no need to add to aflowrc
              node_content_ss << "\\shortstack{";
              compound_label = prettyPrintCompound(point,(plot_reduced_composition?gcd_vrt:no_vrt),true,latex_ft);  // don't print prototype if not
              node_content_ss << compound_label;
              // equal to compound
              output_name=prettyPrintPrototype(point,false,false);  // only one backslash needed
              if(compound_label != output_name) {
                node_content_ss << "::";
                node_content_ss << output_name;
              }
              // shortstack newline
              node_content_ss << "\\\\";
              // enthalpy of formation, row 4
              // no need for precision for next few columns, leave it same way
              // as received from AFLOW
              node_content_ss << "$H_{\\mathrm{f}}$=" << aurostd::utype2string(chull::H_f_atom(point,_m_),precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM) << " meV/atom";
              //num_ss << chull::H_f_atom(point,_m_);
              //node_content_ss << "$H_{\\mathrm{f}}$=" << num_ss.str() << " meV/atom";
              //num_ss.str("");
              // shortstack newline
              node_content_ss << "\\\\";
              // entropic temperature, row 5
              node_content_ss << "$T_{\\mathrm{S}}$=" << aurostd::utype2string(chull::T_S(point),precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM) << " K";
              //num_ss << chull::T_S(point);
              //node_content_ss << "$T_{\\mathrm{S}}$=" << num_ss.str() << " K";
              //num_ss.str("");
              // dist_2_hull, row 6
              if(!point.isGState()) {
                // shortstack newline
                node_content_ss << "\\\\";
                if(m_formation_energy_hull) {
                  node_content_ss << "$" << getDelta(helvetica_font) << " H_{\\mathrm{f}}$=" << aurostd::utype2string(point.getDist2Hull(_m_),precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM) << " meV/atom";  //CHULL_PRECISION
                } else {
                  node_content_ss << "$" << getDelta(helvetica_font) << " T_{\\mathrm{S}}$=" << aurostd::utype2string(point.getDist2Hull(_std_),precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM) << " K"; //CHULL_PRECISION
                }
              }
              node_content_ss << "}";
              node_content_ss << "}";
              // create node
              labels_data_ss << nodeCreator(node_option_ss, node_position_ss,node_content_ss);

              //////////////////////////////////////////////////////////////////
              // END Meta-labels (lots of info)
              //////////////////////////////////////////////////////////////////

            } else {  // no metadata
              // special case
              // create two nodes, one with compound name below ground-state
              // node, another with prototype above each node

              //////////////////////////////////////////////////////////////////
              // START Special case labels (2D with prototypes)
              //////////////////////////////////////////////////////////////////

              if(dimension == 2 && !plot_labels && prototype_labels && rotate_labels) {
                if(point.m_is_g_state && !point.isUnary()) {
                  // get node option
                  node_option_ss << "rotate=90,anchor=" << (m_formation_energy_hull?"east":"west");
                  // get node position
                  node_position_ss << getNodeCoordPosition(point);
                  // get node content
                  node_content_ss << "\\" << font_size << "{";  //leave g-states as default font
                  if(bold_labels/* && !helvetica_font*/) {node_content_ss << "\\textbf{";}
                  if(!m_formation_energy_hull){node_content_ss << "~~";}   //pre - 1
                  node_content_ss << prettyPrintCompound(point,(plot_reduced_composition?gcd_vrt:no_vrt),true,latex_ft);
                  if(m_formation_energy_hull){node_content_ss << "~~";}  //post - 2: only works if we put two?
                  if(bold_labels/* && !helvetica_font*/) {node_content_ss << "}";}
                  node_content_ss << "}";
                  // create node
                  labels_data_ss << nodeCreator(node_option_ss, node_position_ss,node_content_ss);
                }
                // prototype label
                // get node option
                if(point.isUnary()) {
                  if(entry.vspecies[0] == m_velements[0]) {node_option_ss << "anchor=east";}
                  else {node_option_ss << "anchor=west";}
                } else {node_option_ss << "anchor=" << (m_formation_energy_hull?"south,above=0.1cm":"north,below=0.1cm");}
                // get node position
                node_position_ss << getNodeCoordPosition(point);
                // get node content
                node_content_ss << "\\scriptsize{"; //these are sort of "special" font settings meant to reduce clutter, no need to add to aflowrc
                output_name=prettyPrintPrototype(point,false,false);  // only one backslash needed
                if(point.isUnary() && entry.vspecies[0] == m_velements[1]) {node_content_ss << "~~";}
                node_content_ss << output_name;
                if(point.isUnary() && entry.vspecies[0] == m_velements[0]) {node_content_ss << "~~";}
                // enclose brackets
                node_content_ss << "}";
                // create node
                labels_data_ss << nodeCreator(node_option_ss, node_position_ss,node_content_ss);

                ////////////////////////////////////////////////////////////////
                // END Special case labels (2D with prototypes)
                ////////////////////////////////////////////////////////////////

              } else {  // normal case

                ////////////////////////////////////////////////////////////////
                // START Normal labels
                ////////////////////////////////////////////////////////////////

                // get node option
                if(rotate_labels) {
                  if(dimension == 2) {
                    if(!point.isUnary()) {  //deal with unaries later
                      if(point.m_is_g_state) {node_option_ss << "rotate=90,anchor=" << (m_formation_energy_hull?"east":"west");}
                      else {node_option_ss << "anchor=" << (m_formation_energy_hull?"south,above=0.1cm":"north,below=0.1cm");}
                    }
                  } else {  // dimension==3
                    // ordered to optimize speed (binaries are bulk, then ternaries, then unaries)
                    if(entry.vspecies.size() == 2) {
                      // / side of triangle
                      if(entry.vspecies[0] == m_velements[0] && entry.vspecies[1] == m_velements[1]) {
                        node_option_ss << "rotate=-30,anchor=east";
                        // \ side of triangle
                      } else if(entry.vspecies[0] == m_velements[1] && entry.vspecies[1] == m_velements[2]) {
                        node_option_ss << "rotate=30,anchor=west";
                        // _ side of triangle
                      } else if(entry.vspecies[0] == m_velements[0] && entry.vspecies[1] == m_velements[2]) {
                        node_option_ss << "rotate=90,anchor=east";
                      }
                    } else if(entry.vspecies.size() == 3) {
                      if(!show_heat_map) {node_option_ss << "anchor=south,above=0.1cm";}
                    } else if(entry.vspecies.size() == 1) {
                      // bottom two edges of triangle
                      if(entry.vspecies[0] == m_velements[0] || entry.vspecies[0] == m_velements[2]) {
                        node_option_ss << "anchor=north,below=0.1cm";
                        // top of triangle
                      } else {node_option_ss << "anchor=south,above=0.1cm";}
                    }
                  }
                }
                if(dimension == 2) {  //deal with unaries separately
                  if(point.isUnary()) {
                    if(entry.vspecies[0] == m_velements[0]) {node_option_ss << "anchor=east";}
                    else {node_option_ss << "anchor=west";}
                  }
                }
                // get node position
                node_position_ss << getNodeCoordPosition(point);
                // get node content
                if(dimension == 3 && entry.vspecies.size() == 3) {node_content_ss << "\\color{" << ternary_label_color << "}";}
                if(compound_labels && prototype_labels) {node_content_ss << "\\scriptsize{";} //these are sort of "special" font settings meant to reduce clutter, no need to add to aflowrc
                else {node_content_ss << "\\" << font_size << "{";}  //already gets wrapped with brackets in nodeCreator(), just leave alone so you mitigate spaces
                if(bold_labels || (entry.vspecies.size() == 3 && bold_labels_ternaries)/* && !helvetica_font*/) {node_content_ss << "\\textbf{";}

                // add space for rotation
                if(rotate_labels) {
                  if(dimension == 2) {
                    if(!point.isUnary()){ //handle unaries later
                      if(!m_formation_energy_hull && point.m_is_g_state){node_content_ss << "~";}
                    }
                  } else {  // dimension==3
                    if(entry.vspecies.size() == 2) {
                      // \ side of triangle
                      if(entry.vspecies[0] == m_velements[1] && entry.vspecies[1] == m_velements[2]) {
                        node_content_ss << "~";
                      }
                    }
                  }
                }
                if(dimension == 2) {
                  if(point.isUnary()){  //unaries
                    if(entry.vspecies[0] == m_velements[1]) {node_content_ss << "~";}
                  }
                }

                found_icsd_label=false;
                if(icsd_labels){  //icsd_labels mutually exclusive with compound/prototype
                  //uint i_coord_group;
                  if(getCoordGroupIndex(point,i_coord_group)){
                    uint canonical_icsd=m_coord_groups[i_coord_group].m_i_canonical_icsd;
                    if(isViablePoint(canonical_icsd)){
                      compound_label = prettyPrintPrototype(m_points[canonical_icsd],false,true);  // only one backslash needed  //icsd_skim_label=true
                      if(!compound_label.empty()){
                        node_content_ss << compound_label;
                        found_icsd_label=true;
                      }
                    }
                  }
                }
                if(!(icsd_labels&&found_icsd_label)){
                  if(compound_labels) {
                    compound_label = prettyPrintCompound(point,(plot_reduced_composition?gcd_vrt:no_vrt),true,latex_ft);  // don't print prototype if
                    node_content_ss << compound_label;
                    // equal to compound
                  }
                  if(prototype_labels) {
                    output_name=prettyPrintPrototype(point,false,false);  // only one backslash needed
                    if(compound_labels) {
                      if(compound_label != output_name) {
                        node_content_ss << "::";
                        node_content_ss << output_name;
                      }
                    } else {node_content_ss << output_name;}
                  }
                }

                if(rotate_labels) {
                  if(dimension == 2) {
                    if(!point.isUnary()){ //handle unaries later
                      if(m_formation_energy_hull && point.m_is_g_state){node_content_ss << "~~";} // only works if we put two?
                    }
                  } else {  // dimension==3
                    if(entry.vspecies.size() == 2) {
                      // / side of triangle
                      if(entry.vspecies[0] == m_velements[0] && entry.vspecies[1] == m_velements[1]) {
                        node_content_ss << "~~";  // only works if we put two?
                        // _ side of triangle
                      } else if(entry.vspecies[0] == m_velements[0] && entry.vspecies[1] == m_velements[2]) {
                        node_content_ss << "~~";  // only works if we put two?
                      }
                    }
                  }
                }
                if(dimension == 2) {
                  if(point.isUnary()){ //unaries
                    if(entry.vspecies[0] == m_velements[0]) {node_content_ss << "~~";}
                  }
                }

                // enclose brackets
                if(bold_labels || (entry.vspecies.size() == 3 && bold_labels_ternaries)/* && !helvetica_font*/) {node_content_ss << "}";}
                node_content_ss << "}";
                // create node
                labels_data_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);

                ////////////////////////////////////////////////////////////////
                // END Normal labels
                ////////////////////////////////////////////////////////////////
              }
            }
          }
        }
        // merge labels data
        if(plot_off_hull && !points_data_ss.str().empty()) {
          tikzpic_TEX_ss << getPlotHeaderPDF(ADDPLOT_MODE_OFF_HULL_POINTS,DEFAULT_PLOT_COLUMN_HEADER,display_color_gradient); // header for points off hull
          tikzpic_TEX_ss << points_data_ss.str();
          tikzpic_TEX_ss << "};" << endl;
        }
        //add isomax data
        if(plot_iso_max_latent_heat){
          string color;
          uint g_point;
          vector<string> latex_colors=grabAcceptableLatexColors(LATEX_COLORS_TO_AVOID,true,true,g_states.size());
          if(latex_colors.size()!=g_states.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Issue grabbing latex colors");}
          for(uint gi=0,fl_size_gi=g_states.size();gi<fl_size_gi;gi++){
            color=latex_colors[gi];
            //add curves
            tikzpic_TEX_ss << "\\addplot[domain=0.001:0.999,smooth,variable=\\x," << color << "] {";
            g_point=g_states[gi];
            tikzpic_TEX_ss << ((double)KBOLTZEV) << "*" << 1.0e3 << "*" << T_S(m_points[g_point]) << "*(\\x*ln(\\x)+(1-\\x)*ln(1-\\x))};" << endl;
            //add labels
            labels_data_ss << "\\node [fill=white] at (axis cs:0.5," << isoMaxLatentHeat(m_points[g_point],0.5,_m_);
            labels_data_ss << ") {\\" << font_size << "{$T_{\\mathrm{S}}=" << int(T_S(m_points[g_point])+0.5) << "~\\mathrm{K}$}};" << endl;
          }
        }
        if(!labels_data_ss.str().empty()) {
          tikzpic_TEX_ss << "\\begin{pgfonlayer}{foreground}" << endl;  // for overlap
          tikzpic_TEX_ss << labels_data_ss.str();
          tikzpic_TEX_ss << "\\end{pgfonlayer}{foreground}" << endl;
        }
      }
      if(LDEBUG) {cerr << soliloquy << " start plotting logos" << endl;}
      if(1){
        //add node with logo inside first
        tikzpic_TEX_ss << "\\begin{pgfonlayer}{background}" << endl;  // for overlap
        //tikzpic_TEX_ss << "\\begin{scope}[overlay,on background layer]" << endl;
        if(dimension==2){
          ////top left
          //node_option_ss << "opacity=" << opacity_watermark;
          //node_position_ss << "axis cs:0.1," << ymin*0.05;
          //node_content_ss << "\\includegraphics[scale=0.15]{" << aflow_logo_skinny_file << "}";
          //tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
          ////top right
          //node_option_ss << "opacity=" << opacity_watermark;
          //node_position_ss << "axis cs:0.9," << ymin*0.05;
          //node_content_ss << "\\includegraphics[scale=0.15]{" << aflow_logo_skinny_file << "}";
          //tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
          ////bottom left
          //node_option_ss << "opacity=" << opacity_watermark;
          //node_position_ss << "axis cs:0.1," << ymin*0.95;
          //node_content_ss << "\\includegraphics[scale=0.15]{" << aflow_logo_skinny_file << "}";
          //tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
          //bottom right
          //node_option_ss << "opacity=" << opacity_watermark;
          //node_position_ss << "axis cs:0.9," << ymin*0.95;
          //node_content_ss << "\\includegraphics[scale=0.15]{" << aflow_logo_skinny_file << "}";
          //tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
          ////center
          //node_option_ss << "opacity=" << opacity_watermark;
          //node_position_ss << "axis cs:0.5," << ymin*0.5;
          //node_content_ss << "\\includegraphics[scale=0.15]{" << aflow_logo_skinny_file << "}";
          //tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
          //node_position_ss << "axis cs:0.125," << ymin*0.95;
          node_option_ss << "opacity=" << opacity_watermark << ",anchor=south west";
          node_position_ss << "axis cs:0," << ymin;
          node_content_ss << "\\includegraphics[scale=0.25]{" << aflow_logo_skinny_file << "}";
          tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
        } else {  //dimension==3
          //// / side
          //node_option_ss << "opacity=" << opacity_watermark << ",rotate=60,anchor=south";
          //node_position_ss << "axis cs:0.5,0.5,0";
          //node_content_ss << "\\includegraphics[scale=0.15]{" << aflow_logo_skinny_file << "}";
          //tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
          //// \ side
          //node_option_ss << "opacity=" << opacity_watermark << ",rotate=-60,anchor=south";
          //node_position_ss << "axis cs:0.5,0,0.5";
          //node_content_ss << "\\includegraphics[scale=0.15]{" << aflow_logo_skinny_file << "}";
          //tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
          //// _ side
          //node_option_ss << "opacity=" << opacity_watermark << ",anchor=north";
          //node_position_ss << "axis cs:0,0.5,0.5";
          //node_content_ss << "\\includegraphics[scale=0.15]{" << aflow_logo_skinny_file << "}";
          //tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
          //node_position_ss << "axis cs:0,0.5,0.5";
          //node_option_ss << ",shift={(0in,-1in)}";
          if(!small_banner) //&& include_color_bar)
          { //CO20200106 - patching for auto-indenting
            node_option_ss << "opacity=" << opacity_watermark << ",shift={(" << watermark_x_shift << ",0cm)},anchor=north"; // << ",anchor=north west";
            //if(include_color_bar){node_position_ss << "axis cs:0.75,0.125,0.125";}  //more complicated than necessary
            //else {
            node_position_ss << "axis cs:1,0,0";
            //}
          } else {
            node_option_ss << "opacity=" << opacity_watermark << ",shift={(-" << watermark_x_shift << ",0cm)},anchor=north"; // << ",anchor=north west";
            node_position_ss << "axis cs:1,0,0";
          }
          node_content_ss << "\\includegraphics[scale=0.25]{" << aflow_logo_skinny_file << "}";
          tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
        }
        if(small_banner) //image_only) //note: this must also be added to pseudo_preliminary_axes_TEX_ss for proper padding (color bar), ONLY AFFECTS 3D
        { //CO20200106 - patching for auto-indenting
          if(dimension==2){
            node_option_ss << "anchor=south west";
            node_position_ss << "axis cs:0," << ymax;
            node_content_ss << general_image_font_size << " " << count_total_entries << " entries"; // doesn't work with externalizing images printCountTotalEntries
            tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);

            node_option_ss << "anchor=south east";
            node_position_ss << "axis cs:1," << ymax;
            node_content_ss << general_image_font_size << " \\today";
            tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
          } else {  //dimension==3
            //node_option_ss << "shift={(0in,5in)}";
            //node_position_ss << "axis cs:0,1,0";
            node_option_ss << "anchor=south,shift={(-" << watermark_x_shift << "," << sqrt(2.0*unary_distance_axis_3D*unary_distance_axis_3D) << "cm)}";
            node_position_ss << "axis cs:1,0,0";
            node_content_ss << general_image_font_size << " " << count_total_entries << " entries"; // doesn't work with externalizing images printCountTotalEntries
            tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);

            //node_option_ss << "shift={(0in,5in)}";
            //node_position_ss << "axis cs:0,0,1";
            node_option_ss << "anchor=south,shift={(" << watermark_x_shift << "," << sqrt(2.0*unary_distance_axis_3D*unary_distance_axis_3D) << "cm)}";
            node_position_ss << "axis cs:1,0,0";
            node_content_ss << general_image_font_size << " \\today";
            tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
          }
        }
        tikzpic_TEX_ss << "\\end{pgfonlayer}{background}" << endl;
        //tikzpic_TEX_ss << "\\end{scope}" << endl;
      }

      ////////////////////////////////////////////////////////////////////////////
      // END Plotting off hull points
      ////////////////////////////////////////////////////////////////////////////

      if(dimension == 2) {tikzpic_TEX_ss << "\\end{axis}" << endl;}
      else {tikzpic_TEX_ss << "\\end{ternaryaxis}" << endl;}
      if(LDEBUG) {cerr << soliloquy << " ending axis" << endl;}

      ////////////////////////////////////////////////////////////////////////////
      // END Axis
      ////////////////////////////////////////////////////////////////////////////

      //this section sucks to maintain, I fix with fancyheaders
      //I only keep here as reference to some potentially useful code
      //WARNING: the banner is EASILY the most complicated part of the code, as it's very
      //options dependent.
      //modify at your own peril 
      //if(0&&!no_banner) { //gone!
      //  if(dimension == 2) {
      //    ////////////////////////////////////////////////////////////////////////
      //    // START Logo on top left
      //    ////////////////////////////////////////////////////////////////////////
      //
      //    if(image_only){tikzpic_TEX_ss << "\\begin{scope}[remember picture,on background layer]" << endl;}
      //    else {tikzpic_TEX_ss << "\\begin{scope}[remember picture,overlay,on background layer]" << endl;}
      //    
      //    if(!small_banner) {
      //      // get node option
      //      if(print_aflow_logo_full) {
      //        if(image_only) {
      //          if(print_logo_2){node_option_ss << "shift={(2.75cm,0.75cm)}";}  //DONE
      //          else {node_option_ss << "shift={(2.75cm,0.5cm)}";} //DONE
      //        } else {node_option_ss << "shift={(2.25cm,0.5cm)}";} //DONE
      //      } else {
      //        if(image_only){node_option_ss << "shift={(4.0cm,0.75cm)}";} //DONE
      //        else {node_option_ss << "shift={(3.25cm,0.75cm)}";} //DONE
      //			}
      //      // get node position
      //      node_position_ss << "current bounding box.north west";
      //      // get node content
      //      if(print_aflow_logo_full) {
      //        if(external_links) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
      //        node_content_ss << "{\\includegraphics[scale=0.2]{" << aflow_logo_full_file << "}}";
      //      } else {
      //        node_content_ss << "\\shortstack[l]{";
      //        if(external_links) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
      //        node_content_ss << "{\\LARGE AFLOW V" << string(AFLOW_VERSION) << "}";
      //        node_content_ss << "\\\\";
      //        node_content_ss << "{\\large C. Oses and S. Curtarolo}";
      //        node_content_ss << "}";
      //      }
      //      // create node
      //      tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
      //    }
      //
      //    ////////////////////////////////////////////////////////////////////////
      //    // END Logo on top left
      //    ////////////////////////////////////////////////////////////////////////
      //
      //    ////////////////////////////////////////////////////////////////////////
      //    // START AFLOW.org on top right
      //    // nomad logo too
      //    ////////////////////////////////////////////////////////////////////////
      //
      //    // get node option
      //    if(image_only){
      //      if(!small_banner&&print_logo_2){
      //        if(print_aflow_logo_full){node_option_ss << "shift={(-2cm,-0.5cm)}";} //1
      //        else {node_option_ss << "shift={(-2cm,-0.75cm)}";}   //2
      //      } else {
      //        if(print_aflow_logo_full){
      //          if(!small_banner) {node_option_ss << "shift={(-2cm,-1.0cm)}";} //3
      //          else {node_option_ss << "shift={(-2cm,0.75cm)}";} //4
      //        } else {node_option_ss << "shift={(-2cm,-0.75cm)}";}  //5
      //      }
      //    } else {node_option_ss << "shift={(-1.25cm,0.75cm)}";}  //6
      //    // get node position
      //    node_position_ss << "current bounding box.north east";
      //    // get node content
      //    if(!small_banner&&print_logo_2){
      //      if(external_links) {node_content_ss << "\\href{" << NOMAD_WEB << "}";}
      //      node_content_ss << "{\\includegraphics[scale=0.1]{" << logo_file_2 << "}}";
      //    } else {
      //      node_content_ss << "\\large";
      //      node_content_ss << "{\\fontfamily{phv}\\selectfont";
      //      if(external_links) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
      //      node_content_ss << "{" << AFLOWLIB_MATERIALS_SERVER << "}";
      //      node_content_ss << "}";
      //    }
      //    // create node
      //    tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
      //
      //    ////////////////////////////////////////////////////////////////////////
      //    // END AFLOW.org on top right
      //    ////////////////////////////////////////////////////////////////////////
      //
      //    if(!small_banner) {
      //      //////////////////////////////////////////////////////////////////////
      //      // START Count on bottom left
      //      //////////////////////////////////////////////////////////////////////
      //
      //      // get node option
      //      if(image_only) {node_option_ss << "shift={(2.5cm,-1.0cm)}";}  //
      //      else {node_option_ss << "shift={(1.5cm,-0.75cm)}";}  //
      //      // get node position
      //      node_position_ss << "current bounding box.south west";
      //      // get node content
      //      node_content_ss << "count=" << count_entries;
      //      // create node
      //      tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
      //
      //      //////////////////////////////////////////////////////////////////////
      //      // END Count on bottom left
      //      //////////////////////////////////////////////////////////////////////
      //
      //      //////////////////////////////////////////////////////////////////////
      //      // START Date on bottom right
      //      //////////////////////////////////////////////////////////////////////
      //
      //      // get node option
      //      if(image_only) {node_option_ss << "shift={(-4.25cm,0.375cm)}";} //
      //      else {node_option_ss << "shift={(-2.5cm,-0.75cm)}";} //
      //      // get node position
      //      node_position_ss << "current bounding box.south east";
      //      // get node content
      //      node_content_ss << "\\today~\\currenttime";
      //      // create node
      //      tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
      //
      //      //////////////////////////////////////////////////////////////////////
      //      // END Date on bottom right
      //      //////////////////////////////////////////////////////////////////////
      //    }
      //    tikzpic_TEX_ss << "\\end{scope}" << endl;
      //  
      //  } else {  // dimension==3
      //
      //    ////////////////////////////////////////////////////////////////////////
      //    // START Full banner on left (logo,count,date)
      //    ////////////////////////////////////////////////////////////////////////
      //
      //    tikzpic_TEX_ss << "\\begin{scope}[remember picture,overlay,on background layer]" << endl;
      //    if(!small_banner) {
      //      // get node option
      //      node_content_ss << "\\shortstack[l]{";
      //      if(include_color_bar) {
      //        if(print_aflow_logo_full) {
      //          if(image_only){node_option_ss << "shift={(3.75cm,-2.5cm)}";}
      //          else {node_option_ss << "shift={(3.25cm,-1.0cm)}";}
      //        } else {
      //          if(image_only){node_option_ss << "shift={(4cm,-2.25cm)}";}
      //          else {node_option_ss << "shift={(3.25cm,-1.25cm)}";}
      //        }
      //      } else {
      //        if(print_aflow_logo_full) {
      //          if(image_only){node_option_ss << "shift={(3.25cm,-2.25cm)}";}
      //          else {node_option_ss << "shift={(2.25cm,-1.5cm)}";}
      //        } else {
      //          if(image_only){node_option_ss << "shift={(4cm,-2.25cm)}";}
      //          else {node_option_ss << "shift={(2cm,-1.5cm)}";}
      //        }
      //      }
      //      // get node position
      //      node_position_ss << "current bounding box.north west";
      //      // get node content
      //      if(print_aflow_logo_full) {
      //        if(external_links) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
      //        node_content_ss << "{\\includegraphics[scale=0.25]{" << aflow_logo_full_file << "}}";
      //      } else {
      //        if(external_links) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
      //        node_content_ss << "{\\LARGE AFLOW V" << string(AFLOW_VERSION) << "}";
      //        node_content_ss << "\\\\";
      //        node_content_ss << "{\\large C. Oses and S. Curtarolo}";
      //      }
      //      // get node content
      //      node_content_ss << "\\\\";
      //      node_content_ss << "\\\\";
      //      node_content_ss << "\\large count=" << count_entries;
      //      node_content_ss << "\\\\";
      //      node_content_ss << "\\large \\today~\\currenttime";
      //      node_content_ss << "}";
      //      // create node
      //      tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
      //    }
      //    ////////////////////////////////////////////////////////////////////////
      //    // END Full banner on top left (logo,count,date)
      //    ////////////////////////////////////////////////////////////////////////
      //
      //    ////////////////////////////////////////////////////////////////////////
      //    // START AFLOW.org on top right
      //    // nomad logo too
      //    ////////////////////////////////////////////////////////////////////////
      //
      //    // get node option
      //    if(!small_banner&&print_logo_2){
      //      if(include_color_bar) {
      //        if(image_only){node_option_ss << "shift={(-2cm,-0.75cm)}";}
      //        else {node_option_ss << "shift={(-1.5cm,0.0cm)}";} //
      //      } else {
      //        if(image_only) {node_option_ss << "shift={(-2.5cm,-1.25cm)}";}
      //        else {node_option_ss << "shift={(-0.25cm,-0.5cm)}";}
      //      }
      //    } else {
      //      if(include_color_bar) {
      //        if(image_only){node_option_ss << "shift={(-2cm,-0.75cm)}";}
      //        else {node_option_ss << "shift={(-1.5cm,0.0cm)}";} //
      //      } else {
      //        if(image_only) {node_option_ss << "shift={(-2.5cm,-1.25cm)}";}
      //        else {node_option_ss << "shift={(-0.25cm,-0.5cm)}";}
      //      }
      //    }
      //    // get node position
      //    node_position_ss << "current bounding box.north east";
      //    // get node content
      //    //node_content_ss << "\\shortstack[l]{";
      //    node_content_ss << "{\\large";
      //    node_content_ss << "{\\fontfamily{phv}\\selectfont";
      //    if(external_links) {node_content_ss << "\\href{" << AFLOW_WEB << "}";}
      //    node_content_ss << "{" << AFLOWLIB_MATERIALS_SERVER << "}";
      //    node_content_ss << "}";
      //    node_content_ss << "}";
      //    //node_content_ss << "}";
      //    // create node
      //    tikzpic_TEX_ss << nodeCreator(node_option_ss, node_position_ss, node_content_ss);
      //
      //    ////////////////////////////////////////////////////////////////////////
      //    // END AFLOW.org on top right
      //    ////////////////////////////////////////////////////////////////////////
      //
      //    tikzpic_TEX_ss << "\\end{scope}" << endl;
      //  }
      //}
      tikzpic_TEX_ss << "\\end{tikzpicture}" << endl;
      if(image_only) {tikzpic_TEX_ss << "\\endpgfgraphicnamed" << endl;}
      else {
        tikzpic_TEX_ss << "\\vspace*{\\fill}" << endl;
        tikzpic_TEX_ss << "}" << endl;
        tikzpic_TEX_ss << "\\end{landscape}" << endl;
        //if(!no_doc) {tikzpic_TEX_ss << "\\restoregeometry" << endl;}
      }
      tikzpic_TEX_ss << "\\restoregeometry" << endl;
    } else {
      // make sure to add this in
      doc_header_TEX_ss << "\\usepackage{graphicx}  \%HEADER" << endl;
      // contains begin{document}, which needs to go in sooner
      doc_header_TEX_ss << _doc_header_TEX_ss.str();
      _doc_header_TEX_ss.str("");
    }

    // BIG MERGE
    main_TEX_ss << doc_header_TEX_ss.str();
    doc_header_TEX_ss.str("");

    if(!doc_only && (dimension == 2 || dimension == 3)) {
      main_TEX_ss << _tikzpic_settings_TEX_ss.str();
      _tikzpic_settings_TEX_ss.str("");
      main_TEX_ss << pseudo_preliminary_axes_TEX_ss.str();
      pseudo_preliminary_axes_TEX_ss.str("");
      main_TEX_ss << tikzpic_settings_TEX_ss.str();
      tikzpic_settings_TEX_ss.str("");
      if(show_heat_map && num_horizontal_planes > 1) {
        main_TEX_ss << heat_map_TEX_ss.str();
        heat_map_TEX_ss.str("");
      }
      main_TEX_ss << tikzpic_TEX_ss.str();
      tikzpic_TEX_ss.str("");
    }

    //////////////////////////////////////////////////////////////////////////////
    // END Image on first page
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Report
    //////////////////////////////////////////////////////////////////////////////

    if(!no_doc && !image_only) {
      //if(!doc_only) {main_TEX_ss << "\\newpage" << endl;}
      ////////////////////////////////////////////////////////////////////////////
      // START Column header setup
      ////////////////////////////////////////////////////////////////////////////

      main_TEX_ss << "\\setlength{\\tabcolsep}{" << LATEX_TABCOLSEP_STD << "pt}" << endl;
      main_TEX_ss << "\\setlength\\arrayrulewidth{" << LATEX_ARRAYRULEWIDTH_STD << "pt}" << endl;

      main_TEX_ss << "\\newgeometry{" << MARGIN_REPORT << "}" << endl; //new geometry introduces \\newpage automatically
      main_TEX_ss << "\\updateSnapshotTableHeaderOne" << endl;

      main_TEX_ss << "\\thispagestyle{reportPage1}" << endl;
      main_TEX_ss << "\\pagestyle{reportPage2}" << endl;

      //citation
      main_TEX_ss << " \%CITATION" << endl;
      main_TEX_ss << "\\noindent " << CHULL_CITE << "" << " \%CITATION" << endl;
      main_TEX_ss << " \%CITATION" << endl;
      main_TEX_ss << "\\noindent\\begin{quote}" << " \%CITATION" << endl;
      main_TEX_ss << CHULL_AUTHORS << ", ";
      main_TEX_ss << "\\textit{" << CHULL_TITLE << "}, ";
      main_TEX_ss << CHULL_JOURNAL_LATEX << "." << " \%CITATION" << endl;
      main_TEX_ss << "\\end{quote}" << " \%CITATION" << endl;

      ////////////////////////////////////////////////////////////////////////////
      // END Column header setup
      ////////////////////////////////////////////////////////////////////////////

      uint counter;
      bool putColumnHeader = true;  // only put it for the first reported stoich
      vector<vector<uint> > equilibrium_phases;
      vector<vector<ChullPoint> > equilibrium_phases_CP;
      vector<ChullPoint> dummyDCP;
      vector<string> equilibrium_phases_vs, _equilibrium_phases_vs;
      vector<uint> decomposition_phases;
      //xvector<double> decomposition_coefficients;
      vector<string> decompositionCoefPhase_vs;  // combined coef * phase
      string misc;
      uint i_phase;
      bool added_nary_tag=false;  //for unary, binary, ternary, etc.
      bool add_vspace=true; //ONLY once, first TERNARY is too close to column headers
      string pdftable_font_sizes;
      vector<string> chpoint_properties;
      bool print_scriterion=true,print_np1=true;
      stringstream scriterion_data_ss,np1_data_ss;
      //uint num_cols_scriterion=2;
      //uint num_cols_np1=3;
      uint precision_tmp=0;
      double tmp_roundoff_tol;
      if(compounds_column_report){pdftable_font_sizes="\\fontsize{4}{6}\\selectfont";}
      else {pdftable_font_sizes="\\fontsize{5}{7}\\selectfont";}

      ////////////////////////////////////////////////////////////////////////////
      // START Stoichiometry group loop
      ////////////////////////////////////////////////////////////////////////////

      for(uint fl_size_i_nary=m_naries.size(),i_nary=(fl_size_i_nary-1);i_nary<fl_size_i_nary;i_nary--){ //go backwards!
        added_nary_tag=false;
        for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
          for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size();i<fl_size_i;i++){
            i_coord_group=m_naries[i_nary].m_alloys[i_alloy].m_coord_groups[i];
            counter = 0;

            //////////////////////////////////////////////////////////////////////////
            // START Stoichiometry group points loop
            //////////////////////////////////////////////////////////////////////////

            for(uint j=0,fl_size_j=m_coord_groups[i_coord_group].m_points.size();j<fl_size_j;j++) {
              ////////////////////////////////////////////////////////////////////////
              // START Entries filter
              ////////////////////////////////////////////////////////////////////////

              const ChullPoint& point = m_points[m_coord_groups[i_coord_group].m_points[j]];
              if(!point.m_has_entry) {continue;}
              const aflowlib::_aflowlib_entry& entry = point.m_entry;

              ////////////////////////////////////////////////////////////////////////
              // END Entries filter
              ////////////////////////////////////////////////////////////////////////

              if(!counter) {
                //////////////////////////////////////////////////////////////////////
                // START Concentration label
                //////////////////////////////////////////////////////////////////////

                if(stoich_header_report) {
                  for(int j=point.m_elements_present.lrows;j<=point.m_elements_present.urows;j++) {
                    if(point.m_elements_present[j]==1){
                      _report_data_ss << m_velements[j] << "$_{" << aurostd::utype2string(point.s_coords[j],COEF_PRECISION) << "}$";
                    }
                  }
                } else {_report_data_ss << prettyPrintCompound(entry,gcd_vrt,true,latex_ft);}

                //////////////////////////////////////////////////////////////////////
                // START Concentration label
                //////////////////////////////////////////////////////////////////////

                //////////////////////////////////////////////////////////////////////
                // START Gathering info about equilibrium phases / decomposition
                // reaction
                //////////////////////////////////////////////////////////////////////

                if(m_coord_groups[i_coord_group].m_is_on_hull) {

                  const vector<vector<uint> >& equilibrium_phases=m_coord_groups[i_coord_group].m_equilibrium_phases;
                  //nice fast way to toggle equivalent_phases on/off
                  //if(include_equilibrium_phases) {equilibrium_phases = m_coord_groups[i_coord_group].m_equilibrium_phases;}
                  //else {equilibrium_phases.clear();}

                  if(include_equilibrium_phases && !equilibrium_phases.empty()) {
                    for(uint k=0,fl_size_k=equilibrium_phases.size();k<fl_size_k;k++) {
                      for(uint l=0,fl_size_l=equilibrium_phases[k].size();l<fl_size_l;l++) {
                        i_phase=artificialMap(equilibrium_phases[k][l]);
                        const ChullPoint& eq_phase=m_points[i_phase];
                        if(!eq_phase.m_has_entry) {
                          // we need to adjust for missing unaries
                          // look for coords
                          output_name=aurostd::joinWDelimiter(alloyToElements(eq_phase),"");  //unary, so "" delimiter doesn't play a role
                        } else {
                          const aflowlib::_aflowlib_entry& equation_entry = eq_phase.m_entry;

                          output_name=prettyPrintCompound(equation_entry,gcd_vrt,true,latex_ft);
                          // do not hyperlink current point (pointless)
                          if(!aurostd::identical(point.getStoichiometricCoords(), eq_phase.getStoichiometricCoords(), ZERO_TOL)) {
                            if(internal_links_withinreport) {
                              misc_ss << "\\hyperref[" << input << "_" << equation_entry.auid << "]{";
                              misc_ss << output_name;
                              misc_ss << "}";
                              output_name = misc_ss.str();
                              misc_ss.str("");
                            }
                          }
                        }
                        _equilibrium_phases_vs.push_back(output_name);
                      }
                      if(m_coord_groups[i_coord_group].getDim() > 6) {equilibrium_phases_vs.push_back(aurostd::joinWDelimiter(_equilibrium_phases_vs, " -- "));}  // that way, we don't run off the line
                      else {equilibrium_phases_vs.push_back(aurostd::joinWDelimiter(_equilibrium_phases_vs, "--"));}
                      _equilibrium_phases_vs.clear();
                    }
                    equilibrium_phases_TEX_ss << aurostd::joinWDelimiter(equilibrium_phases_vs, ", ", " and ", ", and ");
                    equilibrium_phases_vs.clear();
                    equilibrium_phases_CP.clear();
                    //get header
                    //misc = prettyPrintCompound(entry,gcd_vrt,true,latex_ft);
                    equilibrium_phases_header_TEX_ss << "vertex of facets: (" << m_coord_groups[i_coord_group].getDim() << "-phase~equilibria)";  //patched ugly looking discontinuity
                    //equilibrium_phases_header_TEX_ss << " with " << misc;
                    //equilibrium_phases_header_TEX_ss << ":";
                  }
                } else {
                  // decomposition equation
                  const vector<uint>& decomposition_phases = m_coord_groups[i_coord_group].m_decomp_phases;
                  const xvector<double>& decomposition_coefficients = m_coord_groups[i_coord_group].m_decomp_coefs;
                  if(!decomposition_phases.empty() && scalar_product(decomposition_coefficients, decomposition_coefficients) >= ZERO_TOL) {
                    if(decomposition_phases.size() != (uint)decomposition_coefficients.rows-1) {
                      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Size of decomposition phases != size of decomposition coefficients for coordgroup["+aurostd::utype2string(i)+"]");
                    }
                    // write out decomposition equation
                    reaction_chem_eq_TEX_ss << prettyPrintCompound(entry,frac_vrt,true,latex_ft);
                    reaction_chem_eq_TEX_ss << " $\\to$ ";
                    for(uint k=0,fl_size_k=decomposition_phases.size();k<fl_size_k;k++) {
                      if(abs(decomposition_coefficients[decomposition_coefficients.lrows+k+1]) < ZERO_TOL) {continue;}
                      i_phase=artificialMap(decomposition_phases[k]);
                      const ChullPoint& dc_phase=m_points[i_phase];
                      if(!dc_phase.m_has_entry) {
                        // we need to adjust for missing unaries
                        // look for coords
                        output_name=aurostd::joinWDelimiter(alloyToElements(dc_phase),"");  //unary, so "" delimiter doesn't play a role
                      } else {
                        const aflowlib::_aflowlib_entry& equation_entry = dc_phase.m_entry;
                        output_name=prettyPrintCompound(equation_entry,frac_vrt,true,latex_ft);
                        if(internal_links_withinreport) {
                          misc_ss << "\\hyperref[" << input << "_" << equation_entry.auid << "]{";
                          misc_ss << output_name;
                          misc_ss << "}";
                          output_name = misc_ss.str();
                          misc_ss.str("");
                        }
                      }
                      misc_ss << aurostd::utype2string(abs(decomposition_coefficients[decomposition_coefficients.lrows+k+1]),COEF_PRECISION) << "~";
                      misc_ss << output_name;
                      decompositionCoefPhase_vs.push_back(misc_ss.str());
                      misc_ss.str("");
                    }
                    reaction_chem_eq_TEX_ss << aurostd::joinWDelimiter(decompositionCoefPhase_vs, " + ");
                    decompositionCoefPhase_vs.clear();
                  }
                }

                //////////////////////////////////////////////////////////////////////
                // END Gathering info about equilibrium phases / decomposition
                // reaction
                //////////////////////////////////////////////////////////////////////
              }

              ////////////////////////////////////////////////////////////////////////
              // START Row properties set up
              ////////////////////////////////////////////////////////////////////////

              //sg_tokens=entry.vsg;
              //if(!entry.sg.empty()) {
              //  aurostd::string2tokens(entry.sg, sg_tokens, ",");
              //  if(sg_tokens.size() != 3) {
              //    continue;
              //  }
              //}
              if(point.isGState()) {report_data_ss << aurostd::PaddedPOST("\\rowcolor{green!85!blue} ", 30);} //red!25
              else if(point.m_is_sym_equivalent_g_state) {report_data_ss << aurostd::PaddedPOST("\\rowcolor{orange!85} ", 30);}  // odd should be white
              else if(counter % 2) {report_data_ss << aurostd::PaddedPOST("\\rowcolor{white} ", 30);}  // odd should be white
              else {report_data_ss << aurostd::PaddedPOST("\\rowcolor{gray!25} ", 30);}
              chpoint_properties.clear();
              for(uint i=0,fl_size_i=vheaders.size();i<fl_size_i;i++){chpoint_properties.push_back(grabCHPointProperty(point,vheaders[i],latex_ft));}
              report_data_ss << aurostd::joinWDelimiter(chpoint_properties," & ");
              report_data_ss << " \\\\" << endl;
              counter++;
            }

            //////////////////////////////////////////////////////////////////////////
            // END Entry properties output
            //////////////////////////////////////////////////////////////////////////

            //////////////////////////////////////////////////////////////////////////
            // START Entry table creation
            //////////////////////////////////////////////////////////////////////////

            if(!report_data_ss.str().empty()) {
              if(putColumnHeader){
                main_TEX_ss << "\\noindent{" << pdftable_font_sizes << endl;
                main_TEX_ss << getSnapshotTableHeader(headers,false);
                main_TEX_ss << "}" << endl;
              }
              if(!added_nary_tag){
                if(add_vspace){
                  main_TEX_ss << endl;
                  main_TEX_ss << "\\vspace{5pt}" << endl;
                }
                main_TEX_ss << "\\centering{" << general_image_font_size << "{" << pflow::arity_string(i_nary+1,false,true) << "}}" << endl; //lowercase per SC's request
                main_TEX_ss << endl;
                main_TEX_ss << "\\vspace{-15pt}" << endl;
                added_nary_tag=true;
              }
              //main_TEX_ss << "{" << pdftable_font_sizes << endl;
              ////[CO20190226 - TABU IS BROKEN IN TeX Live 2019]main_TEX_ss << "\\begin{longtabu}{|" << aurostd::joinWDelimiter(valignments,"|") << "|}" << endl;
              //main_TEX_ss << "\\begin{longtable}{|" << aurostd::joinWDelimiter(valignments_entrytable_string,"|") << "|}" << endl;
              //putColumnHeader = false;
              //if(internal_links && isViablePoint(m_coord_groups[i_coord_group].m_ref_state)) {
              //  uint ref_state=m_coord_groups[i_coord_group].m_ref_state;
              //  main_TEX_ss << "\\multicolumn{" << vheaders.size() << "}{l}{\\phantomsection\\label{"+input + "_" + m_points[ref_state].m_entry.auid + "}} \\\\[0.1cm]" << endl;
              //} else {main_TEX_ss << "\\multicolumn{" << vheaders.size() << "}{l}{} \\\\[0.1cm]" << endl;}  //padding and spacing preservation
              print_scriterion=false;
              print_np1=false;
              scriterion_data_ss.str("");
              np1_data_ss.str("");
              if(m_coord_groups[i_coord_group].m_is_on_hull) {
                _report_data_ss << " " << "(ground-state)"; // if ground-state
                if(m_coord_groups[i_coord_group].m_stability_criterion<AUROSTD_NAN){
                  print_scriterion=true;
                  precision_tmp=0;
                  tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);
                  //scriterion_data_ss << "$\\mathit{\\Delta}_{\\mathrm{sc}}="; //this delta is okay, should be italicized
                  scriterion_data_ss << "$\\delta_{\\mathrm{sc}}="; //this delta is okay, should be italicized
                  scriterion_data_ss << aurostd::utype2string(convertUnits(m_coord_groups[i_coord_group].m_stability_criterion,(m_formation_energy_hull?_m_:_std_)),precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM);
                  scriterion_data_ss << "$~" << (m_formation_energy_hull?string("meV/atom"):string("K"));
                }
                if(m_coord_groups[i_coord_group].m_i_nary>=1 && m_coord_groups[i_coord_group].m_n_plus_1_enthalpy_gain<AUROSTD_NAN){ //print binaries anyway... //print only for ternaries and up, binaries is trivial formation enthalpy (save space)
                  print_np1=true;
                  precision_tmp=0;
                  tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);
                  //np1_data_ss << "$\\mathit{\\Delta}_{\\mathrm{sc}}="; //this delta is okay, should be italicized
                  if(0){
                    np1_data_ss << "$\\Delta H[N|\\{1,\\cdots,N-1\\}]="; //this delta is okay, should be italicized
                  }else{
                    np1_data_ss << "$\\Delta H[" << m_coord_groups[i_coord_group].m_i_nary+1 << "|"; //this delta is okay, should be italicized
                    if(m_coord_groups[i_coord_group].m_i_nary==0){np1_data_ss << "0";}  //not allowed anymore, but we can print the value
                    else if(m_coord_groups[i_coord_group].m_i_nary==1){np1_data_ss << "1";}
                    else if(m_coord_groups[i_coord_group].m_i_nary==2){np1_data_ss << "\\{1,2\\}";}
                    else if(m_coord_groups[i_coord_group].m_i_nary==3){np1_data_ss << "\\{1,2,3\\}";}
                    else if(m_coord_groups[i_coord_group].m_i_nary>3){np1_data_ss << "\\{1,\\cdots," << m_coord_groups[i_coord_group].m_i_nary << "\\}";}
                    np1_data_ss << "]=";
                  }
                  np1_data_ss << aurostd::utype2string(convertUnits(m_coord_groups[i_coord_group].m_n_plus_1_enthalpy_gain,(m_formation_energy_hull?_m_:_std_)),precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM);
                  np1_data_ss << "$~" << (m_formation_energy_hull?string("meV/atom"):string("K"));
                }
              } else {
                _report_data_ss << " " << "(unstable)"; // if above hull	  
              }
              // compound name
              main_TEX_ss << "\\begin{longtable}{" << aurostd::joinWDelimiter( (m_coord_groups[i_coord_group].m_is_on_hull?valignments_compoundname_thermopropstable_string:valignments_onecol_lefttable_string) ,"") << "}" << endl;
              if(internal_links && isViablePoint(m_coord_groups[i_coord_group].m_ref_state)) {
                uint ref_state=m_coord_groups[i_coord_group].m_ref_state;
                main_TEX_ss << "\\multicolumn{" << (m_coord_groups[i_coord_group].m_is_on_hull?n_cols_compoundname_thermoprops:n_cols_onecol_left) << "}{l}{\\phantomsection\\label{"+input + "_" + m_points[ref_state].m_entry.auid + "}} \\\\[0.1cm]" << endl;
              } else {main_TEX_ss << "\\multicolumn{" << (m_coord_groups[i_coord_group].m_is_on_hull?n_cols_compoundname_thermoprops:n_cols_onecol_left) << "}{l}{} \\\\[0.1cm]" << endl;}  //padding and spacing preservation
              //main_TEX_ss << "\\multicolumn{" << vheaders.size()-((print_scriterion?num_cols_scriterion:0)+(print_np1?num_cols_np1:0)) << "}{l}{";
              main_TEX_ss << "\\cellcolor{white}\\normalsize{" + _report_data_ss.str() << "}";
              //main_TEX_ss << "}";
              if(print_scriterion || print_np1){
                main_TEX_ss << " & ";
                //main_TEX_ss << "\\multicolumn{" << (print_scriterion?num_cols_scriterion:0)+(print_np1?num_cols_np1:0) << "}{r}{";
                main_TEX_ss << "\\cellcolor{white}\\normalsize{" + (print_scriterion?scriterion_data_ss.str():"") + (print_scriterion&&print_np1?", ":"") + (print_np1?np1_data_ss.str():"") << "}";
                //main_TEX_ss << "}";
              }
              main_TEX_ss << " \\\\[0.05cm]" << endl;  //0.1cm
              main_TEX_ss << "\\end{longtable}" << endl;
              main_TEX_ss << "\\vspace{-23pt}" << endl;

              //main table
              main_TEX_ss << "{" << pdftable_font_sizes << endl;
              //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]main_TEX_ss << "\\begin{longtabu}{|" << aurostd::joinWDelimiter(valignments,"|") << "|}" << endl;
              main_TEX_ss << "\\begin{longtable}{|" << aurostd::joinWDelimiter(valignments_entrytable_string,"|") << "|}" << endl;
              putColumnHeader = false;
              //if(internal_links && isViablePoint(m_coord_groups[i_coord_group].m_ref_state)) {
              //  uint ref_state=m_coord_groups[i_coord_group].m_ref_state;
              //  main_TEX_ss << "\\multicolumn{" << vheaders.size() << "}{l}{\\phantomsection\\label{"+input + "_" + m_points[ref_state].m_entry.auid + "}} \\\\[0.1cm]" << endl;
              //} else {main_TEX_ss << "\\multicolumn{" << vheaders.size() << "}{l}{} \\\\[0.1cm]" << endl;}  //padding and spacing preservation
              main_TEX_ss << "\\hline" << endl;
              main_TEX_ss << report_data_ss.str();
              main_TEX_ss << "\\hline" << endl;
              main_TEX_ss << "\\end{longtable}" << endl;
              //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]main_TEX_ss << "\\end{longtabu}" << endl;
              main_TEX_ss << "}" << endl;

              ////////////////////////////////////////////////////////////////////////
              // END Entry table creation
              ////////////////////////////////////////////////////////////////////////

              ////////////////////////////////////////////////////////////////////////
              // START Equilibrium phases / decomposition reaction table
              ////////////////////////////////////////////////////////////////////////

              if(!(equilibrium_phases_header_TEX_ss.str().empty() && equilibrium_phases_TEX_ss.str().empty() && reaction_chem_eq_TEX_ss.str().empty())) {
                main_TEX_ss << "\\vspace{-20pt}" << endl;
                //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]main_TEX_ss << "\\begin{longtabu}{X[1,l]X[3,r]}" << endl;
                main_TEX_ss << "\\begin{longtable}{" << aurostd::joinWDelimiter(valignments_reactiontable_string,"") << "}" << endl;
                if(m_coord_groups[i_coord_group].m_is_on_hull) {
                  if(include_equilibrium_phases && !(equilibrium_phases_header_TEX_ss.str().empty() && equilibrium_phases_TEX_ss.str().empty())) {
                    main_TEX_ss << equilibrium_phases_header_TEX_ss.str();
                    main_TEX_ss << " & ";
                    main_TEX_ss << equilibrium_phases_TEX_ss.str() << endl;
                  }
                } else {
                  if(!reaction_chem_eq_TEX_ss.str().empty()) {
                    main_TEX_ss << "decomposition reaction: & ";
                    main_TEX_ss << reaction_chem_eq_TEX_ss.str() << endl;
                  }
                }
                main_TEX_ss << "\\end{longtable}" << endl;
                //[CO20190226 - TABU IS BROKEN IN TeX Live 2019]main_TEX_ss << "\\end{longtabu}" << endl;
              }

              ////////////////////////////////////////////////////////////////////////
              // END Equilibrium phases / decomposition reaction table
              ////////////////////////////////////////////////////////////////////////

              equilibrium_phases_header_TEX_ss.str("");
              equilibrium_phases_TEX_ss.str("");
              reaction_chem_eq_TEX_ss.str("");
              if(!((i_alloy==m_naries[i_nary].m_alloys.size()-1)&&(i==m_naries[i_nary].m_alloys[i_alloy].m_coord_groups.size()-1))) {
                main_TEX_ss << "\\vspace{-20pt}" << endl;
              }
              //if(i!=m_coord_groups.size()-1) {main_TEX_ss << "\\vspace{-20pt}" << endl;}
            }
            scriterion_data_ss.str("");
            np1_data_ss.str("");
            _report_data_ss.str("");
            report_data_ss.str("");
            reaction_chem_eq_TEX_ss.str("");
          }

          ////////////////////////////////////////////////////////////////////////////
          // END Stoichiometry group points loop
          ////////////////////////////////////////////////////////////////////////////
        }
      }
      main_TEX_ss << "\\restoregeometry" << endl;
    }
    //////////////////////////////////////////////////////////////////////////////
    // END Stoichiometry group loop
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // END Report
    //////////////////////////////////////////////////////////////////////////////

    main_TEX_ss << "\\end{document}" << " \%FOOTER" << endl;

    //////////////////////////////////////////////////////////////////////////////
    // START Create tmp directory for compilation of .tex document
    //////////////////////////////////////////////////////////////////////////////

    string PWD = getPath();
    string path = getPath(m_cflags, *p_FileMESSAGE, *p_oss);
    string destination = path+main_PDF_file;
    main_output_file=main_PDF_file;
    if(m_cflags.flag("CHULL::PNG_IMAGE")&&!m_cflags.flag("CHULL::LATEX_DOC")){destination=path+main_PNG_file;main_output_file=main_PNG_file;}
    string LATEX_dir = aurostd::TmpDirectoryCreate("chullLATEX");
    chdir(LATEX_dir.c_str());
    aurostd::stringstream2file(main_TEX_ss, main_TEX_file);
    if(!aurostd::FileExist(main_TEX_file)) {
      chdir(PWD.c_str());
#ifndef _AFLOW_TEMP_PRESERVE_
      aurostd::RemoveDirectory(LATEX_dir);
#endif
      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Could not write "+main_TEX_file+" to "+LATEX_dir);
    }
    //watermark
    if(!doc_only){
      aurostd::base642bin(_AFLOW_LOGO_SKINNY_BASE64_, aflow_logo_skinny_file);
      if(!aurostd::FileExist(aflow_logo_skinny_file)) {
        chdir(PWD.c_str());
#ifndef _AFLOW_TEMP_PRESERVE_
        aurostd::RemoveDirectory(LATEX_dir);
#endif
        throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Could not write "+aflow_logo_skinny_file+" to "+LATEX_dir);
      }
    }
    if(print_aflow_logo_full) {
      aurostd::base642bin(_AFLOW_LOGO_FULL_BASE64_, aflow_logo_full_file);
      if(!aurostd::FileExist(aflow_logo_full_file)) {
        chdir(PWD.c_str());
#ifndef _AFLOW_TEMP_PRESERVE_
        aurostd::RemoveDirectory(LATEX_dir);
#endif
        throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Could not write "+aflow_logo_full_file+" to "+LATEX_dir);
      }
    }
    if(print_logo_2) {
      aurostd::base642bin(_NOMAD_LOGO_BASE64_, logo_file_2);
      if(!aurostd::FileExist(logo_file_2)) {
        chdir(PWD.c_str());
#ifndef _AFLOW_TEMP_PRESERVE_
        aurostd::RemoveDirectory(LATEX_dir);
#endif
        throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Could not write "+logo_file_2+" to "+LATEX_dir);
      }
    }
    command.str("");
    stringstream clean_command;
    uint num_compile;
    command << XHOST.command("pdflatex") << " ";
    clean_command << XHOST.command("pdflatex") << " ";
    if(!show_latex_output) {command << "-interaction=nonstopmode -halt-on-error ";}  //-interaction=batchmode
    if(image_only) {
      command << "--jobname=" << main_file << " " << main_TEX_file << " ";
      clean_command << "--jobname=" << main_file << " " << main_TEX_file << " ";
      num_compile = 1;
    } else {
      command << main_TEX_file << " ";
      clean_command << main_TEX_file << " ";

      //if(doc_only && no internal_links) { //[CO20200106 - close bracket for indenting]}
      if(!internal_links) {num_compile = 1;}
      else {num_compile = 2;}
    }
    if(!show_latex_output) {command << "1>/dev/null ";}
    message << "Attempting to compile " << main_TEX_file;  //CO20180220 //the .tex file";
    pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);

    if(show_latex_output) {
      if(latex_interactive_mode) {for (uint i = 0; i < num_compile; i++) {aurostd::execute(command.str());}} // will not save output, allows you to interact with LaTEX
      else {for (uint i = 0; i < num_compile; i++) {*p_oss << aurostd::execute2string(command.str()) << endl;}} // saves output
    } else {for (uint i = 0; i < num_compile; i++) {aurostd::execute(command.str());}} // no output to save
    if(!aurostd::FileExist(main_PDF_file)) {
      message << main_PDF_file << " was not created successfully, likely a LaTeX issue";
      pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_ERROR_);
      files_2_move.clear(); //only move these files
      files_2_move.push_back(main_TEX_file);
      if(!doc_only){files_2_move.push_back(aflow_logo_skinny_file);}
      if(print_aflow_logo_full){files_2_move.push_back(aflow_logo_full_file);}
      if(print_logo_2){files_2_move.push_back(logo_file_2);}

      message << "Moving " << aurostd::joinWDelimiter(files_2_move,", "," and ",", and ") << " to " << path; //CO20180220 - current directory";
      pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);
      message << "Try running \"" << aurostd::RemoveWhiteSpacesFromTheBack(clean_command.str()) << "\"";
      pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);

      aurostd::file2directory(files_2_move, path);
      chdir(PWD.c_str());
#ifndef _AFLOW_TEMP_PRESERVE_
      aurostd::RemoveDirectory(LATEX_dir);
#endif
      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Issues compiling .tex file");
    }
    if(m_cflags.flag("CHULL::PNG_IMAGE")){
      command.str("");clean_command.str("");
      uint default_resolution=DEFAULT_CHULL_PNG_RESOLUTION,resolution=default_resolution;
      string resolution_input=m_cflags.getattachedscheme("CHULL::PNG_RESOLUTION");
      if(!resolution_input.empty()){
        if(!aurostd::isfloat(resolution_input)){
          message << "PNG_RESOLUTION input is not a number, defaulting to " << default_resolution;
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
        } else {resolution=aurostd::string2utype<int>(resolution_input);}
        if(resolution==0){
          message << "PNG_RESOLUTION input is 0, defaulting to " << default_resolution;
          pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_WARNING_);
          resolution=default_resolution;
        }
      }
      message << "Attempting to convert " << main_PDF_file << " to " << main_PNG_file;  //CO20180220 //the .tex file";
      pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);
      command << XHOST.command("convert") << " -density " << resolution << " " << main_PDF_file << " " << main_PNG_file;
      clean_command << XHOST.command("convert") << " -density " << resolution << " " << main_PDF_file << " " << main_PNG_file;
      command << " 1>/dev/null 2>&1";
      if(LDEBUG) {cerr << soliloquy << " executing: " << clean_command.str() << endl;}
      string convert_output=aurostd::execute2string(command.str());
      if(!aurostd::RemoveWhiteSpaces(convert_output).empty()){
        message << main_PNG_file << " was not created successfully, likely a convert issue";
        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_ERROR_);
        files_2_move.clear(); //only move these files
        files_2_move.push_back(main_PDF_file);

        message << "Moving " << aurostd::joinWDelimiter(files_2_move,", "," and ",", and ") << " to " << path; //CO20180220 - current directory";
        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);
        message << "Try running \"" << aurostd::RemoveWhiteSpacesFromTheBack(clean_command.str()) << "\"";
        pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);

        aurostd::file2directory(files_2_move, path);
        chdir(PWD.c_str());
#ifndef _AFLOW_TEMP_PRESERVE_
        aurostd::RemoveDirectory(LATEX_dir);
#endif
        throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Issues converting PDF to PNG file");
      }
    }
    if(m_cflags.flag("CHULL::LATEX_DOC")){files_2_move.push_back(main_PDF_file);}
    if(m_cflags.flag("CHULL::PNG_IMAGE")){files_2_move.push_back(main_PNG_file);}
    if(keep_tex) {
      files_2_move.push_back(main_TEX_file);
      if(!doc_only){files_2_move.push_back(aflow_logo_skinny_file);}
      if(print_aflow_logo_full){files_2_move.push_back(aflow_logo_full_file);} //files_2_move.push_back(aflow_logo_skinny_file);
      if(print_logo_2){files_2_move.push_back(logo_file_2);}
      message << "Moving " << aurostd::joinWDelimiter(files_2_move,", "," and ",", and ") << " to " << path; //CO20180220 - current directory";
      pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);
    }
    if(!aurostd::file2directory(files_2_move, path)) {
      chdir(PWD.c_str());
#ifndef _AFLOW_TEMP_PRESERVE_
      aurostd::RemoveDirectory(LATEX_dir);
#endif
      throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unable to move files out of temporary compilation directory");
    }
    chdir(PWD.c_str());
#ifndef _AFLOW_TEMP_PRESERVE_
    aurostd::RemoveDirectory(LATEX_dir);
#endif
    if(!aurostd::FileExist(destination)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unable to write "+main_output_file+" to "+path);}
    message << main_output_file << " was created successfully, see destination=" << path;
    pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_COMPLETE_);

    //////////////////////////////////////////////////////////////////////////////
    // END Create tmp directory for compilation of .tex document
    //////////////////////////////////////////////////////////////////////////////
  }

  string ConvexHull::getPlainTextHeader() const {
    stringstream main_text_ss;main_text_ss.str("");
    stringstream misc_ss;misc_ss.str("");
    const uint width_page_txt = 130;   // helps with formatting of output
    //misc_ss << aurostd::joinWDelimiter(m_velements,"") << " summary"; //Materials Snapshot
    //main_text_ss << aurostd::PaddedCENTER(misc_ss.str(), width_page_txt+2); misc_ss.str("");  //CENTER is off from PRE/POST by 2 spaces (see where i starts)
    //main_text_ss << endl;
    if(0){
      misc_ss << aurostd::joinWDelimiter(m_velements,"-") << " summary"; // (V" << string(AFLOW_VERSION) << ")";
      main_text_ss << aurostd::PaddedPOST(misc_ss.str(), width_page_txt / 2); misc_ss.str("");
      misc_ss << AFLOW_WEB;
      main_text_ss << aurostd::PaddedPRE(misc_ss.str(), width_page_txt / 2); misc_ss.str("");
      main_text_ss << endl;

      //misc_ss << "count=" << getEntriesCount(m_half_hull) << "/" << getEntriesCount(false);
      misc_ss << "count_entries_total=" << getEntriesCount(false);
      main_text_ss << aurostd::PaddedPOST(misc_ss.str(), width_page_txt / 2); misc_ss.str("");
      main_text_ss << aurostd::PaddedPRE(aurostd::get_datetime_formatted("-",false), width_page_txt / 2); //CO20180819 - we don't need minute/second precision, date is fine
      main_text_ss << endl;
    }

    main_text_ss << aurostd::joinWDelimiter(m_velements,"-") << " summary" << " (" << AFLOWLIB_MATERIALS_SERVER << ")" << endl;
    main_text_ss << aurostd::get_datetime_formatted("-",false) << endl;

    //cite as
    main_text_ss << endl;
    main_text_ss << CHULL_CITE << endl;
    main_text_ss << "    " << CHULL_AUTHORS << "," << endl;
    main_text_ss << "    " << CHULL_TITLE << "," << endl;
    main_text_ss << "    " << CHULL_JOURNAL_TXT << "." << endl;
    main_text_ss << endl;

    main_text_ss << endl;
    main_text_ss << "HULL DATA" << endl;
    //gstate_counts
    if(m_has_stoich_coords){
      uint gstate_count=0,total_gstate_count=0;
      for(uint i_nary=0,fl_size_i_nary=m_naries.size();i_nary<fl_size_i_nary;i_nary++){
        gstate_count=getGStateCount(i_nary);total_gstate_count+=gstate_count;
        main_text_ss << "Count ground-state " << pflow::arity_string(i_nary+1,false,true) << " = " << gstate_count << endl;
      }
      main_text_ss << "Count ground-state total = " << total_gstate_count;
      main_text_ss << endl;
    }
    main_text_ss << "Count entries total = " << getEntriesCount(false) << endl;
    main_text_ss << endl;

    return main_text_ss.str();
  }

  string ConvexHull::getJSONHeader() const {
    vector<string> vout;
    stringstream misc_ss;misc_ss.str("");

    misc_ss << "\"alloy\":\"" << aurostd::joinWDelimiter(m_velements,"") << "\"";
    vout.push_back(misc_ss.str()); misc_ss.str("");

    misc_ss << "\"aflow_version\":\"aflow" << string(AFLOW_VERSION) << "\"";
    vout.push_back(misc_ss.str()); misc_ss.str("");

    misc_ss << "\"aflow_website\":\"" << AFLOW_WEB << "\"";
    vout.push_back(misc_ss.str()); misc_ss.str("");

    misc_ss << "\"date\":\"" << aurostd::get_datetime_formatted("-",false) << "\""; //CO20180819 - we don't need minute/second precision, date is fine //previously datetime
    vout.push_back(misc_ss.str()); misc_ss.str("");

    //misc_ss << "\"count_hull\":\"" << getEntriesCount(m_half_hull) << "\"";
    //vout.push_back(misc_ss.str()); misc_ss.str("");
    //misc_ss << "\"count_total\":\"" << getEntriesCount(false) << "\"";

    if(m_has_stoich_coords){
      uint gstate_count=0,total_gstate_count=0;
      for(uint i_nary=0,fl_size_i_nary=m_naries.size();i_nary<fl_size_i_nary;i_nary++){
        gstate_count=getGStateCount(i_nary);total_gstate_count+=gstate_count;
        misc_ss << "\"count_gstate_" << pflow::arity_string(i_nary+1,false,false) << "\":" << gstate_count;
        vout.push_back(misc_ss.str()); misc_ss.str("");
      }
      misc_ss << "\"count_gstate_total\":" << total_gstate_count;
      vout.push_back(misc_ss.str()); misc_ss.str("");
    }

    misc_ss << "\"count_entries_total\":" << getEntriesCount(false);
    vout.push_back(misc_ss.str()); misc_ss.str("");

    misc_ss << "\"publication\":\"";
    misc_ss << CHULL_AUTHORS << ", ";
    misc_ss << CHULL_TITLE << ", ";
    misc_ss << CHULL_JOURNAL_TXT;
    misc_ss << "\"";
    vout.push_back(misc_ss.str()); misc_ss.str("");

    return aurostd::wrapString(aurostd::joinWDelimiter(vout,","),"{","}");
  }

  string ConvexHull::grabCHPointProperty(const ChullPoint& point,const string& property,filetype ftype) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::grabCHPointProperty():";
    if(LDEBUG) {cerr << soliloquy << " start" << endl;}
    uint precision=COEF_PRECISION,precision_tmp=COEF_PRECISION;
    double tmp_roundoff_tol=5.0*pow(10,-((int)precision)-1);
    double d_tmp=0.0;
    string value="";
    string equilibrium_phases_delimiter="-";
    string string_wrapper="";
    string list_prefix="";
    string list_suffix="";
    string null_value="-";
    uint padding=30;  //latex only
    if(ftype==json_ft){
      equilibrium_phases_delimiter=",";
      string_wrapper="\"";
      list_prefix="[";
      list_suffix="]";
      null_value="null";
    }
    string string_wrapper_math_mode="$";  //latex only
    bool compounds_column_report=false;
    bool external_links=false;
    if(ftype==latex_ft){
      null_value="N/A";
      compounds_column_report=DEFAULT_CHULL_LATEX_COMPOUNDS_COLUMN; //only grab if necessary, not an inexpensive string search
      external_links=addExternalHyperlinks(); //only grab if necessary, not an inexpensive string search
    }
    if(LDEBUG) {cerr << soliloquy << " starting property=" << property << endl;}
    bool latex_property=false;
    bool math_mode=false;
    //[OBSOLETE]bool reduced=false;
    if(property=="compound"||property=="compound_latex"||property=="reduced_compound"||property=="reduced_compound_latex"||property=="fractional_compound"||property=="fractional_compound_latex"){
      math_mode=false;  //do not wrap these, they are automatically wrapped inside prettyPrint
      latex_property=(property=="compound_latex"||property=="reduced_compound_latex"||property=="fractional_compound_latex");
      vector_reduction_type vred=no_vrt;
      if(property=="reduced_compound"||property=="reduced_compound_latex"){vred=gcd_vrt;}
      if(property=="fractional_compound"||property=="fractional_compound_latex"){vred=frac_vrt;}
      //[OBSOLETE]reduced=(property=="reduced_compound"||property=="reduced_compound_latex");
      value=prettyPrintCompound(point,vred,(ftype==latex_ft||latex_property||vred==gcd_vrt||vred==frac_vrt),(latex_property?latex_ft:ftype));
      if((ftype==latex_ft||latex_property)&&math_mode&&!value.empty()){value=aurostd::wrapString(value,string_wrapper_math_mode);}
      value=aurostd::wrapString(value,string_wrapper);
    }
    else if(property=="prototype"||property=="prototype_latex"){
      latex_property=(property=="prototype_latex");
      if(ftype==latex_ft||latex_property){value=prettyPrintPrototype(point,ftype==json_ft,false);}  //JSON needs double backslash
      else {value=point.m_entry.prototype;}
      value=aurostd::wrapString(value,string_wrapper);
      padding=100;  //latex only
    }
    else if(property=="auid"){
      if(ftype==latex_ft){value="\\texttt{"+aurostd::wrapString(point.m_entry.auid,string_wrapper)+"}";}
      else {value=aurostd::wrapString(point.m_entry.auid,string_wrapper);}
    }
    else if(property=="aurl"){value=aurostd::wrapString(point.m_entry.aurl,string_wrapper);}
    else if(property=="url_entry_page"){value=aurostd::wrapString(ENTRY_PAGE_URL_PREFIX+point.m_entry.auid,string_wrapper);}
    else if(property=="space_group_orig"||property=="space_group_orig_latex"){
      math_mode=true;
      latex_property=(property=="space_group_orig_latex");
      string sg=point.getVSG().front();
      if(ftype==latex_ft||latex_property){sg=aurostd::fixStringLatex(sg,ftype==json_ft,true);}
      value=sg;
      if((ftype==latex_ft||latex_property)&&math_mode&&!value.empty()){value=aurostd::wrapString(value,string_wrapper_math_mode);}
      value=aurostd::wrapString(value,string_wrapper);
    }
    else if(property=="space_group_relax"||property=="space_group_relax_latex"){
      math_mode=true;
      latex_property=(property=="space_group_relax_latex");
      string sg=point.getVSG().back();
      if(ftype==latex_ft||latex_property){sg=aurostd::fixStringLatex(sg,ftype==json_ft,true);}
      value=sg;
      if((ftype==latex_ft||latex_property)&&math_mode&&!value.empty()){value=aurostd::wrapString(value,string_wrapper_math_mode);}
      value=aurostd::wrapString(value,string_wrapper);
    }
    else if(property=="spin_atom"){
      d_tmp=point.m_entry.spin_atom;
      if(d_tmp!=AUROSTD_NAN){
        precision_tmp=precision;
        if(ftype==latex_ft){precision_tmp=2;tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);}
        value=aurostd::utype2string(d_tmp,precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM);
      }
    }
    else if(property=="enthalpy_formation_atom"){
      precision_tmp=precision;
      if(ftype==latex_ft){precision_tmp=0;tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);}
      value=aurostd::utype2string(H_f_atom(point,_m_),precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM);
    }
    else if(property=="entropic_temperature"){
      precision_tmp=precision;
      if(ftype==latex_ft){precision_tmp=0;tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);}
      value=aurostd::utype2string(point.m_entry.entropic_temperature,precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM);
    }
    else if(property=="ground_state"){value=(point.isGState()?"true":"false");}
    else if(property=="equivalent_structures_auid"){
      if(!(ftype==txt_ft || ftype==json_ft)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No latex rule defined for "+property);}
      if(point.isGState()){
        //need to grab from coord_group
        uint i_coord_group=AUROSTD_MAX_UINT;
        if(!getCoordGroupIndex(point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
        if(m_coord_groups[i_coord_group].m_is_on_hull){
          vector<string> auids;
          uint i_point=AUROSTD_MAX_UINT;
          const vector<uint>& equivalent_g_states=m_coord_groups[i_coord_group].m_equivalent_g_states;
          if(equivalent_g_states.size()){
            for(uint i=0,fl_size_i=equivalent_g_states.size();i<fl_size_i;i++){
              i_point=artificialMap(equivalent_g_states[i]);
              if(m_points[i_point].m_has_entry){
                auids.push_back(aurostd::wrapString(m_points[i_point].m_entry.auid,string_wrapper));
              } else {auids.push_back(null_value);}
            }
            value=aurostd::wrapString(aurostd::joinWDelimiter(auids,","),list_prefix,list_suffix);
          }
        }
      }
    }
    else if(property=="icsd_ground_state"){
      bool icsd_g_state=false;
      if(point.isGState()){
        //need to grab from coord_group
        uint i_coord_group=AUROSTD_MAX_UINT;
        if(!getCoordGroupIndex(point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
        if(m_coord_groups[i_coord_group].m_is_on_hull){
          icsd_g_state=m_coord_groups[i_coord_group].m_icsd_g_state;
        }
      }
      value=(icsd_g_state?"true":"false");
    }
    else if(property=="icsd_canonical_auid"){
      if(point.isGState()){
        //need to grab from coord_group
        uint i_coord_group=AUROSTD_MAX_UINT;
        if(!getCoordGroupIndex(point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
        if(m_coord_groups[i_coord_group].m_is_on_hull){
          if(m_coord_groups[i_coord_group].m_icsd_g_state){
            uint i_point=m_coord_groups[i_coord_group].m_i_canonical_icsd;
            if(i_point>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within points");}
            if(m_points[i_point].m_has_entry){value=aurostd::wrapString(m_points[i_point].m_entry.auid,string_wrapper);}
          }
        }
      }
    }
    else if(property=="phases_equilibrium_compound"){
      if(!(ftype==txt_ft || ftype==json_ft)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No latex rule defined for "+property);}
      if(point.isGState()&&!point.isUnary()){ //unaries are always gstates, but do NOT have any mixture context
        //need to grab from coord_group
        uint i_coord_group=AUROSTD_MAX_UINT;
        if(!getCoordGroupIndex(point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
        if(!m_cflags.flag("CHULL::CALCULATE_HIGHEST_DIMENSION_ONLY")){
          if(m_coord_groups[i_coord_group].m_equilibrium_phases.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Equilibrium phases not set");}
        }
        vector<string> compounds,_compounds;
        uint i_point=AUROSTD_MAX_UINT;
        const vector<vector<uint> >& equilibrium_phases=m_coord_groups[i_coord_group].m_equilibrium_phases;
        if(equilibrium_phases.size()){
          for(uint i=0,fl_size_i=equilibrium_phases.size();i<fl_size_i;i++){
            if(equilibrium_phases[i].size()==0){compounds.push_back(null_value);continue;}
            _compounds.clear();
            for(uint j=0,fl_size_j=equilibrium_phases[i].size();j<fl_size_j;j++){
              i_point=artificialMap(equilibrium_phases[i][j]);
              if(m_points[i_point].m_has_entry){
                _compounds.push_back(aurostd::wrapString(m_points[i_point].m_entry.compound,string_wrapper));
              } else {_compounds.push_back(null_value);}
            }
            compounds.push_back(aurostd::wrapString(aurostd::joinWDelimiter(_compounds,equilibrium_phases_delimiter),list_prefix,list_suffix));
          }
          value=aurostd::wrapString(aurostd::joinWDelimiter(compounds,","),list_prefix,list_suffix);
        }
      }
    }
    else if(property=="phases_equilibrium_auid"){
      if(!(ftype==txt_ft || ftype==json_ft)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No latex rule defined for "+property);}
      if(point.isGState()&&!point.isUnary()){
        //need to grab from coord_group
        uint i_coord_group=AUROSTD_MAX_UINT;
        if(!getCoordGroupIndex(point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
        if(!m_cflags.flag("CHULL::CALCULATE_HIGHEST_DIMENSION_ONLY")){
          if(m_coord_groups[i_coord_group].m_equilibrium_phases.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Equilibrium phases not set");}
        }
        vector<string> auids,_auids;
        uint i_point=AUROSTD_MAX_UINT;
        const vector<vector<uint> >& equilibrium_phases=m_coord_groups[i_coord_group].m_equilibrium_phases;
        if(equilibrium_phases.size()){
          for(uint i=0,fl_size_i=equilibrium_phases.size();i<fl_size_i;i++){
            if(equilibrium_phases[i].size()==0){auids.push_back(null_value);continue;}
            _auids.clear();
            for(uint j=0,fl_size_j=equilibrium_phases[i].size();j<fl_size_j;j++){
              i_point=artificialMap(equilibrium_phases[i][j]);
              if(m_points[i_point].m_has_entry){
                _auids.push_back(aurostd::wrapString(m_points[i_point].m_entry.auid,string_wrapper));
              } else {_auids.push_back(null_value);}
            }
            auids.push_back(aurostd::wrapString(aurostd::joinWDelimiter(_auids,equilibrium_phases_delimiter),list_prefix,list_suffix));
          }
          value=aurostd::wrapString(aurostd::joinWDelimiter(auids,","),list_prefix,list_suffix);
        }
      }
    }
    else if(property=="phases_decomposition_compound"){
      if(!(ftype==txt_ft || ftype==json_ft)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No latex rule defined for "+property);}
      if(GET_DECOMPOSITION_POLYMORPHS||!point.isGState()){
        //need to grab from coord_group
        uint i_coord_group=AUROSTD_MAX_UINT;
        if(!getCoordGroupIndex(point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
        if(GET_DECOMPOSITION_POLYMORPHS||!m_coord_groups[i_coord_group].m_is_on_hull){
          if(m_coord_groups[i_coord_group].m_decomp_phases.size()){
            vector<string> compounds;
            uint i_point=AUROSTD_MAX_UINT;
            for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_decomp_phases.size();i<fl_size_i;i++){
              i_point=artificialMap(m_coord_groups[i_coord_group].m_decomp_phases[i]);
              const xvector<double>& decomposition_coefficients=m_coord_groups[i_coord_group].m_decomp_coefs;
              //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]const xvector<double>& decomposition_coefficients=point.m_decomp_coefs;
              if((decomposition_coefficients.lrows+i+1<=(uint)decomposition_coefficients.urows)&&(nonZeroWithinTol(decomposition_coefficients[decomposition_coefficients.lrows+i+1]))){
                if(m_points[i_point].m_has_entry){
                  compounds.push_back(aurostd::wrapString(m_points[i_point].m_entry.compound,string_wrapper));
                } else {compounds.push_back(null_value);} //already did artificialMap()
              } //else {compounds.push_back(null_value);}
            }
            value=aurostd::wrapString(aurostd::joinWDelimiter(compounds,","),list_prefix,list_suffix);
          }
        }
      }
    }
    else if(property=="phases_decomposition_auid"){
      if(!(ftype==txt_ft || ftype==json_ft)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No latex rule defined for "+property);}
      if(GET_DECOMPOSITION_POLYMORPHS||!point.isGState()){
        //need to grab from coord_group
        uint i_coord_group=AUROSTD_MAX_UINT;
        if(!getCoordGroupIndex(point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
        if(GET_DECOMPOSITION_POLYMORPHS||!m_coord_groups[i_coord_group].m_is_on_hull){
          if(m_coord_groups[i_coord_group].m_decomp_phases.size()){
            vector<string> auids;
            uint i_point=AUROSTD_MAX_UINT;
            for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_decomp_phases.size();i<fl_size_i;i++){
              i_point=artificialMap(m_coord_groups[i_coord_group].m_decomp_phases[i]);
              const xvector<double>& decomposition_coefficients=m_coord_groups[i_coord_group].m_decomp_coefs;
              //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]const xvector<double>& decomposition_coefficients=point.m_decomp_coefs;
              if((decomposition_coefficients.lrows+i+1<=(uint)decomposition_coefficients.urows)&&(nonZeroWithinTol(decomposition_coefficients[decomposition_coefficients.lrows+i+1]))){
                if(m_points[i_point].m_has_entry){
                  auids.push_back(aurostd::wrapString(m_points[i_point].m_entry.auid,string_wrapper));
                } else {auids.push_back(null_value);} //already did artificialMap()
              } //else {auids.push_back(null_value);}
            }
            value=aurostd::wrapString(aurostd::joinWDelimiter(auids,","),list_prefix,list_suffix);
          }
        }
      }
    }
    else if(property=="phases_decomposition_coefficient"){
      if(!(ftype==txt_ft || ftype==json_ft)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No latex rule defined for "+property);}
      if(GET_DECOMPOSITION_POLYMORPHS||!point.isGState()){
        //need to grab from coord_group
        uint i_coord_group=AUROSTD_MAX_UINT;
        if(!getCoordGroupIndex(point,i_coord_group)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup index not set");}
        if(GET_DECOMPOSITION_POLYMORPHS||!m_coord_groups[i_coord_group].m_is_on_hull){
          if(m_coord_groups[i_coord_group].m_decomp_phases.size()){
            vector<double> nonzero_coefs;
            //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]for(int i=point.m_decomp_coefs.lrows;i<=point.m_decomp_coefs.urows;i++){
            //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]  if(nonZeroWithinTol(point.m_decomp_coefs[i])){nonzero_coefs.push_back(point.m_decomp_coefs[i]);}
            //[OBSOLETE - reduce by frac_vrt always! so use coord_group values]}
            for(int i=m_coord_groups[i_coord_group].m_decomp_coefs.lrows;i<=m_coord_groups[i_coord_group].m_decomp_coefs.urows;i++){
              if(nonZeroWithinTol(m_coord_groups[i_coord_group].m_decomp_coefs[i])){nonzero_coefs.push_back(m_coord_groups[i_coord_group].m_decomp_coefs[i]);}
            }
            precision_tmp=precision;
            tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);
            value=aurostd::wrapString(aurostd::joinWDelimiter(aurostd::vecDouble2vecString(nonzero_coefs,precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM),","),list_prefix,list_suffix);
          }
        }
      }
    }
    else if(property=="nspecies"){
      uint i_nary=point.m_i_nary;
      if(i_nary!=AUROSTD_MAX_UINT){i_nary+=1;}  //m_i_nary is just index, increment by count to get nspecies
      else {i_nary=0;}  //set to something reasonable
      if(i_nary==0){    //potential other ways of defining nspecies
        if(point.m_has_entry){i_nary=point.m_entry.nspecies;}
      }
      value=aurostd::utype2string(i_nary);  //no precision needed here, simple uint
    }
    else if(property=="enthalpy_formation_atom_difference"){
      d_tmp=point.getDist2Hull(_m_);
      if(d_tmp!=AUROSTD_MAX_DOUBLE){
        precision_tmp=precision;
        if(ftype==latex_ft){precision_tmp=0;tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);}
        value=aurostd::utype2string(d_tmp,precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM);
      }
    }
    else if(property=="entropic_temperature_difference"){
      d_tmp=point.getDist2Hull(_std_);
      if(d_tmp!=AUROSTD_MAX_DOUBLE){
        precision_tmp=precision;
        if(ftype==latex_ft){precision_tmp=0;tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);}
        value=aurostd::utype2string(d_tmp,precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM); //will never be _m_ units
      }
    }
    else if(property=="stability_criterion"){
      if(m_cflags.flag("CHULL::SKIP_STABILITY_CRITERION_ANALYSIS")||point.getStabilityCriterion(_m_)>=AUROSTD_NAN){value=null_value;}
      else {
        if(point.isGState()){
          d_tmp=point.getStabilityCriterion(_m_);
          if(d_tmp!=AUROSTD_MAX_DOUBLE){
            precision_tmp=precision;
            if(ftype==latex_ft){precision_tmp=0;tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);}
            value=aurostd::utype2string(d_tmp,precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM); //can be _m_ units, but smart enough to switch if T_S
          }
        }
      }
    }
    else if(property=="relative_stability_criterion"){
      if(m_cflags.flag("CHULL::SKIP_STABILITY_CRITERION_ANALYSIS")||point.getRelativeStabilityCriterion()>=AUROSTD_NAN){value=null_value;}
      else {
        if(point.isGState()){
          d_tmp=point.getRelativeStabilityCriterion();
          if(d_tmp!=AUROSTD_MAX_DOUBLE){
            precision_tmp=precision;
            if(ftype==latex_ft){precision_tmp=0;tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);}
            value=aurostd::utype2string(d_tmp,precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM); //delivers as decimal, show as percentage  //CO20180409 - not showing as fraction anymore, not necessarily out of 100%
          }
        }
      }
    }
    else if(property=="N+1_enthalpy_gain"){
      if(m_cflags.flag("CHULL::SKIP_N+1_ENTHALPY_GAIN_ANALYSIS")||point.getNPlus1EnthalpyGain(_m_)>=AUROSTD_NAN){value=null_value;}
      else {
        if(point.isGState()){
          d_tmp=point.getNPlus1EnthalpyGain(_m_);
          if(d_tmp!=AUROSTD_MAX_DOUBLE){
            precision_tmp=precision;
            if(ftype==latex_ft){precision_tmp=0;tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);}
            value=aurostd::utype2string(d_tmp,precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM); //delivers as decimal, show as percentage  //CO20180409 - not showing as fraction anymore, not necessarily out of 100%
          }
        }
      }
    }
    else if(property=="entropy_stabilization_coefficient"){
      d_tmp=point.getEntropyStabilizationCoefficient();
      if(d_tmp!=AUROSTD_MAX_DOUBLE){
        precision_tmp=precision;
        if(ftype==latex_ft){precision_tmp=0;tmp_roundoff_tol=5.0*pow(10,-((int)precision_tmp)-1);}
        value=aurostd::utype2string(d_tmp,precision_tmp,true,tmp_roundoff_tol,FIXED_STREAM);
      }
    }
    else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown property");}
    if(value.empty()){value=null_value;}
    if(ftype==latex_ft){
      if(external_links && (property=="compound"||(!compounds_column_report&&property=="prototype"))){
        value="\\href{"+ENTRY_PAGE_URL_PREFIX+point.m_entry.auid+"}{"+value+"}";
      }
      value=aurostd::PaddedPOST(value,padding);
    }
    if(LDEBUG) {cerr << soliloquy << " done" << endl;}
    return value;
  }

  string ConvexHull::grabCHFacetProperty(const ChullFacet& facet,const string& property,filetype ftype) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::grabCHFacetProperty():";
    uint precision=COEF_PRECISION;
    double roundoff_tol=5.0*pow(10,-((int)precision)-1);
    string value="";
    string vector_delimiter=";";
    string string_wrapper="";
    string list_prefix="";
    string list_suffix="";
    string null_value="-";
    if(ftype==json_ft){
      vector_delimiter=",";
      string_wrapper="\"";
      list_prefix="[";
      list_suffix="]";
      null_value="null";
    }
    if(LDEBUG) {cerr << soliloquy << " starting property=" << property << endl;}
    if(property=="vertices_position"){
      vector<string> vstr;
      for(uint i=0,fl_size_i=facet.m_vertices.size();i<fl_size_i;i++){
        vstr.push_back(aurostd::joinWDelimiter(aurostd::xvecDouble2vecString(facet.m_vertices[i].ch_point.h_coords,precision,true,roundoff_tol,FIXED_STREAM),vector_delimiter));
      }
      value=aurostd::wrapString(aurostd::joinWDelimiter(aurostd::wrapVecEntries(vstr,"[","]"),","),list_prefix,list_suffix);
    }
    else if(property=="vertices_compound"){
      vector<string> compounds;
      for(uint i=0,fl_size_i=facet.m_vertices.size();i<fl_size_i;i++){
        if(facet.m_vertices[i].ch_point.m_has_entry){
          if(!m_points[facet.m_vertices[i].ch_index].m_entry.compound.empty()){
            compounds.push_back(aurostd::wrapString(m_points[facet.m_vertices[i].ch_index].m_entry.compound,string_wrapper));
          } else {compounds.push_back(null_value);}
        }
        else if(facet.m_vertices[i].ch_point.m_is_artificial){
          uint i_nary=facet.m_vertices[i].ch_point.m_i_nary;
          uint i_alloy=facet.m_vertices[i].ch_point.m_i_alloy;
          string elements=aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"");  //unary, so "" delimiter doesn't play a role
          compounds.push_back(aurostd::wrapString("artificial:"+elements,string_wrapper));
        } else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown print setting");}
      }
      value=aurostd::wrapString(aurostd::joinWDelimiter(compounds,","),list_prefix,list_suffix);
    }
    else if(property=="vertices_auid"){
      vector<string> auids;
      for(uint i=0,fl_size_i=facet.m_vertices.size();i<fl_size_i;i++){
        if(facet.m_vertices[i].ch_point.m_has_entry){
          if(!m_points[facet.m_vertices[i].ch_index].m_entry.auid.empty()){
            auids.push_back(aurostd::wrapString(m_points[facet.m_vertices[i].ch_index].m_entry.auid,string_wrapper));
          } else {auids.push_back(null_value);}
        }
        else if(facet.m_vertices[i].ch_point.m_is_artificial){
          uint i_nary=facet.m_vertices[i].ch_point.m_i_nary;
          uint i_alloy=facet.m_vertices[i].ch_point.m_i_alloy;
          string elements=aurostd::joinWDelimiter(alloyToElements(i_nary,i_alloy),"");  //unary, so "" delimiter doesn't play a role
          auids.push_back(aurostd::wrapString("artificial:"+elements,string_wrapper));
        } else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown print setting");}
      }
      value=aurostd::wrapString(aurostd::joinWDelimiter(auids,","),list_prefix,list_suffix);
    }
    else if(property=="content"){value=aurostd::utype2string(facet.m_content,precision,true,roundoff_tol,FIXED_STREAM);}
    else if(property=="normal"){value="["+aurostd::joinWDelimiter(aurostd::xvecDouble2vecString(facet.m_normal,precision,true,roundoff_tol,FIXED_STREAM),vector_delimiter)+"]";}
    else if(property=="offset"){value=aurostd::utype2string(facet.m_offset,precision,true,roundoff_tol,FIXED_STREAM);}
    else if(property=="centroid"){value="["+aurostd::joinWDelimiter(aurostd::xvecDouble2vecString(facet.m_facet_centroid,precision,true,roundoff_tol,FIXED_STREAM),vector_delimiter)+"]";}
    else if(property=="hypercollinear"){value=(facet.m_hypercollinear?"true":"false");}
    else if(property=="vertical"){value=(facet.m_is_vertical?"true":"false");}
    else if(property=="artificial"){value=(facet.m_is_artificial?"true":"false");}
    else {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown property");}
    if(value.empty()){value=null_value;}
    return value;
  }

  vector<vector<string> > ConvexHull::getPointsData(const string& properties_str,vector<string>& headers,filetype ftype) const {
    string soliloquy=XPID+"ConvexHull::getPointsData():";
    stringstream message;

    vector<string> vproperties;
    uint i_point=AUROSTD_MAX_UINT;
    string value;

    vector<vector<string> > ventries;
    aurostd::string2tokens(properties_str,vproperties,",");
    for(uint i_coord_group=0,fl_size_i_coord_group=m_coord_groups.size();i_coord_group<fl_size_i_coord_group;i_coord_group++){
      if(!m_coord_groups[i_coord_group].m_points.size()){continue;}
      if(!m_coord_groups[i_coord_group].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Coordgroup["+aurostd::utype2string(i_coord_group)+"] is not initialized");}
      for(uint i=0,fl_size_i=m_coord_groups[i_coord_group].m_points.size();i<fl_size_i;i++){
        i_point=m_coord_groups[i_coord_group].m_points[i];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        const ChullPoint& point=m_points[i_point];
        if(!point.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        if(!point.m_has_entry){continue;}
        ventries.push_back(vector<string>(0));
        for(uint j=0,fl_size_j=vproperties.size();j<fl_size_j;j++){
          value=grabCHPointProperty(point,vproperties[j],ftype);
          ventries.back().push_back(value);
        }
      }
    }

    string header;
    headers.clear();
    if(ftype==json_ft){
      //for json response, we want TRUE keywords as they would appear in aflowlib.out
      for(uint i=0,fl_size_i=vproperties.size();i<fl_size_i;i++){
        header=vproperties[i];
        //add any processing here
        headers.push_back(header);
      }
    } else {
      //for text response, we decorate nicely by replacing _atom with _[/atom]
      for(uint i=0,fl_size_i=vproperties.size();i<fl_size_i;i++){
        header=vproperties[i];
        //while this is "pretty", it's NON-STANDARD
        //define in the paper, and leave it be
        //if(vproperties[i]=="url_entry_page"){header="entry_page_url";}
        //if(vproperties[i]=="enthalpy_formation_atom"){header="formation_enthalpy";}
        //if(vproperties[i]=="spin_atom"){header="spin";}
        //if(vproperties[i]=="phases_equilibrium_compound"){header="equilibrium_phases";}
        //if(vproperties[i]=="phases_equilibrium_auid"){header="equilibrium_phases_auids";}
        //if(vproperties[i]=="phases_decomposition_compound"){header="decomposition_phases";}
        //if(vproperties[i]=="phases_decomposition_auid"){header="decomposition_phases_auids";}
        //if(vproperties[i]=="phases_decomposition_coefficient"){header="decomposition_coefficients";}
        //if(vproperties[i]=="enthalpy_formation_atom_difference"){header="formation_enthalpy_difference";}
        //add any processing here before upper
        header=aurostd::toupper(header);
        //units are nice, but again, NON-STANDARD
        //define in the ppaer, and leave it be
        //add any processing here after upper
        //if(vproperties[i]=="enthalpy_formation_atom"){header+="_[meV/atom]";}
        //if(vproperties[i]=="entropic_temperature"){header+="_[K]";}
        //if(vproperties[i]=="spin_atom"){header+="_[mu_B/atom]";}
        //if(vproperties[i]=="enthalpy_formation_atom_difference"){header+="_[meV/atom]";}
        //if(vproperties[i]=="entropic_temperature_difference"){header+="_[K]";}
        headers.push_back(header);
      }
    }
    return ventries;
  }

  vector<vector<vector<vector<string> > > > ConvexHull::getFacetsData(const string& facet_properties_str,vector<string>& headers,filetype ftype) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getFacetsData():";
    stringstream message;

    if(m_naries.size()<2){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No naries (larger than 1) found");}

    vector<string> vproperties;
    string value;
    vector<vector<vector<vector<string> > > > ventries;

    aurostd::string2tokens(facet_properties_str,vproperties,",");
    uint i_facet;
    for(uint i_nary=1,fl_size_i_nary=m_naries.size();i_nary<fl_size_i_nary;i_nary++){
      if(!m_naries[i_nary].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary["+aurostd::utype2string(i_nary)+"]");}
      if(m_naries[i_nary].m_alloys.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No alloys found in nary["+aurostd::utype2string(i_nary)+"]");}
      if(LDEBUG) {cerr << soliloquy << " looking at i_nary=" << i_nary << endl;}
      ventries.push_back(vector<vector<vector<string> > >(0));
      for(uint i_alloy=0,fl_size_i_alloy=m_naries[i_nary].m_alloys.size();i_alloy<fl_size_i_alloy;i_alloy++){
        if(!m_naries[i_nary].m_alloys[i_alloy].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized nary[i_nary="+aurostd::utype2string(i_nary)+",i_alloy="+aurostd::utype2string(i_alloy)+"]");}
        if(!m_cflags.flag("CHULL::CALCULATE_HIGHEST_DIMENSION_ONLY")){
          if(m_naries[i_nary].m_alloys[i_alloy].m_facets.size()==0){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"No facets found in nary[i_nary="+aurostd::utype2string(i_nary)+",i_alloy="+aurostd::utype2string(i_alloy)+"]");}
        }
        if(LDEBUG) {cerr << soliloquy << " looking at i_nary=" << i_nary << ",i_alloy=" << i_alloy << endl;}
        ventries.back().push_back(vector<vector<string> >(0));
        for(uint i=0,fl_size_i=m_naries[i_nary].m_alloys[i_alloy].m_facets.size();i<fl_size_i;i++){
          i_facet=m_naries[i_nary].m_alloys[i_alloy].m_facets[i];
          const ChullFacet& facet=m_facets[i_facet];
          if(!facet.m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Facet[i_nary="+aurostd::utype2string(i_nary)+",i_alloy="+aurostd::utype2string(i_alloy)+",i_facet="+aurostd::utype2string(i_facet)+"] is not initialized");}
          if(LDEBUG) {cerr << soliloquy << " looking at i_nary=" << i_nary << ",i_alloy=" << i_alloy << ",i_facet=" << i_facet << endl;}
          ventries.back().back().push_back(vector<string>(0));
          for(uint j=0,fl_size_j=vproperties.size();j<fl_size_j;j++){
            value=grabCHFacetProperty(facet,vproperties[j],ftype);
            ventries.back().back().back().push_back(value);
          }
        }
      }
    }
    if(LDEBUG) {cerr << soliloquy << " created ventries" << endl;}

    string header;
    headers.clear();
    if(ftype==json_ft){
      //for json response, we want TRUE keywords as they would appear in aflowlib.out
      for(uint i=0,fl_size_i=vproperties.size();i<fl_size_i;i++){
        header=vproperties[i];
        //add any processing here
        headers.push_back(header);
      }
    } else {
      //for text response, we decorate nicely by replacing _atom with _[/atom]
      for(uint i=0,fl_size_i=vproperties.size();i<fl_size_i;i++){
        header=vproperties[i];
        //add any processing here before upper
        header=aurostd::toupper(header);
        //add any processing here after upper
        headers.push_back(header);
      }
    }
    if(LDEBUG) {cerr << soliloquy << " created headers" << endl;}
    return ventries;
  }

  void ConvexHull::getPlainTextColumnSizes(const vector<string>& headers,const vector<vector<string> >& ventries,vector<uint>& sizes) const {
    string soliloquy=XPID+"ConvexHull::getPlainTextColumnSizes():";
    for(uint i=0,fl_size_i=ventries.size();i<fl_size_i;i++){
      if(headers.size()!=ventries[i].size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between headers and ventries");}
    }
    if(sizes.size()==0){  //initialize
      sizes.resize(headers.size());
      for(uint i=0,fl_size_i=headers.size();i<fl_size_i;i++){sizes[i]=headers[i].size();}
    }
    if(sizes.size()!=headers.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between sizes and headers");}
    uint p_size;
    for(uint i=0,fl_size_i=ventries.size();i<fl_size_i;i++){
      for(uint j=0,fl_size_j=ventries[i].size();j<fl_size_j;j++){
        p_size=ventries[i][j].size();
        sizes[j]=std::max(sizes[j],p_size);
      }
    }
  }

  void ConvexHull::getPlainTextColumnSizesPoints(const vector<string>& headers,const vector<vector<string> >& ventries,vector<uint>& sizes) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getPlainTextColumnSizesPoints():";
    stringstream message;
    sizes.clear();
    getPlainTextColumnSizes(headers,ventries,sizes);
    if(LDEBUG) {cerr << soliloquy << " sizes=" << sizes.size() << endl;}
    if(LDEBUG) {cerr << soliloquy << " determined sizes" << endl;}
  }

  void ConvexHull::getPlainTextColumnSizesFacets(const vector<string>& headers,const vector<vector<vector<vector<string> > > >& ventries,vector<uint>& sizes) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::getPlainTextColumnSizesFacets():";
    stringstream message;
    sizes.clear();
    for(uint i=0,fl_size_i=ventries.size();i<fl_size_i;i++){
      for(uint j=0,fl_size_j=ventries[i].size();j<fl_size_j;j++){
        getPlainTextColumnSizes(headers,ventries[i][j],sizes);
      }
    }
    if(LDEBUG) {cerr << soliloquy << " sizes=" << sizes.size() << endl;}
    if(LDEBUG) {cerr << soliloquy << " determined sizes" << endl;}
  }

  string ConvexHull::getPlainTextTable(const vector<string>& headers,const vector<vector<string> >& ventries,const vector<uint>& sizes) const {
    stringstream out_ss;
    for(uint i=0,fl_size_i=headers.size();i<fl_size_i;i++){out_ss << aurostd::PaddedPOST(headers[i],sizes[i]+5);}
    out_ss << endl;
    for(uint i=0,fl_size_i=ventries.size();i<fl_size_i;i++){
      for(uint j=0,fl_size_j=ventries[i].size();j<fl_size_j;j++){
        out_ss << aurostd::PaddedPOST(ventries[i][j],sizes[j]+5);
      }
      out_ss << endl;
    }
    return out_ss.str();
  }

  string ConvexHull::getJSONTable(const vector<string>& headers,const vector<vector<string> >& ventries) const {
    stringstream misc_ss;misc_ss.str("");
    vector<string> _vout;_vout.clear();
    vector<string> vout;vout.clear();
    for(uint i=0,fl_size_i=ventries.size();i<fl_size_i;i++){
      for(uint j=0,fl_size_j=ventries[i].size();j<fl_size_j;j++){
        misc_ss << aurostd::wrapString(headers[j],"\"") << ":" << ventries[i][j];
        _vout.push_back(misc_ss.str()); misc_ss.str("");
      }
      vout.push_back(aurostd::wrapString(aurostd::joinWDelimiter(_vout,","),"{","}")); _vout.clear();
    }
    return aurostd::wrapString(aurostd::joinWDelimiter(vout,","),"[","]");
  }

  void ConvexHull::writeText(filetype ftype) const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::writeText():";
    stringstream message;

    if(!(ftype==txt_ft || ftype==json_ft)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unknown mode");}

    if(!m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Hull not initialized");}

    if(ftype==txt_ft){message << "Starting plain text generator";}
    else {message << "Starting JSON generator";}
    pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_MESSAGE_);

    string properties_str_points=getPointsPropertyHeaderList(ftype);

    bool terse_output=false;
    string facet_properties_str="vertices_position";
    if(!terse_output){facet_properties_str+=",vertices_compound";}
    facet_properties_str+=",vertices_auid";
    facet_properties_str+=",content";
    facet_properties_str+=",normal";
    facet_properties_str+=",offset";
    facet_properties_str+=",centroid";
    facet_properties_str+=",hypercollinear";
    facet_properties_str+=",vertical";
    facet_properties_str+=",artificial";

    stringstream main_text_ss;main_text_ss.str("");
    vector<string> vout;        //json only
    vector<uint> column_sizes;  //plain text only

    //POINTS DATA
    vector<string> headers_points;
    vector<vector<string> > ventries_points=getPointsData(properties_str_points,headers_points,ftype);
    if(LDEBUG) {cerr << soliloquy << " got points data" << endl;}

    //FACETS DATA
    vector<string> headers_facets;
    //first layer=nary, second=alloy, third=facet, fourth=properties
    vector<vector<vector<vector<string> > > > ventries_facets=getFacetsData(facet_properties_str,headers_facets,ftype);
    if(LDEBUG) {cerr << soliloquy << " got facets data" << endl;}

    //HEADER
    if(ftype==json_ft){vout.push_back("\"hull_data\":"+getJSONHeader());}
    else {main_text_ss << getPlainTextHeader();}
    if(LDEBUG) {cerr << soliloquy << " created doc header" << endl;}

    //points data
    if(ftype==json_ft){vout.push_back("\"points_data\":"+getJSONTable(headers_points,ventries_points));}
    else {
      getPlainTextColumnSizesPoints(headers_points,ventries_points,column_sizes);
      main_text_ss << endl;
      main_text_ss << "POINTS DATA" << endl;
      main_text_ss << getPlainTextTable(headers_points,ventries_points,column_sizes);
      main_text_ss << endl;
    }
    if(LDEBUG) {cerr << soliloquy << " added points data" << endl;}

    //facets data
    if(ftype==json_ft){
      stringstream misc_ss;misc_ss.str("");
      vector<string> _vout;
      for(uint i=0,fl_size_i=ventries_facets.size();i<fl_size_i;i++){
        for(uint j=0,fl_size_j=ventries_facets[i].size();j<fl_size_j;j++){
          misc_ss << "\"" << i+2 << "-nary:";
          if(m_velements.size()){misc_ss << aurostd::joinWDelimiter(alloyToElements(i+1,j),"-");}
          else {misc_ss << j+1;}
          misc_ss << "\":" << getJSONTable(headers_facets,ventries_facets[i][j]);
          _vout.push_back(misc_ss.str()); misc_ss.str("");
        }
      }
      vout.push_back("\"facets_data\":"+aurostd::wrapString(aurostd::joinWDelimiter(_vout,","),"{","}"));
    } else {
      getPlainTextColumnSizesFacets(headers_facets,ventries_facets,column_sizes);
      main_text_ss << endl;
      for(uint i=0,fl_size_i=ventries_facets.size();i<fl_size_i;i++){
        for(uint j=0,fl_size_j=ventries_facets[i].size();j<fl_size_j;j++){
          main_text_ss << "FACETS DATA " << i+2 << "-nary ";
          if(m_velements.size()){main_text_ss << "(" << aurostd::joinWDelimiter(alloyToElements(i+1,j),"-") << ")";}
          else {main_text_ss << "(" << j+1 << ")";}
          main_text_ss << endl;
          main_text_ss << getPlainTextTable(headers_facets,ventries_facets[i][j],column_sizes);
          if(!(i==ventries_facets.size()-1 && j==ventries_facets[i].size()-1)){main_text_ss << endl;}
        }
        if(i!=ventries_facets.size()-1){main_text_ss << endl;}
      }
    }
    if(LDEBUG) {cerr << soliloquy << " added facets data" << endl;}

    if(ftype==json_ft){main_text_ss << aurostd::wrapString(aurostd::joinWDelimiter(vout,","),"{","}");}

    string file_name="aflow_"+aurostd::joinWDelimiter(m_velements,"")+"_hull";
    if(ftype==json_ft){file_name+=".json";}
    else {file_name+=".txt";}

    if(m_cflags.flag("CHULL::SCREEN_ONLY")){
      *p_oss << main_text_ss.str();
      return;
    }

    if(LDEBUG) {cerr << soliloquy << " now writting to file" << endl;}
    string path = getPath(m_cflags, *p_FileMESSAGE, *p_oss);
    string destination = path + file_name;
    aurostd::stringstream2file(main_text_ss,destination);
    if(!aurostd::FileExist(destination)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Unable to write "+file_name+" to "+path);}
    message << file_name << " was created successfully, see destination=" << path;
    pflow::logger(_AFLOW_FILE_NAME_,soliloquy,message,m_aflags, *p_FileMESSAGE,*p_oss,_LOGGER_COMPLETE_);
  }

  void ConvexHull::writeWebApp() const {
    bool LDEBUG=(FALSE || _DEBUG_CHULL_ || XHOST.DEBUG);
    string soliloquy=XPID+"ConvexHull::writeWebApp():";
    stringstream message;
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, "Starting web-specific JSONifier", m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_MESSAGE_);

    // initializing stringstreams to use
    stringstream main_JSON_ss;
    stringstream id_data_JSON_ss;
    stringstream species_data_JSON_ss;
    vector<string> points_data_JSON_vs;
    vector<string> distances_data_JSON_vs;
    stringstream distances_data_JSON_ss;
    vector<string> stoich_comp_JSON_vs;
    stringstream stoich_comp_JSON_ss;
    vector<string> stoich_data_JSON_vs;
    stringstream stoich_data_JSON_ss;
    vector<string> stoich_points_data_JSON_vs;
    vector<string> vertices_data_JSON_vs;
    stringstream vertices_data_JSON_ss;
    vector<string> hull_points_data_JSON_vs;
    stringstream hull_points_data_JSON_ss;
    vector<string> planes_data_JSON_vs;
    vector<string> decomp_data_JSON_vs;
    stringstream decomp_data_JSON_ss;
    stringstream data_helper_ss;
    stringstream num_ss;  // no precision, for properties calculated by AFLOW

    // initializing some strings
    string main_JSON_file;
    string input;//,input_hyphened;

    // creating name of output file
    input=aurostd::joinWDelimiter(m_velements,"");
    //input_hyphened=aurostd::joinWDelimiter(m_velements,"-");
    main_JSON_file="aflow_"+input; //SK20200406
    //[SK20200325 - OBSOLETE]main_JSON_file="aflow_"+input+"_hull_web.json"; //WSCHMITT20190620
    //SK20200331 START
    bool fhsc_requested=m_cflags.flag("CHULL::CALCULATE_FAKE_HULL_STABILITY_CRITERION");  //only neglect feature via web
    bool fhn1eg_requested=m_cflags.flag("CHULL::CALCULATE_FAKE_HULL_N+1_ENTHALPY_GAIN");
    vector<string> sc_point;
    string delimiter="";
    // naming stability criterion files
    if(fhsc_requested) {
      aurostd::string2tokens(m_cflags.getattachedscheme("CHULL::CALCULATE_FAKE_HULL_STABILITY_CRITERION"),sc_point,",");
      std::sort(sc_point.begin(),sc_point.end()); //CO20200404 - this sort is NOT necessary, as web only removes 1 point a time, but this is SAFE
      delimiter = "_sc_";
      // limiting to the characters after "aflow:" because ":" is a reserved character for php query calls, also shortening queries
      main_JSON_file=main_JSON_file + delimiter + sc_point[0].substr(6); // restricting to single auid to limit file name growth, the substr(6) removes 'aflow:' from string which would cause issues for the filename/web
      if(LDEBUG){cerr << soliloquy << " main_JSON_file=" << main_JSON_file << endl;}
    }
    // naming n+1 enthalpy gain files
    if (fhn1eg_requested) {
      delimiter = "_n1eg";  //CO20200404 - n+1 is the same for all points on a hull
      main_JSON_file=main_JSON_file + delimiter;
    }
    //SK20200331 END
    main_JSON_file=main_JSON_file+"_hull_web.json"; //SK20200327
    species_data_JSON_ss << aurostd::joinWDelimiter(aurostd::wrapVecEntries(m_velements,"\""),",");
    //for (uint i = 0; i < m_velements.size(); i++) {
    //  main_JSON_file.append(m_velements[i]);
    //  species_data_JSON_ss << "\"" << m_velements[i] << "\"";
    //  if(i != m_velements.size() - 1) {
    //    species_data_JSON_ss << ",";
    //  }
    //}
    //input = main_JSON_file;
    //main_JSON_file.append("_hull.json");

    // other initializations
    bool stoich_groups_set;
    xvector<double> coord;
    xvector<double> normal;

    //////////////////////////////////////////////////////////////////////////////
    // START Stoichiometry group loop
    //////////////////////////////////////////////////////////////////////////////

    uint i_point=AUROSTD_MAX_UINT,i_phase=AUROSTD_MAX_UINT;
    for(uint i=0,fl_size_i=m_coord_groups.size();i<fl_size_i;i++) {
      stoich_groups_set = false;

      ////////////////////////////////////////////////////////////////////////////
      // START Stoichiometry group points loop
      ////////////////////////////////////////////////////////////////////////////

      for(uint j=0,fl_size_j=m_coord_groups[i].m_points.size();j<fl_size_j;j++) {
        //////////////////////////////////////////////////////////////////////////
        // START Entries filter
        //////////////////////////////////////////////////////////////////////////
        i_point=m_coord_groups[i].m_points[j];
        if(!m_points[i_point].m_initialized){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Point["+aurostd::utype2string(i_point)+"] is not initialized");}
        const ChullPoint& point = m_points[i_point];
        const aflowlib::_aflowlib_entry& entry = point.m_entry;

        //////////////////////////////////////////////////////////////////////////
        // END Entries filter
        //////////////////////////////////////////////////////////////////////////

        if(!stoich_groups_set) {
          ////////////////////////////////////////////////////////////////////////
          // START Stoichiometry group properties output
          ////////////////////////////////////////////////////////////////////////

          stoich_data_JSON_ss << "{";
          // get stoich id and stoichiometries at the same time
          // id_data_JSON_ss will take care of id
          for(int j=point.m_elements_present.lrows;j<=point.m_elements_present.urows;j++) {
            if(point.m_elements_present[j]==1){
              stoich_comp_JSON_ss << "{";
              stoich_comp_JSON_ss << "\"element\":\"" << m_velements[j-point.m_elements_present.lrows] << "\",";
              id_data_JSON_ss << m_velements[j-point.m_elements_present.lrows] << aurostd::utype2string(point.s_coords[j],CHULL_PRECISION); // make id out of nonzero components
              stoich_comp_JSON_ss << "\"stoichiometry\":" << aurostd::utype2string(point.s_coords[j],CHULL_PRECISION) << "}";
              stoich_comp_JSON_vs.push_back(stoich_comp_JSON_ss.str());
              stoich_comp_JSON_ss.str("");
            }
          }
          stoich_data_JSON_ss << "\"stoichiometries\":[" << aurostd::joinWDelimiter(stoich_comp_JSON_vs, ',') << "],";
          stoich_data_JSON_ss << "\"id\":\"" << id_data_JSON_ss.str() << "\",";
          id_data_JSON_ss.str("");
          // get is_hull
          stoich_data_JSON_ss << "\"isGroundState\":" << (m_coord_groups[i].m_is_on_hull?"true":"false") << ",";
          // get endPoint
          stoich_data_JSON_ss << "\"endPoint\":" << (m_coord_groups[i].m_i_nary==0?"true":"false") << ",";
          // get decomposition information for all phases
          const vector<uint>& decomposition_phases = m_coord_groups[i].m_decomp_phases;
          const xvector<double>& decomposition_coefficients = m_coord_groups[i].m_decomp_coefs;

          ////////////////////////////////////////////////////////////////////////
          // START Gathering info about decomposition reaction (equilibrium phase
          // stuff handled by javascript with FACES)
          ////////////////////////////////////////////////////////////////////////

          if(!decomposition_phases.empty() && scalar_product(decomposition_coefficients, decomposition_coefficients) >= ZERO_TOL) {
            if(decomposition_phases.size() != (uint)decomposition_coefficients.rows-1) {
              throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Size of decomposition phases != size of decomposition coefficients for coordgroup["+aurostd::utype2string(i)+"]");
            }
            for(uint k=0,fl_size_k=decomposition_phases.size();k<fl_size_k;k++) {
              if(abs(decomposition_coefficients[decomposition_coefficients.lrows+k+1]) < ZERO_TOL) {continue;}
              decomp_data_JSON_ss << "{";
              i_phase=artificialMap(decomposition_phases[k]);
              const ChullPoint& dc_phase=m_points[i_phase];
              if(!dc_phase.m_has_entry) {
                // we need to adjust for missing unaries
                // look for coords
                decomp_data_JSON_ss << "\"entry\":\"" << AFLOW_HULL_ENDPOINT_STRING << ":" << aurostd::joinWDelimiter(alloyToElements(dc_phase),"") << "\","; //unary, so "" delimiter doesn't play a role
              } else {
                const aflowlib::_aflowlib_entry& equation_entry = dc_phase.m_entry;
                decomp_data_JSON_ss << "\"entry\":\"" << equation_entry.auid << "\",";
              }
              decomp_data_JSON_ss << "\"coefficient\":" << aurostd::utype2string(decomposition_coefficients[decomposition_coefficients.lrows+k+1],CHULL_PRECISION);
              decomp_data_JSON_ss << "}";
              decomp_data_JSON_vs.push_back(decomp_data_JSON_ss.str());
              decomp_data_JSON_ss.str("");
            }
          }
          // print even if empty
          stoich_data_JSON_ss << "\"decomposition_phases\":[" << aurostd::joinWDelimiter(decomp_data_JSON_vs, ',') << "],";
          decomp_data_JSON_vs.clear();
          // filling in "points" is last
          stoich_groups_set = true;

          ////////////////////////////////////////////////////////////////////////
          // END Gathering info about decomposition reaction
          ////////////////////////////////////////////////////////////////////////

          ////////////////////////////////////////////////////////////////////////
          // END Stoichiometry group properties output
          ////////////////////////////////////////////////////////////////////////
        }

        //////////////////////////////////////////////////////////////////////////
        // START Entry properties output
        //////////////////////////////////////////////////////////////////////////

        if(point.m_has_entry) {
          data_helper_ss << "\"" << entry.auid << "\"";
          stoich_points_data_JSON_vs.push_back(data_helper_ss.str());
          data_helper_ss.str("");
          // remove artificial points from distances
          distances_data_JSON_ss << "{";
          distances_data_JSON_ss << "\"auid\":";
        }
        // get points, distances, vertices
        if(point.m_is_g_state) {
          hull_points_data_JSON_ss << "{";
          hull_points_data_JSON_ss << "\"auid\":";  // why not entry? or all auid? why two different names?
        }
        if(!point.m_has_entry) {
          data_helper_ss << "\"" << AFLOW_HULL_ENDPOINT_STRING << ":" << aurostd::joinWDelimiter(alloyToElements(point),"") << "\"";  //unary, so "" delimiter doesn't play a role
          if(point.m_is_g_state) {hull_points_data_JSON_ss << data_helper_ss.str();}
          data_helper_ss.str(""); //WSCHMITT20190731 - patching quaternary hull writer issues
        } else {
          data_helper_ss << "\"" << entry.auid << "\"";
          points_data_JSON_vs.push_back(data_helper_ss.str());
          distances_data_JSON_ss << data_helper_ss.str();
          if(point.m_is_g_state) {hull_points_data_JSON_ss << data_helper_ss.str();}
          data_helper_ss.str("");
          // wrap up distances data
          distances_data_JSON_ss << ",";
          distances_data_JSON_ss << "\"distanceToHull\":" << aurostd::utype2string(point.getDist2Hull(_std_),CHULL_PRECISION);
          // ADDED BY EGOSS
          //
          // Changed distances_data to be points data. I believe 
          // points_data_JSON may be removed and replaced with this.
          //
          distances_data_JSON_ss << ",";
          distances_data_JSON_ss << "\"compound\": \""<< entry.compound << "\"";
          distances_data_JSON_ss << ",";
          distances_data_JSON_ss << "\"composition\":[";
          // explicit dimensions
          const xvector<double>& coord = point.s_coords;
          distances_data_JSON_ss << aurostd::joinWDelimiter(aurostd::xvecDouble2vecString(coord,CHULL_PRECISION,false),",");
          //[CO20190423 - OBSOLETE]for(int k=coord.lrows;k<=coord.urows;k++) {
          //[CO20190423 - OBSOLETE] distances_data_JSON_ss << aurostd::utype2string(coord(k),CHULL_PRECISION);  // is 3 digits okay? I normally do 15
          //[CO20190423 - OBSOLETE] if(k!=coord.urows){distances_data_JSON_ss << ",";}
          //[CO20190423 - OBSOLETE]}
          distances_data_JSON_ss << "],";
          // fix for unaries, set to 0
          if(!point.m_has_entry) {  // these are only hull_members, so they only happen to
            // endpoints
            // enthalpy of formation, row 4
            // no need for precision for next few columns, leave it same way as
            // received from AFLOW
            distances_data_JSON_ss << "\"enthalpyFormationAtom\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
            distances_data_JSON_ss << ",";
            // entropic temperature, row 5
            distances_data_JSON_ss << "\"entropicTemperature\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
            //WSCHMITT20190620 - adding in np1 and stab criterion to webApp - START
            distances_data_JSON_ss << ",";
            distances_data_JSON_ss << "\"nPlus1EnthalpyGain\":" << aurostd::utype2string(0.0, CHULL_PRECISION);
            distances_data_JSON_ss << ",";
            distances_data_JSON_ss << "\"stabilityCriterion\":" << aurostd::utype2string(0.0, CHULL_PRECISION);
            //WSCHMITT20190620 - adding in np1 and stab criterion to webApp - STOP
          } else {
            // enthalpy of formation, row 4
            // no need for precision for next few columns, leave it same way as
            // received from AFLOW
            num_ss << chull::H_f_atom(entry, _std_);
            distances_data_JSON_ss << "\"enthalpyFormationAtom\":" << num_ss.str();
            distances_data_JSON_ss << ",";
            num_ss.str("");
            // entropic temperature, row 5
            num_ss << chull::T_S(entry);
            distances_data_JSON_ss << "\"entropicTemperature\":" << num_ss.str();
            num_ss.str("");

            //WSCHMITT20190620 - adding in np1 and stab criterion to webApp, "N/A" for non ground-states - START
            distances_data_JSON_ss << ",";

            num_ss << ConvexHull::grabCHPointProperty(point,"N+1_enthalpy_gain",json_ft);
            distances_data_JSON_ss << "\"nPlus1EnthalpyGain\":" << num_ss.str();
            distances_data_JSON_ss << ",";
            num_ss.str("");

            num_ss << ConvexHull::grabCHPointProperty(point,"stability_criterion",json_ft);
            distances_data_JSON_ss << "\"stabilityCriterion\":" << num_ss.str();
            num_ss.str("");
            //WSCHMITT20190620 - adding in np1 and stab criterion to webApp, "N/A" for non ground-states - STOP

            //SK20200825 start
            //adding decompositionAuids for webapp
            distances_data_JSON_ss << ",";
            num_ss.str("");

            num_ss << ConvexHull::grabCHPointProperty(point,"phases_decomposition_auid",json_ft);
            distances_data_JSON_ss << "\"decompositionAuids\":" << num_ss.str();
            num_ss.str("");
            //SK20200825 end
          }
          distances_data_JSON_ss << "}";
          distances_data_JSON_vs.push_back(distances_data_JSON_ss.str());
          distances_data_JSON_ss.str("");
        }
        // distances
        // vertices
        if(point.m_is_g_state) {
          hull_points_data_JSON_ss << ",";
          hull_points_data_JSON_ss << "\"compound\": \""<< entry.compound << "\"";
          hull_points_data_JSON_ss << ",";
          hull_points_data_JSON_ss << "\"composition\":[";
          // explicit dimensions
          const xvector<double>& coord = point.s_coords;
          hull_points_data_JSON_ss << aurostd::joinWDelimiter(aurostd::xvecDouble2vecString(coord,CHULL_PRECISION,false),",");
          //[CO20190423 - OBSOLETE]for(int k=coord.lrows;k<=coord.urows;k++) {
          //[CO20190423 - OBSOLETE]  hull_points_data_JSON_ss << aurostd::utype2string(coord(k),CHULL_PRECISION);  // is 3 digits okay? I normally do 15
          //[CO20190423 - OBSOLETE]  if(k!=coord.urows){hull_points_data_JSON_ss << ",";}
          //[CO20190423 - OBSOLETE]}
          // implicit dimension
          hull_points_data_JSON_ss << "],";
          // fix for unaries, set to 0
          if(!point.m_has_entry) {  // these are only hull_members, so they only happen to
            // endpoints
            // enthalpy of formation, row 4
            // no need for precision for next few columns, leave it same way as
            // received from AFLOW
            hull_points_data_JSON_ss << "\"enthalpyFormationAtom\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
            hull_points_data_JSON_ss << ",";
            // entropic temperature, row 5
            hull_points_data_JSON_ss << "\"entropicTemperature\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
            //WSCHMITT20190620 - adding in np1 and stab criterion to webApp - START
            hull_points_data_JSON_ss << ",";
            hull_points_data_JSON_ss << "\"nPlus1EnthalpyGain\":" << aurostd::utype2string(0.0, CHULL_PRECISION);
            hull_points_data_JSON_ss << ",";
            hull_points_data_JSON_ss << "\"stabilityCriterion\":" << aurostd::utype2string(0.0, CHULL_PRECISION);
            //WSCHMITT20190620 - adding in np1 and stab criterion to webApp - STOP
          } else {
            // enthalpy of formation, row 4
            // no need for precision for next few columns, leave it same way as
            // received from AFLOW
            num_ss << chull::H_f_atom(entry, _std_);
            hull_points_data_JSON_ss << "\"enthalpyFormationAtom\":" << num_ss.str();
            hull_points_data_JSON_ss << ",";
            num_ss.str("");
            // entropic temperature, row 5
            num_ss << chull::T_S(entry);
            hull_points_data_JSON_ss << "\"entropicTemperature\":" << num_ss.str();
            num_ss.str("");

            //WSCHMITT20190620 - adding in np1 and stab criterion to webApp - START
            hull_points_data_JSON_ss << ",";

            num_ss << ConvexHull::grabCHPointProperty(point,"N+1_enthalpy_gain",json_ft);
            hull_points_data_JSON_ss << "\"nPlus1EnthalpyGain\":" << num_ss.str();
            hull_points_data_JSON_ss << ",";
            num_ss.str("");

            num_ss << ConvexHull::grabCHPointProperty(point,"stability_criterion",json_ft);
            hull_points_data_JSON_ss << "\"stabilityCriterion\":" << num_ss.str();
            num_ss.str("");
            //WSCHMITT20190620 - adding in np1 and stab criterion to webApp - STOP
          }
          hull_points_data_JSON_ss << "}";
          hull_points_data_JSON_vs.push_back(hull_points_data_JSON_ss.str());
          hull_points_data_JSON_ss.str("");
        }

        //////////////////////////////////////////////////////////////////////////
        // END Entry properties output
        //////////////////////////////////////////////////////////////////////////
      }
      if(stoich_groups_set) {
        stoich_data_JSON_ss << "\"points\":[" << aurostd::joinWDelimiter(stoich_points_data_JSON_vs, ',') << "]";
        stoich_data_JSON_ss << "}";
        stoich_data_JSON_vs.push_back(stoich_data_JSON_ss.str());
        stoich_points_data_JSON_vs.clear();
        stoich_data_JSON_ss.str("");
      }

      ////////////////////////////////////////////////////////////////////////////
      // END Stoichiometry group points loop
      ////////////////////////////////////////////////////////////////////////////
    }

    //////////////////////////////////////////////////////////////////////////////
    // END Stoichiometry group loop
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Grabbing planes data
    //////////////////////////////////////////////////////////////////////////////
    // index specific, so we can't loop through stoichGroups

    vector<uint> vertices=getHullPoints(false); //moved up for faces
    if(LDEBUG) {cerr << soliloquy << " vertices=" << aurostd::joinWDelimiter(vertices,",") << endl;}

    vector<uint> v_ch_indices,v_vertices_indices;
    bool found=false;
    for(uint i=0,fl_size_i=m_facets.size();i<fl_size_i;i++) {
      //const xvector<double> normal = m_facets[i].m_normal;
      if(!(/*m_facets[i].m_hypercollinear||*/m_facets[i].m_is_vertical||m_facets[i].m_is_artificial)&&m_facets[i].m_dim==m_dim){  //keep hypercollinear, might create small gaps in visualization otherwise //CO20190423 - EG needs three-dimensional only for 3D
        v_ch_indices=m_facets[i].getCHIndices();
        if(LDEBUG) {cerr << soliloquy << " v_ch_indices=" << aurostd::joinWDelimiter(v_ch_indices,",") << endl;}
        v_vertices_indices.clear();
        for(uint j=0,fl_size_j=v_ch_indices.size();j<fl_size_j;j++){
          found=false;
          for(uint k=0,fl_size_k=vertices.size();k<fl_size_k&&!found;k++){
            if(v_ch_indices[j]==vertices[k]){
              v_vertices_indices.push_back(k);
              found=true;
            }
          }
          if(!found){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"ChullPoint["+aurostd::utype2string(v_ch_indices[j])+"] could not be found in getHullPoints()",_INDEX_ILLEGAL_);}
        }
        //data_helper_ss << "[" << aurostd::joinWDelimiter(m_facets[i].getCHIndices(), ',') << "]";
        data_helper_ss << "[" << aurostd::joinWDelimiter(v_vertices_indices, ',') << "]"; //CO20190423 - EG needs references to vertices, not points
        planes_data_JSON_vs.push_back(data_helper_ss.str());
        data_helper_ss.str("");
      }
    }
    //////////////////////////////////////////////////////////////////////////////
    // END Grabbing planes data
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Grabbing vertex data (for 3-D visualization of hull)
    //////////////////////////////////////////////////////////////////////////////
    // index specific, so we can't loop through stoichGroups

    //[CO20190423 - moving up for faces]vector<uint> vertices=getHullPoints(false);
    for(uint i=0,fl_size_i=vertices.size();i<fl_size_i;i++) {
      vertices_data_JSON_ss << "{";
      vertices_data_JSON_ss << "\"auid\":";  // why not entry? or all auid? why two different names?

      const ChullPoint& point = m_points[vertices[i]];
      const aflowlib::_aflowlib_entry& entry = point.m_entry;
      const xvector<double>& coord = point.s_coords;

      if(!point.m_has_entry) {
        vertices_data_JSON_ss << "\"" << AFLOW_HULL_ENDPOINT_STRING << ":" << aurostd::joinWDelimiter(alloyToElements(point),"") << "\""; //unary, so "" delimiter doesn't play a role
      } else {vertices_data_JSON_ss << "\"" << entry.auid << "\"";}

      vertices_data_JSON_ss << ",";
      vertices_data_JSON_ss << "\"compound\": \"" << entry.compound << "\","; 
      vertices_data_JSON_ss << "\"composition\":[";
      // explicit dimensions
      vertices_data_JSON_ss << aurostd::joinWDelimiter(aurostd::xvecDouble2vecString(coord,CHULL_PRECISION,false),",");
      //[CO20190423 - OBSOLETE]for(int k=coord.lrows;k<=coord.urows;k++) {
      //[CO20190423 - OBSOLETE] vertices_data_JSON_ss << aurostd::utype2string(coord(k),CHULL_PRECISION); // is 3 digits okay? I normally do 15
      //[CO20190423 - OBSOLETE] if(k!=coord.rows-1){vertices_data_JSON_ss << ",";}
      //[CO20190423 - OBSOLETE]}
      vertices_data_JSON_ss << "],";
      // fix for unaries, set to 0
      if(!point.m_has_entry) {  // these are only hull_members, so they only happen to
        // endpoints
        // enthalpy of formation, row 4
        // no need for precision for next few columns, leave it same way as
        // received from AFLOW
        vertices_data_JSON_ss << "\"enthalpyFormationAtom\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
        vertices_data_JSON_ss << ",";
        // entropic temperature, row 5
        vertices_data_JSON_ss << "\"entropicTemperature\":" << aurostd::utype2string(0.0,CHULL_PRECISION);
        //WSCHMITT20190620 - adding in np1 and stab criterion to webApp - START
        vertices_data_JSON_ss << ",";
        vertices_data_JSON_ss << "\"nPlus1EnthalpyGain\":" << aurostd::utype2string(0.0, CHULL_PRECISION);
        vertices_data_JSON_ss << ",";
        vertices_data_JSON_ss << "\"stabilityCriterion\":" << aurostd::utype2string(0.0, CHULL_PRECISION);
        //WSCHMITT20190620 - adding in np1 and stab criterion to webApp - STOP
      } else {
        // enthalpy of formation, row 4
        // no need for precision for next few columns, leave it same way as
        // received from AFLOW
        num_ss << chull::H_f_atom(entry, _std_);
        vertices_data_JSON_ss << "\"enthalpyFormationAtom\":" << num_ss.str();
        vertices_data_JSON_ss << ",";
        num_ss.str("");
        // entropic temperature, row 5
        num_ss << chull::T_S(entry);
        vertices_data_JSON_ss << "\"entropicTemperature\":" << num_ss.str();
        num_ss.str("");

        //WSCHMITT20190620 - adding in np1 and stab criterion to webApp, "N/A" for non ground-states - START
        vertices_data_JSON_ss << ",";

        num_ss << ConvexHull::grabCHPointProperty(point,"N+1_enthalpy_gain",json_ft);
        vertices_data_JSON_ss << "\"nPlus1EnthalpyGain\":" << num_ss.str();
        vertices_data_JSON_ss << ",";
        num_ss.str("");

        num_ss << ConvexHull::grabCHPointProperty(point,"stability_criterion",json_ft);
        vertices_data_JSON_ss << "\"stabilityCriterion\":" << num_ss.str();
        num_ss.str("");
        //WSCHMITT20190620 - adding in np1 and stab criterion to webApp, "N/A" for non ground-states - STOP
      }
      vertices_data_JSON_ss << "}";
      vertices_data_JSON_vs.push_back(vertices_data_JSON_ss.str());
      vertices_data_JSON_ss.str("");
    }
    //////////////////////////////////////////////////////////////////////////////
    // END Grabbing vertex data
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    // START Output amalgamation and writing
    //////////////////////////////////////////////////////////////////////////////

    main_JSON_ss << "{";
    main_JSON_ss << "\"name\":\"" << input << "\","; //input_hyphened
    main_JSON_ss << "\"species\":[" << species_data_JSON_ss.str() << "],";
    species_data_JSON_ss.str("");
    // CHANGE BY EGOSS 
    // replaced points_data_JSON_vs with distance_data_JSON_vs
    //
    // OLD
    //main_JSON_ss << "\"points\":[" << aurostd::joinWDelimiter(points_data_JSON_vs, ',')
    //             << "],";
    //points_data_JSON_vs.clear();
    main_JSON_ss << "\"points\":[" << aurostd::joinWDelimiter(distances_data_JSON_vs, ',') << "],";
    distances_data_JSON_vs.clear();
    main_JSON_ss << "\"groundStates\":[" << aurostd::joinWDelimiter(hull_points_data_JSON_vs, ',') << "],";
    hull_points_data_JSON_vs.clear();
    main_JSON_ss << "\"vertices\":[" << aurostd::joinWDelimiter(vertices_data_JSON_vs, ',') << "],";
    vertices_data_JSON_vs.clear();
    // CHANGE BY EGOSS
    // distanceToHull is removed. Now distances are contained within the entries 
    // of points
    //
    //main_JSON_ss << "\"distanceToHull\":["
    //             << aurostd::joinWDelimiter(distances_data_JSON_vs, ',') << "],";
    //distances_data_JSON_vs.clear();

    // CHANGE BY EGOSS
    // At this time I do not require stoichiometryGroups for the visualization. 
    // It should be hidden behind a flag for now.

    if(false) {
      main_JSON_ss << "\"stoichiometryGroups\":[" << aurostd::joinWDelimiter(stoich_data_JSON_vs, ',') << "],";
      stoich_data_JSON_vs.clear();
    }

    main_JSON_ss << "\"faces\":[" << aurostd::joinWDelimiter(planes_data_JSON_vs, ',') << "]";
    planes_data_JSON_vs.clear();  // no comma
    main_JSON_ss << "}";

    if(m_cflags.flag("CHULL::SCREEN_ONLY")){
      *p_oss << main_JSON_ss.str();
      return;
    }

    string path = getPath(m_cflags, *p_FileMESSAGE, *p_oss);
    string destination = path + main_JSON_file;
    aurostd::stringstream2file(main_JSON_ss, destination);
    if(!aurostd::FileExist(destination)) {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Could not write "+main_JSON_file+" to "+path);}

    //////////////////////////////////////////////////////////////////////////////
    // END Output amalgamation and writing
    //////////////////////////////////////////////////////////////////////////////

    message << main_JSON_file << " was created successfully, see destination=" << path;
    pflow::logger(_AFLOW_FILE_NAME_, soliloquy, message, m_aflags, *p_FileMESSAGE, *p_oss, _LOGGER_COMPLETE_);
  }

  void ConvexHull::writeAPool() const {
  }

  bool ConvexHull::sortWithinCoordGroup::operator() (uint i,uint j) {
    //ascending order
    string soliloquy=XPID+"ConvexHull::sortWithinCoordGroup::operator():";
    if( (i>m_points.size()-1) || (j>m_points.size()-1) ) {throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index within CoordGroup");}  //safety
    const ChullPoint& ci=m_points[i];
    const ChullPoint& cj=m_points[j];
    if(ci.isGState()!=cj.isGState()){return ci.isGState()>cj.isGState();}
    //always sort by last coord first
    bool energy_sort=(m_sort_energy_ascending ? (ci.getLastCoord()<cj.getLastCoord()) : (ci.getLastCoord()>cj.getLastCoord()));
    if(ci.m_has_entry && cj.m_has_entry){
      //if entry, then we also sort by proto, compound, and then aurl to make final print out pretty
      return ( energy_sort ||
          ((ci.getLastCoord() == cj.getLastCoord()) && 
           (ci.m_entry.prototype<cj.m_entry.prototype)) ||
          ((ci.getLastCoord() == cj.getLastCoord()) &&
           (ci.m_entry.prototype == cj.m_entry.prototype) && 
           (ci.m_entry.compound<cj.m_entry.compound)) ||
          ((ci.getLastCoord() == cj.getLastCoord()) &&
           (ci.m_entry.prototype == cj.m_entry.prototype) && 
           (ci.m_entry.compound == cj.m_entry.compound) && 
           (ci.m_entry.aurl<cj.m_entry.aurl)) );  //aurl is guaranteed to be unique (more so than auid)
    } else {return energy_sort;}
  }

  bool ConvexHull::sortCHullPoints::operator() (uint i,uint j) const{
    string soliloquy=XPID+"ConvexHull::sortCHullPoints::operator():";
    if(i>m_points.size()-1 || j>m_points.size()-1){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Invalid index for m_points");}
    const ChullPoint& ci=m_points[i];
    const ChullPoint& cj=m_points[j];
    sortThermoPoints stp(m_sort_stoich_ascending,m_sort_energy_ascending);
    return stp.operator()(ci,cj);
  }

  bool ConvexHull::sortFacetsByPoints::operator() (const ChullFacet& fi,const ChullFacet& fj) const {
    string soliloquy=XPID+"ConvexHull::sortFacetsByPoints::operator():";
    if(fi.m_vertices.size()!=fj.m_vertices.size()){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch among facets");} //return m_ascending_order ? fi.m_vertices.size()<rj.m_vertices.size() : fi.m_vertices.size()>rj.m_vertices.size();
    if(fi.m_normal.rows!=fj.m_normal.rows){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Dimension mismatch between facet normals");}
    if(!(fi.m_initialized&&fj.m_initialized)){throw aurostd::xerror(_AFLOW_FILE_NAME_,soliloquy,"Uninitialized facet");}       //ensure we have inward pointing normal and angle

    if(m_auto_sort_energy){
      if(fi.m_in_lower_hemisphere!=fj.m_in_lower_hemisphere){return fi.m_in_lower_hemisphere>fj.m_in_lower_hemisphere;} //upper hemisphere last
      if(fi.m_hypercollinear!=fj.m_hypercollinear){return fi.m_hypercollinear>fj.m_hypercollinear;} //hypercollinearity last within hemisphere
      if(fi.m_is_vertical!=fj.m_is_vertical){return fi.m_is_vertical>fj.m_is_vertical;} //vertical above hypercollinearity
    }

    for(uint i=0,fl_size_i=fi.m_vertices.size();i<fl_size_i;i++){
      if(fi.m_vertices[i].ch_index!=fj.m_vertices[i].ch_index){
        const ChullPoint& ci=m_points[fi.m_vertices[i].ch_index];
        const ChullPoint& cj=m_points[fj.m_vertices[i].ch_index];
        bool sort_stoich_ascending=m_sort_stoich_ascending;
        bool sort_energy_ascending=m_sort_energy_ascending;
        if(m_auto_sort_stoich){sort_stoich_ascending=!fi.m_in_lower_hemisphere;} //left to right in lower hemisphere
        if(m_auto_sort_energy){sort_energy_ascending=fi.m_in_lower_hemisphere;}  //bottom to top in lower hemisphere
        sortThermoPoints stp(sort_stoich_ascending,sort_energy_ascending);
        return stp.operator()(ci,cj);
      }
    }

    return false;
  }
} // namespace chull

#endif  // _AFLOW_CHULL_CPP_

// ***************************************************************************
// *                                                                         *
// *           Aflow STEFANO CURTAROLO - Duke University 2003-2021           *
// *           Aflow COREY OSES - Duke University 2013-2021                  *
// *                                                                         *
// ***************************************************************************
