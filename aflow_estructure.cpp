// ***************************************************************************
// *                                                                         *
// *           Aflow STEFANO CURTAROLO - Duke University 2003-2021           *
// *                                                                         *
// ***************************************************************************
// functions written by KESONG YANG
// 2010-2011: kesong.yang@gmail.com
// 2018: SC xzip

#ifndef _AFLOW_ESTRUCTURE_CPP_
#define _AFLOW_ESTRUCTURE_CPP_

const int BANDS_PRECISION = 4;

#include "aflow.h"

// ***************************************************************************
// aurostd::CountofWords
// ***************************************************************************
namespace aurostd {
  int CountWordsinString(string& input) {
    // return the number of words in a string;
    int number=0;
    string::iterator str_it;
    for (str_it = input.begin(); str_it < input.end(); str_it++) {
      if( ! (*str_it == ' ' || *str_it == '\t' || *str_it == '\n') ) {
        number++;
        while (str_it!=input.end() && !(*str_it == ' ' || *str_it == '\t' || *str_it == '\n') ) {
          str_it++;
        }
      }
    }
    return number;
  }
} // namespace aurostd

// ***************************************************************************
// aurostd::CountofWords
// ***************************************************************************
namespace aurostd {
  int CountWordsinString_web(string input) {
    // return the number of words in a string;
    vector<string> vstr;
    aurostd::string2tokens(input, vstr, " ");
    return vstr.size();
  }
} // namespace aurostd

// ***************************************************************************
// estructure::PEDOS_GENERATE_GNUPLOTSCRIPT(const string& plot_pdosname, const string& PEDOStitle, const double& DOS_Emin, const double& DOS_Emax, const double& DOSMAX, const double& DOSSCALE, const int& Natom_pdos, const vector<vector<vector<double> > >& PDOS, const string& pdosdatafile)
// ***************************************************************************
namespace estructure {
  string PEDOS_GENERATE_GNUPLOTSCRIPT(const string& plot_pdosname, const string& PEDOStitle, const double& DOS_Emin, const double& DOS_Emax, const double& DOSMAX, const double& DOSSCALE, const int& Natom_pdos, const vector<vector<vector<double> > >& PDOS, const string& pdosdatafile) {
    stringstream ss_gnuplot;
    ss_gnuplot << "#Generated by AFLOW" << endl;
    ss_gnuplot << "set term postscript eps enhanced color font \"Helvetica, 40\" size 18, 10.125" << endl;
    ss_gnuplot << "set output " << "\"" << plot_pdosname << ".eps" << "\"" << endl;
    ss_gnuplot << "set title \"" <<PEDOStitle << endl;
    //ss_gnuplot << "set border lw 5" << endl; //CO20170830 - thick border
    ss_gnuplot << "unset border" << endl; //CO20170830 - looks better
    ss_gnuplot << "set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb '#E4E4E4' behind fs noborder" << endl;  //CO20170830 - gray background
    ss_gnuplot << "set grid back lt 1 lc rgb 'white' lw 5" << endl; //CO20170830 - white grid
    ss_gnuplot << endl;

    ss_gnuplot << "#DOS PLOT" << endl;
    ss_gnuplot << "set xtics 2" << endl;
    ss_gnuplot << "set ytics" << endl;
    ss_gnuplot << "set xrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
    if(PDOS[Natom_pdos].at(0).size()==7||PDOS[Natom_pdos].at(0).size()==9||PDOS[Natom_pdos].at(0).size()==19||PDOS[Natom_pdos].at(0).size()==33) {
      ss_gnuplot << "set yrange [" << DOSMAX*DOSSCALE*(-1) <<":"  << DOSMAX*DOSSCALE << "]" << endl;
    }
    if(PDOS[Natom_pdos].at(0).size()==4||PDOS[Natom_pdos].at(0).size()==5||PDOS[Natom_pdos].at(0).size()==10||PDOS[Natom_pdos].at(0).size()==17) {
      ss_gnuplot << "set yrange [0:"  << DOSMAX*DOSSCALE << "]" << endl;
    }
    ss_gnuplot << endl;

    ss_gnuplot << "set label '" << AFLOWLIB_CONSORTIUM_STRING << "' at screen 0.70, 0.02 font \"Helvetica, 32\"" << endl;
    ss_gnuplot << "set xlabel 'energy (eV)' offset graph 0.00" << endl;
    ss_gnuplot << "set ylabel 'peDOS (states/eV)' offset graph 0.00" << endl;
    ss_gnuplot << "set label '{/Helvetica-Oblique E}_F'  at 0.05, graph 0.95" << endl;
    ss_gnuplot << "set arrow from 0, 0 to first 0, graph 1 nohead lt 1 lc rgb '#0000FF' lw 10" << endl; //CO20170830 - originally lt 3 lw 1.5
    ss_gnuplot << "set arrow from 0, 0 to first 0, graph 0 nohead lt 3 lc rgb '#0000FF' lw 10" << endl; //CO20170830 - originally lt 3 lw 1.5
    ss_gnuplot << endl;
    ss_gnuplot << "plot[][] \\" << endl;
    if(PDOS[Natom_pdos].at(0).size()==4) { // Only works for s, p and d orbitals  
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
    }
    if(PDOS[Natom_pdos].at(0).size()==5) { // Works for s, p, d and f orbitals    
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}', \\" << endl;
    }
    if(PDOS[Natom_pdos].at(0).size()==7) { // Spin polarized, only works for s, p and d orbitals  
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:6 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:7 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
    }
    if(PDOS[Natom_pdos].at(0).size()==9) { // Spin polarized, only works for s, p, d and f orbitals  
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:6 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:7 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:8 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:9 w l lt 1 lc rgb '#8172B2' lw 6 notitle, \\" << endl;
    }
    if(PDOS[Natom_pdos].at(0).size()==10) { // Only works for s, p and d orbitals; Non-spin-polarized  
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}_y', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique p}_z', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique p}_x', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:6 w l lt 1 lc rgb '#CCB974' lw 6 title '{/Helvetica-Oblique d}_{xy}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:7 w l lt 1 lc rgb '#64B5CD' lw 6 title '{/Helvetica-Oblique d}_{yz}', \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:8 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique d}_{z^2}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:9 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique d}_{xz}', \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:10 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}_{x^2-y^2}',\\" << endl;
    }
    if(PDOS[Natom_pdos].at(0).size()==17) { // Only works for s, p and d orbitals; Non-spin-polarized  
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}_y', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique p}_z', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique p}_x', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:6 w l lt 1 lc rgb '#CCB974' lw 6 title '{/Helvetica-Oblique d}_{xy}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:7 w l lt 1 lc rgb '#64B5CD' lw 6 title '{/Helvetica-Oblique d}_{yz}', \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:8 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique d}_{z^2}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:9 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique d}_{xz}', \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:10 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}_{x^2-y^2}',\\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:11 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}_1', \\" << endl; //CO20170830 - originally lw 12 (why?)
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:12 w l lt 1 lc rgb '#CCB974' lw 6 title '{/Helvetica-Oblique f}_2', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:13 w l lt 1 lc rgb '#64B5CD' lw 6 title '{/Helvetica-Oblique f}_3', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:14 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique f}_4', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:15 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique f}_5', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:16 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique f}_6', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:17 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}_7' " << endl;
    }
    if(PDOS[Natom_pdos].at(0).size()==19) { // Only works for s, p and d orbitals; Spin-polarized  
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}_y', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:6 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique p}_z', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:7 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:8 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique p}_x', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:9 w l lt 1 lc rgb '#8172B2' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:10 w l lt 1 lc rgb '#CCB974' lw 6 title '{/Helvetica-Oblique d}_{xy}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:11 w l lt 1 lc rgb '#CCB974' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:12 w l lt 1 lc rgb '#64B5CD' lw 6 title '{/Helvetica-Oblique d}_{yz}', \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:13 w l lt 1 lc rgb '#64B5CD' lw 6 notitle, \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:14 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique d}_{z^2}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:15 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:16 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique d}_{xz}', \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:17 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:18 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}_{x^2-y^2}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:19 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
    }
    if(PDOS[Natom_pdos].at(0).size()==33) { // Spin-polarized, s, p, d, f...
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}_y', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:6 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique p}_z', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:7 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:8 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique p}_x', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:9 w l lt 1 lc rgb '#8172B2' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:10 w l lt 1 lc rgb '#CCB974' lw 6 title '{/Helvetica-Oblique d}_{xy}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:11 w l lt 1 lc rgb '#CCB974' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:12 w l lt 1 lc rgb '#64B5CD' lw 6 title '{/Helvetica-Oblique d}_{yz}', \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:13 w l lt 1 lc rgb '#64B5CD' lw 6 notitle, \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:14 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique d}_{z^2}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:15 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:16 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique d}_{xz}', \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:17 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\"  << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:18 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}_{x^2-y^2}', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:19 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:20 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}_1', \\" << endl; //CO20170830 - originally lw 12 (why?)
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:21 w l lt 1 lc rgb '#8172B2' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:22 w l lt 1 lc rgb '#CCB974' lw 6 title '{/Helvetica-Oblique f}_2', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:23 w l lt 1 lc rgb '#CCB974' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:24 w l lt 1 lc rgb '#64B5CD' lw 6 title '{/Helvetica-Oblique f}_3', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:25 w l lt 1 lc rgb '#64B5CD' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:26 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique f}_4', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:27 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:28 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique f}_5', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:29 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:30 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique f}_6', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:31 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:32 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}_7', \\" << endl;
      ss_gnuplot << "\"" << pdosdatafile << "\"" << " u 1:33 w l lt 1 lc rgb '#8172B2' lw 6 notitle " << endl;
    }

    ss_gnuplot << endl;
    return ss_gnuplot.str();
  }
} // namespace estructure

// ***************************************************************************
// estructure::PLOT_DOS(string options)
// ***************************************************************************
namespace estructure {
  void PLOT_DOS(string options) {
    //Generate DOS plot using GNUPLOT
    //Usage: aflow --plotdos[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]
    //The following files must reside in the directory
    //  DOSCAR.static
    //  OUTCAR.static

    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::PLOT_DOS():";
    if(LDEBUG) cerr << function_name << " BEGIN" << endl;

    vector<string> tokens;
    aurostd::string2tokens(options,tokens,",");
    double DOS_Emin=DEFAULT_DOS_EMIN,DOS_Emax=DEFAULT_DOS_EMAX,DOSSCALE=DEFAULT_DOS_SCALE;  // some defaults

    if(LDEBUG) cerr << function_name << " options=[" << options << "]" << endl;
    if(LDEBUG) cerr << function_name << " tokens.size()=" << tokens.size() << endl;
    if(LDEBUG) for(uint i=0;i<tokens.size();i++) cerr << function_name << " tokens.at(i)=" << tokens.at(i) << endl;

    double DOSMAX=0.0;
    string directory="./", ICSDName, DOSCARfile, OUTCARfile,  stmp, line;
    stringstream straus, strline, dosfile, ss_outcar, ss_doscar; //, stringstreamtmp, strline;  

    if(tokens.size()<1) {
      init::ErrorOption(options,function_name,"aflow --plotdos[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]");
    }
    if(tokens.size()>=1) directory = tokens.at(0);
    if(tokens.size()>=2) DOS_Emin = aurostd::string2utype<double>(tokens.at(1)); 
    if(tokens.size()>=3) DOS_Emax = aurostd::string2utype<double>(tokens.at(2));
    if(tokens.size()>=4) DOSSCALE = aurostd::string2utype<double>(tokens.at(3));

    if(LDEBUG) cerr << function_name << " directory=[" << directory << "]" << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emin=" << DOS_Emin << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emax=" << DOS_Emax << endl;
    if(LDEBUG) cerr << function_name << " DOSSCALE=" << DOSSCALE << endl;

    cout << function_name << " working in directory=" << directory << endl;

    ICSDName=KBIN::ExtractSystemName(directory); //Get SystemName

    //READ OUTCAR, get the number of IONS, Fermi Level  
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    xOUTCAR pedos_outcar; pedos_outcar.GetPropertiesFile(aflowlib::vaspfile2stringstream(directory,"OUTCAR"));

    aflowlib::vaspfile2stringstream(directory, "DOSCAR", ss_doscar);
    vector<vector<double> > TDOS;
    vector<vector<double> >  TOTALPDOS;
    double Efermi;
    //CO20180216 - this function needs PDOS
    if(!(estructure::GET_DOS_DATA(ss_doscar, ss_outcar, Efermi, TDOS, TOTALPDOS) && TOTALPDOS.size()>0)){
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"DOSCAR extraction failed, perhaps there is no PDOS",_INPUT_MISSING_);
    }

    vector<vector<double> > vvDOS;
    CombineTDOSAndTOTALPDOS(TDOS, TOTALPDOS, vvDOS);
    DOSMAX = aurostd::FindMaxIn2DvectorExcept1stColumn(vvDOS, DOS_Emin, DOS_Emax);

    //Wringting dosdata into file
    string str_dos = aurostd::vector2string(vvDOS);
    string dosdatafile = ICSDName + "_DOS.dat";
    ofstream fin;
    fin.open(dosdatafile.c_str());
    fin << str_dos;
    fin.close();

    //***********************************GENERATING GNUPLOT SCRIPT**************************************************************

    //Writing Gnuplot Script
    string gnuplotscript = aurostd::ProperFileName("GNUPLOT_" + ICSDName + "_DOS.gp");
    //////ofstream fin;
    fin.open(gnuplotscript.c_str());
    fin << "#Generated by AFLOW (Kesong Yang [kesong.yang@gmail.com], 2011, Duke) University" << endl;
    fin << "set term postscript eps enhanced color font \"Helvetica, 40\" size 18, 10.125" << endl;
    fin << "set output " << "\"" << ICSDName <<"_DOS.eps" << "\"" << endl;
    fin << "set title \"" << estructure::changeICSDNameGunplot(ICSDName) << "\""<< endl;
    //fin << "set border lw 5" << endl; //CO20170830 - thick border
    fin << "unset border" << endl; //CO20170830 - looks better
    fin << "set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb '#E4E4E4' behind fs noborder" << endl;  //CO20170830 - gray background
    fin << "set grid back lt 1 lc rgb 'white' lw 5" << endl; //CO20170830 - white grid
    fin << endl;

    fin << "#DOS PLOT" << endl;
    fin << "set xtics 2" << endl;
    fin << "set ytics" << endl;
    fin << "set xrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
    if(TOTALPDOS.at(0).size()==9||(TOTALPDOS.at(0).size()==7)) { 	
      if(DOSMAX*DOSSCALE!=0) {
        fin << "set yrange [" << DOSMAX*DOSSCALE*(-1) <<":"  << DOSMAX*DOSSCALE << "]" << endl;
      }
      else {
        fin << "set yrange [0:2]" << endl;
      }
    }
    if(TOTALPDOS.at(0).size()==4||(TOTALPDOS.at(0).size()==5)) {
      if(DOSMAX*DOSSCALE!=0) {
        fin << "set yrange [0:" << DOSMAX*DOSSCALE << "]" << endl;
      }
    }
    fin << endl;
    fin << "set label '" << AFLOWLIB_CONSORTIUM_STRING << "' at screen 0.70, 0.02 font \"Helvetica, 32\"" << endl;
    fin << "set xlabel 'energy (eV)' offset graph 0.00" << endl;
    fin << "set ylabel 'eDOS (states/eV)' offset graph 0.00" << endl;
    fin << "set label '{/Helvetica-Oblique E}_F' at 0.05, graph 0.95" << endl;
    fin << "set arrow from 0, 0 to first 0, graph 1 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
    fin << "set arrow from 0, 0 to first 0, graph 0 nohead lt 3 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
    fin << endl;
    fin << "plot[][] \\" << endl;
    if(TOTALPDOS.at(0).size()==4) { // Only works for s, p and d orbitals	a
      fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:5 w l lt -1 lw 6 title 'total'" << endl;
    }
    if(TOTALPDOS.at(0).size()==5) { // Works for s, p, d and f orbitals	
      fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:6 w l lt -1 lw 6 title 'total'" << endl;
    }
    if(TOTALPDOS.at(0).size()==7) { // Only works for s, p and d orbitals; Spin-polarized	
      fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:6 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:7 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:8 w l lt -1 lw 6 title 'total', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:9 w l lt -1 lw 6 notitle" << endl;
    }
    if(TOTALPDOS.at(0).size()==9) { // Only works for s, p, d and f orbitals; Spin-polarized	
      fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:6 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:7 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:8 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:9 w l lt 1 lc rgb '#8172B2' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:10 w l lt -1 lw 6 title 'total', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 1:11 w l lt -1 lw 6 notitle" << endl;
    }
    fin << endl;
    fin << endl;
    fin.close();

    //Call gnuplot to plot the bands structure	
    aurostd::execute(XHOST.command("gnuplot")+" " + gnuplotscript);
    aurostd::execute(XHOST.command("convert")+" -background white ./" + ICSDName + "_DOS.eps ./" + ICSDName + "_DOS.png");

    //Postprocess
    if(!XHOST.vflag_control.flag("KEEP::GPL")) {
      aurostd::RemoveFile(dosdatafile); //Delete the dosdatafile
      aurostd::RemoveFile(gnuplotscript); //Delete the gnuplotscript to avoid sb. delte the AFLOW label in the eps
    }
    // aurostd::RemoveFile(ICSDName + "_DOS.eps"); // [CORMAC]
    if(aurostd::FileExist(ICSDName+"_DOS.eps"))  aurostd::execute(DEFAULT_KZIP_BIN+" -9f " + ICSDName + "_DOS.eps"); // [CORMAC]
    if(LDEBUG) cerr << function_name << " END" << endl;
  }
}

// ***************************************************************************
// estructure::PLOT_DOSWEB(string options)
// ***************************************************************************
namespace estructure {
  void PLOT_DOSWEB(string options) {
    //Generate DOS plot using GNUPLOT
    //Usage: aflow --plotdosweb[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]

    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::PLOT_DOSWEB():";
    stringstream message;
    bool isLSCOUPLING=FALSE;
    int DOSGRID, NIONS;
    double Efermi, Emax, Emin;
    double DOSMAX=0.0;
    string directory="./", ICSDName="AFLOW_DOS_WEB",  stmp, line;
    stringstream straus, strline, dosfile; //, stringstreamtmp, strline;  

    if(LDEBUG) cerr << function_name << " BEGIN" << endl;

    vector<string> tokens;
    aurostd::string2tokens(options,tokens,",");
    double DOS_Emin=DEFAULT_DOS_EMIN,DOS_Emax=DEFAULT_DOS_EMAX,DOSSCALE=DEFAULT_DOS_SCALE;  // some defaults

    if(LDEBUG) cerr << function_name << " options=[" << options << "]" << endl;
    if(LDEBUG) cerr << function_name << " tokens.size()=" << tokens.size() << endl;
    if(LDEBUG) for(uint i=0;i<tokens.size();i++) cerr << function_name << " tokens.at(i)=" << tokens.at(i) << endl;

    if(tokens.size()<1) {
      init::ErrorOption(options,function_name,"aflow --plotdosweb[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]");
    }
    if(tokens.size()>=1) directory = tokens.at(0);
    if(tokens.size()>=2) DOS_Emin = aurostd::string2utype<double>(tokens.at(1)); 
    if(tokens.size()>=3) DOS_Emax = aurostd::string2utype<double>(tokens.at(2));
    if(tokens.size()>=4) DOSSCALE = aurostd::string2utype<double>(tokens.at(3));

    if(LDEBUG) cerr << function_name << " directory=[" << directory << "]" << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emin=" << DOS_Emin << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emax=" << DOS_Emax << endl;
    if(LDEBUG) cerr << function_name << " DOSSCALE=" << DOSSCALE << endl;

    cout << function_name << " working in directory=" << directory << endl;

    //READ DOSCAR.static
    bool found=FALSE;

    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(!found&&aurostd::FileExist(directory+"/DOSCAR.static"+XHOST.vext.at(iext)))
        found=aurostd::efile2stringstream(directory+"/DOSCAR.static"+XHOST.vext.at(iext),dosfile);
    }
    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(!found&&aurostd::FileExist(directory+"/DOSCAR"+XHOST.vext.at(iext)))
        found=aurostd::efile2stringstream(directory+"/DOSCAR"+XHOST.vext.at(iext),dosfile);
    }

    if(!found) {
      message << "DOSCAR[.static][.EXT] not found in the directory, aborting.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_FILE_NOT_FOUND_);
    }

    int TotalNumberDOSCAR = aurostd::GetNLinesString(dosfile);
    // int TotalNumberDOSCAR = aurostd::CountofLinesinFile(DOSCARfile);

    for (int i=0; i<4; i++) getline(dosfile, stmp);
    dosfile >> stmp; getline(dosfile, stmp);
    dosfile >> Emax >> Emin >> DOSGRID >> Efermi >> stmp; getline(dosfile, stmp);

    if(TotalNumberDOSCAR < DOSGRID) {
      message << "TotalNumberDOSCAR (" << TotalNumberDOSCAR << ") is less than the DOSGRID (" << DOSGRID << ").";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_VALUE_RANGE_);
    }
    bool FLAG_PDOS = false;
    NIONS = (int (TotalNumberDOSCAR-5)/(DOSGRID+1))-1;
    if(NIONS>1) FLAG_PDOS = true;

    //----------------------GETTING TDOS DATA-----------------------
    vector<vector<double> > TDOS(DOSGRID);
    getline(dosfile, line);

    //Dealing with spin-polarized calculations
    if(aurostd::CountWordsinString_web(line)==5) {
      for (int i=0; i<DOSGRID; i++) {
        TDOS[i].resize(5);
      }
      strline.clear();
      strline.str(line);
      strline >> TDOS[0][0]; //Energy
      strline >> TDOS[0][1] >> TDOS[0][2]; //Spin_up & Spin_dn
      strline >> TDOS[0][3] >> TDOS[0][4]; //Sum_up & Sum_dn
      for (int j=1; j<DOSGRID; j++) {
        dosfile >> TDOS[j][0]; //Energy
        dosfile >> TDOS[j][1] >> TDOS[j][2]; //Spin_up & Spin_dn
        dosfile >> TDOS[j][3] >> TDOS[j][4]; //Sum_up & Sum_dn
        getline(dosfile, stmp);
      }	
    }

    //Notes: TDOS[j][0] stores the Energy, TDOS[j][1] stores the spinup, TDOS[j][2] stores the spindown, TDOS[j][3] stores the integral of spinup ...

    //Dealing with non-spin-polarized calculations
    if(aurostd::CountWordsinString_web(line)==3) {
      for (int i=0; i<DOSGRID; i++) {
        TDOS[i].resize(3);
      }
      strline.clear();
      strline.str(line);
      strline >> TDOS[0][0]; //Energy
      strline >> TDOS[0][1]; //DOS
      strline >> TDOS[0][2]; //Sum
      for (int j=1; j<DOSGRID; j++) {
        dosfile >> TDOS[j][0];
        dosfile >> TDOS[j][1];
        dosfile >> TDOS[j][2];
        getline(dosfile, stmp);
      }	
    }
    //-------------------------------------------------------------------------------------------------------------------------------------------------
    if(FLAG_PDOS) {
      //************************************************************************************************************************
      //Get PDOS
      //************************************************************************************************************************
      //----------------------GETTING PDOS DATA-------------------------
      vector<vector<vector<double> > > PDOS(NIONS);
      getline(dosfile, line); //Negelecting the title line after the TDOS
      getline(dosfile, line); //Read the 1st line of PDOS
      int Ncolumns;
      Ncolumns=aurostd::CountWordsinString_web(line);

      //--------------------s, p , d-----------------------
      if(Ncolumns==4) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(4);
        }
        //Storing the DOSDATA of the 1st atom	
        strline.clear();
        strline.str(line);
        strline >> PDOS[0][0][0]; //Energy
        strline >> PDOS[0][0][1]; //s
        strline >> PDOS[0][0][2]; //p
        strline >> PDOS[0][0][3]; //d
        for (int j=1; j<DOSGRID; j++) {
          //                dosfile >> PDOS[0][j][0] >> PDOS[0][j][1] >> PDOS[0][j][2] >> PDOS[0][j][3];
          dosfile >> PDOS[0][j][0];
          dosfile >> PDOS[0][j][1];
          dosfile >> PDOS[0][j][2];
          dosfile >> PDOS[0][j][3];
          getline(dosfile, stmp);
        }

        //Storing the DOSDATA of the left atoms	
        for (int i=1; i<NIONS; i++) {
          getline(dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            dosfile >> PDOS[i][j][0];
            dosfile >> PDOS[i][j][1];
            dosfile >> PDOS[i][j][2];
            dosfile >> PDOS[i][j][3];
            getline(dosfile, stmp);
          }
        }	
      }
      //--------------------s, p , d-----------------------

      //--------------------s, p , d, f-----------------------
      if(Ncolumns==5) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(5);
        }
        //Storing the DOSDATA of the 1st atom	
        strline.clear();
        strline.str(line);
        strline >> PDOS[0][0][0];
        strline >> PDOS[0][0][1];
        strline >> PDOS[0][0][2];
        strline >> PDOS[0][0][3];
        strline >> PDOS[0][0][4];
        for (int j=1; j<DOSGRID; j++) {
          dosfile >> PDOS[0][j][0];
          dosfile >> PDOS[0][j][1];
          dosfile >> PDOS[0][j][2];
          dosfile >> PDOS[0][j][3];
          dosfile >> PDOS[0][j][4];
          getline(dosfile, stmp);
        }

        //Storing the DOSDATA of the left atoms	
        for (int i=1; i<NIONS; i++) {
          getline(dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            dosfile >> PDOS[i][j][0];
            dosfile >> PDOS[i][j][1];
            dosfile >> PDOS[i][j][2];
            dosfile >> PDOS[i][j][3];
            dosfile >> PDOS[i][j][4];
            getline(dosfile, stmp);
          }
        }	
      }
      //--------------------s, p , d, f-----------------------
      //--------------------s, p , d (spin-polarized)-----
      if(Ncolumns==7) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(7);
        }
        //Storing the DOSDATA of the 1st atom	
        strline.clear();
        strline.str(line);
        //            strline >> PDOS[0][0][0] >> PDOS[0][0][1] >> PDOS[0][0][2] >> PDOS[0][0][3] >> PDOS[0][0][4] >> PDOS[0][0][5] >> PDOS[0][0][6];
        strline >> PDOS[0][0][0];  //Energy
        strline >> PDOS[0][0][1] >> PDOS[0][0][2]; //s
        strline >> PDOS[0][0][3] >> PDOS[0][0][4]; //p
        strline >> PDOS[0][0][5] >> PDOS[0][0][6]; //d
        for (int j=1; j<DOSGRID; j++) {
          dosfile >> PDOS[0][j][0];
          dosfile >> PDOS[0][j][1] >> PDOS[0][j][2]; //s
          dosfile >> PDOS[0][j][3] >> PDOS[0][j][4]; //p
          dosfile >> PDOS[0][j][5] >> PDOS[0][j][6]; //d
          getline(dosfile, stmp);
        }
        //Storing the DOSDATA of the left atoms	
        for (int i=1; i<NIONS; i++) {
          getline(dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            dosfile >> PDOS[i][j][0];
            dosfile >> PDOS[i][j][1] >> PDOS[i][j][2]; //s
            dosfile >> PDOS[i][j][3] >> PDOS[i][j][4]; //p
            dosfile >> PDOS[i][j][5] >> PDOS[i][j][6]; //d
            getline(dosfile, stmp);
          }
        }	
      }

      //--------------------s, p , d , f(spin-polarized)-----
      if(Ncolumns==9) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(9);
        }
        //Storing the DOSDATA of the 1st atom	
        strline.clear();
        strline.str(line);
        strline >> PDOS[0][0][0];
        strline >> PDOS[0][0][1] >> PDOS[0][0][2]; //s
        strline >> PDOS[0][0][3] >> PDOS[0][0][4]; //p
        strline >> PDOS[0][0][5] >> PDOS[0][0][6]; //d
        strline >> PDOS[0][0][7] >> PDOS[0][0][8]; //f
        for (int j=1; j<DOSGRID; j++) {
          dosfile >> PDOS[0][j][0];
          dosfile >> PDOS[0][j][1] >> PDOS[0][j][2];
          dosfile >> PDOS[0][j][3] >> PDOS[0][j][4];
          dosfile >> PDOS[0][j][5] >> PDOS[0][j][6];
          dosfile >> PDOS[0][j][7] >> PDOS[0][j][8];
          getline(dosfile, stmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(dosfile, line);
          //cout << line << "hi" << endl;
          for (int j=0; j<DOSGRID; j++) {
            dosfile >> PDOS[i][j][0];
            dosfile >> PDOS[i][j][1] >> PDOS[i][j][2];
            dosfile >> PDOS[i][j][3] >> PDOS[i][j][4];
            dosfile >> PDOS[i][j][5] >> PDOS[i][j][6];
            dosfile >>PDOS[i][j][7] >> PDOS[i][j][8];
            getline(dosfile, stmp);
          }
        }	
      }
      //--------------------s, p , d (spin-polarized)-----

      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2 (non-spin-polarized)-----
      if(Ncolumns==10) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(10);
        }
        //Storing the DOSDATA of the 1st atom	
        strline.clear();
        strline.str(line);
        strline >> PDOS[0][0][0]; //Energy
        strline >> PDOS[0][0][1]; //s
        strline >> PDOS[0][0][2] >> PDOS[0][0][3] >> PDOS[0][0][4]; //py, pz, px
        strline >> PDOS[0][0][5] >> PDOS[0][0][6] >> PDOS[0][0][7] >> PDOS[0][0][8] >> PDOS[0][0][9]; //dxy, dyz, dz2, dxz, dx2-y2
        for (int j=1; j<DOSGRID; j++) {
          dosfile >> PDOS[0][j][0];
          dosfile >> PDOS[0][j][1];
          dosfile >> PDOS[0][j][2] >> PDOS[0][j][3] >> PDOS[0][j][4];
          dosfile >> PDOS[0][j][5] >> PDOS[0][j][6] >> PDOS[0][0][7] >> PDOS[0][0][8] >> PDOS[0][0][9];
          getline(dosfile, stmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            dosfile >> PDOS[i][j][0];
            dosfile >> PDOS[i][j][1];
            dosfile >> PDOS[i][j][2] >> PDOS[i][j][3] >> PDOS[i][j][4];
            dosfile >> PDOS[i][j][5] >> PDOS[i][j][6] >> PDOS[i][j][7] >> PDOS[i][j][8] >> PDOS[i][j][9];
            getline(dosfile, stmp);
          }
        }	
      }
      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2 (non-spin-polarized)-----

      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... (LS COUPLINT)------------
      if(Ncolumns==13) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(13);
        }
        //Storing the DOSDATA of the 1st atom	
        strline.clear();
        strline.str(line);
        strline >> PDOS[0][0][0]; //Energy
        strline >> PDOS[0][0][1] >> PDOS[0][0][2] >> PDOS[0][0][3] >> PDOS[0][0][4]; //stotal, sx, sy, sz
        strline >> PDOS[0][0][5] >> PDOS[0][0][6] >> PDOS[0][0][7] >> PDOS[0][0][8]; //ptotal, px, py, pz
        strline >> PDOS[0][0][9] >> PDOS[0][0][10] >> PDOS[0][0][11] >> PDOS[0][0][12]; //dtotal, dx, dy, dz
        for (int j=1; j<DOSGRID; j++) {
          dosfile >> PDOS[0][j][0];
          dosfile >> PDOS[0][j][1] >> PDOS[0][j][2] >> PDOS[0][j][3] >> PDOS[0][j][4];
          dosfile >> PDOS[0][j][5] >> PDOS[0][j][6] >> PDOS[0][j][7] >> PDOS[0][j][8];
          dosfile >> PDOS[0][j][9] >> PDOS[0][j][10] >> PDOS[0][j][11] >> PDOS[0][j][12];
          getline(dosfile, stmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            dosfile >> PDOS[i][j][0]; //Energy
            dosfile >> PDOS[i][j][1] >> PDOS[i][j][2] >> PDOS[i][j][3] >> PDOS[i][j][4];
            dosfile >> PDOS[i][j][5] >> PDOS[i][j][6] >> PDOS[i][j][7] >> PDOS[i][j][8];
            dosfile >> PDOS[i][j][9] >> PDOS[i][j][10] >> PDOS[i][j][11] >> PDOS[i][j][12];
            getline(dosfile, stmp);
          }
        }	
      }
      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... (LS COUPLINT)------------

      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... ftotal, fx, fy, fz (LS COUPLINT)------------
      if(Ncolumns==17) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(17);
        }
        //Storing the DOSDATA of the 1st atom	
        strline.clear();
        strline.str(line);
        strline >> PDOS[0][0][0]; //Energy
        strline >> PDOS[0][0][1] >> PDOS[0][0][2] >> PDOS[0][0][3] >> PDOS[0][0][4]; //s
        strline >> PDOS[0][0][5] >> PDOS[0][0][6] >> PDOS[0][0][7] >> PDOS[0][0][8]; //p
        strline >> PDOS[0][0][9] >> PDOS[0][0][10] >> PDOS[0][0][11] >> PDOS[0][0][12]; //d
        strline >> PDOS[0][0][13] >> PDOS[0][0][14] >> PDOS[0][0][15] >> PDOS[0][0][16]; //f
        for (int j=1; j<DOSGRID; j++) {
          dosfile >> PDOS[0][j][0];
          dosfile >> PDOS[0][j][1] >> PDOS[0][j][2] >> PDOS[0][j][3] >> PDOS[0][j][4];
          dosfile >> PDOS[0][j][5] >> PDOS[0][j][6] >> PDOS[0][j][7] >> PDOS[0][j][8];
          dosfile >> PDOS[0][j][9] >> PDOS[0][j][10] >> PDOS[0][j][11] >> PDOS[0][j][12];
          dosfile >> PDOS[0][j][13] >> PDOS[0][j][14] >>PDOS[0][j][15] >> PDOS[0][j][16];
          getline(dosfile, stmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            dosfile >> PDOS[i][j][0];
            dosfile >> PDOS[i][j][1] >> PDOS[i][j][2] >> PDOS[i][j][3] >> PDOS[i][j][4];
            dosfile >> PDOS[i][j][5] >> PDOS[i][j][6] >> PDOS[i][j][7] >> PDOS[i][j][8];
            dosfile >> PDOS[i][j][9] >> PDOS[i][j][10] >> PDOS[i][j][11] >> PDOS[i][j][12];
            dosfile >> PDOS[i][j][13] >> PDOS[i][j][14] >> PDOS[i][j][15] >> PDOS[i][j][16];
            getline(dosfile, stmp);
          }
        }	
      }
      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... ftotal, fx, fy, fz (LS COUPLINT)------------

      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn (spin-polarized)-----
      if(Ncolumns==19) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(19);
        }
        //Storing the DOSDATA of the 1st atom	
        //
        //KY UNFISNISHED
        strline.clear();
        strline.str(line);
        strline >> PDOS[0][0][0]; //Energy
        strline >> PDOS[0][0][1] >> PDOS[0][0][2]; //s_up & s_dn
        strline >> PDOS[0][0][3] >> PDOS[0][0][4]; //py_up & py_dn
        strline >> PDOS[0][0][5] >> PDOS[0][0][6]; //pz_up & pz_dn
        strline >> PDOS[0][0][7] >> PDOS[0][0][8]; //px_up & px_dn
        strline >> PDOS[0][0][9] >> PDOS[0][0][10]; //dxy_up & dxy_dn
        strline >> PDOS[0][0][11] >> PDOS[0][0][12]; //dyz_up & dyz_dn
        strline >> PDOS[0][0][13] >> PDOS[0][0][14]; //dz2_up & dz2_dn
        strline >> PDOS[0][0][15] >> PDOS[0][0][16]; //dxz_up & dxz_dn
        strline >> PDOS[0][0][17] >> PDOS[0][0][18]; //dx2-y2_up & dx2-y2_dn
        for (int j=1; j<DOSGRID; j++) {
          dosfile >> PDOS[0][j][0];
          dosfile >> PDOS[0][j][1] >> PDOS[0][j][2];
          dosfile >> PDOS[0][j][3] >> PDOS[0][j][4];
          dosfile >> PDOS[0][j][5] >> PDOS[0][j][6];
          dosfile >> PDOS[0][0][7] >> PDOS[0][0][8];
          dosfile >> PDOS[0][0][9] >> PDOS[0][0][10];
          dosfile >> PDOS[0][0][11] >> PDOS[0][0][12];
          dosfile >> PDOS[0][0][13] >> PDOS[0][0][14];
          dosfile >> PDOS[0][0][15] >> PDOS[0][0][16];
          dosfile >> PDOS[0][0][17] >> PDOS[0][0][18];
          getline(dosfile, stmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            dosfile >> PDOS[i][j][0];
            dosfile >> PDOS[i][j][1] >> PDOS[i][j][2];
            dosfile >> PDOS[i][j][3] >> PDOS[i][j][4];
            dosfile >> PDOS[i][j][5] >> PDOS[i][j][6];
            dosfile >> PDOS[i][j][7] >> PDOS[i][j][8];
            dosfile >> PDOS[i][j][9] >> PDOS[i][j][10];
            dosfile >> PDOS[i][j][11] >> PDOS[i][j][12];
            dosfile >> PDOS[i][j][13] >> PDOS[i][j][14];
            dosfile >> PDOS[i][j][15] >> PDOS[i][j][16];
            dosfile >> PDOS[i][j][17] >> PDOS[i][j][18];
            getline(dosfile, stmp);
          }
        }	
      }
      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn, f1, f2, f3, f4, f5, f6, f7 (spin-polarized)-----
      if(Ncolumns==33) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(33);
        }
        //Storing the DOSDATA of the 1st atom	
        //
        //KY UNFISNISHED
        strline.clear();
        strline.str(line);
        strline >> PDOS[0][0][0]; //Energy
        strline >> PDOS[0][0][1] >> PDOS[0][0][2]; //s_up & s_dn
        strline >> PDOS[0][0][3] >> PDOS[0][0][4]; //py_up & py_dn
        strline >> PDOS[0][0][5] >> PDOS[0][0][6]; //pz_up & pz_dn
        strline >> PDOS[0][0][7] >> PDOS[0][0][8]; //px_up & px_dn
        strline >> PDOS[0][0][9] >> PDOS[0][0][10]; //dxy_up & dxy_dn
        strline >> PDOS[0][0][11] >> PDOS[0][0][12]; //dyz_up & dyz_dn
        strline >> PDOS[0][0][13] >> PDOS[0][0][14]; //dz2_up & dz2_dn
        strline >> PDOS[0][0][15] >> PDOS[0][0][16]; //dxz_up & dxz_dn
        strline >> PDOS[0][0][17] >> PDOS[0][0][18]; //dx2-y2_up & dx2-y2_dn
        strline >> PDOS[0][0][19] >> PDOS[0][0][20]; //f1_up & f1_dn
        strline >> PDOS[0][0][21] >> PDOS[0][0][22]; //f2_up & f2_dn
        strline >> PDOS[0][0][23] >> PDOS[0][0][24]; //f3_up & f3_dn
        strline >> PDOS[0][0][25] >> PDOS[0][0][26]; //f4_up & f4_dn
        strline >> PDOS[0][0][27] >> PDOS[0][0][28]; //f5_up & f5_dn
        strline >> PDOS[0][0][29] >> PDOS[0][0][30]; //f6_up & f6_dn
        strline >> PDOS[0][0][31] >> PDOS[0][0][32]; //f7_up & f7_dn
        for (int j=1; j<DOSGRID; j++) {
          dosfile >> PDOS[0][j][0];
          dosfile >> PDOS[0][j][1] >> PDOS[0][j][2];
          dosfile >> PDOS[0][j][3] >> PDOS[0][j][4];
          dosfile >> PDOS[0][j][5] >> PDOS[0][j][6];
          dosfile >> PDOS[0][j][7] >> PDOS[0][j][8];
          dosfile >> PDOS[0][j][9] >> PDOS[0][j][10];
          dosfile >> PDOS[0][j][11] >> PDOS[0][j][12];
          dosfile >> PDOS[0][j][13] >> PDOS[0][j][14];
          dosfile >> PDOS[0][j][15] >> PDOS[0][j][16];
          dosfile >> PDOS[0][j][17] >> PDOS[0][j][18];
          dosfile >> PDOS[0][j][19] >> PDOS[0][j][20]; //f1_up & f1_dn
          dosfile >> PDOS[0][j][21] >> PDOS[0][j][22]; //f2_up & f2_dn
          dosfile >> PDOS[0][j][23] >> PDOS[0][j][24]; //f3_up & f3_dn
          dosfile >> PDOS[0][j][25] >> PDOS[0][j][26]; //f4_up & f4_dn
          dosfile >> PDOS[0][j][27] >> PDOS[0][j][28]; //f5_up & f5_dn
          dosfile >> PDOS[0][j][29] >> PDOS[0][j][30]; //f6_up & f6_dn
          dosfile >> PDOS[0][j][31] >> PDOS[0][j][32]; //f7_up & f7_dn
          getline(dosfile, stmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            dosfile >> PDOS[i][j][0];
            dosfile >> PDOS[i][j][1] >> PDOS[i][j][2];
            dosfile >> PDOS[i][j][3] >> PDOS[i][j][4];
            dosfile >> PDOS[i][j][5] >> PDOS[i][j][6];
            dosfile >> PDOS[i][j][7] >> PDOS[i][j][8];
            dosfile >> PDOS[i][j][9] >> PDOS[i][j][10];
            dosfile >> PDOS[i][j][11] >> PDOS[i][j][12];
            dosfile >> PDOS[i][j][13] >> PDOS[i][j][14];
            dosfile >> PDOS[i][j][15] >> PDOS[i][j][16];
            dosfile >> PDOS[i][j][17] >> PDOS[i][j][18];
            dosfile >> PDOS[i][j][19] >> PDOS[i][j][20]; //f1_up & f1_dn
            dosfile >> PDOS[i][j][21] >> PDOS[i][j][22]; //f2_up & f2_dn
            dosfile >> PDOS[i][j][23] >> PDOS[i][j][24]; //f3_up & f3_dn
            dosfile >> PDOS[i][j][25] >> PDOS[i][j][26]; //f4_up & f4_dn
            dosfile >> PDOS[i][j][27] >> PDOS[i][j][28]; //f5_up & f5_dn
            dosfile >> PDOS[i][j][29] >> PDOS[i][j][30]; //f6_up & f6_dn
            dosfile >> PDOS[i][j][31] >> PDOS[i][j][32]; //f7_up & f7_dn
            getline(dosfile, stmp);
          }
        }
      }
      //************************************************************************************************************************

      //Calculating total PDOS of s orbital
      vector<vector<double> > TOTALPDOS(DOSGRID);
      //--------------------s, p , d-----------------------
      if(Ncolumns==4) {
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(4);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s orbitals
            TOTALPDOS[i][2]+=PDOS[j][i][2]; //sum of p orbitals
            TOTALPDOS[i][3]+=PDOS[j][i][3]; //sum of d orbitals
          }
        }
      }
      //--------------------s, p , d-----------------------

      //--------------------s, p , d, f-----------------------
      if(Ncolumns==5) {
        //Storing the DOSDATA of the s , p, d
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(5);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s orbitals
            TOTALPDOS[i][2]+=PDOS[j][i][2]; //sum of p orbitals
            TOTALPDOS[i][3]+=PDOS[j][i][3]; //sum of d orbitals
            TOTALPDOS[i][4]+=PDOS[j][i][4]; //sum of f orbitals
          }
        }
      }
      //--------------------s, p , d, f-----------------------

      //--------------------s, p , d (spin-polarized)-----
      if(Ncolumns==7) {
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(7);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;
          TOTALPDOS[i][2]=0.0;
          TOTALPDOS[i][3]=0.0;
          TOTALPDOS[i][4]=0.0;
          TOTALPDOS[i][5]=0.0;
          TOTALPDOS[i][6]=0.0;
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=PDOS[j][i][2]*(-1); //sum of s_dn
            TOTALPDOS[i][3]+=PDOS[j][i][3]; //sum of p_up
            TOTALPDOS[i][4]+=PDOS[j][i][4]*(-1); //sum of p_dn
            TOTALPDOS[i][5]+=PDOS[j][i][5]; //sum of d_up
            TOTALPDOS[i][6]+=PDOS[j][i][6]*(-1); //sum of d_dn
          }    
        }    
      }

      //--------------------s, p , d (spin-polarized)-----

      //--------------------s, p , d, f(spin-polarized)-----
      if(Ncolumns==9) {
        //Storing the DOSDATA of the s , p, d
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(9);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;
          TOTALPDOS[i][2]=0.0;
          TOTALPDOS[i][3]=0.0;
          TOTALPDOS[i][4]=0.0;
          TOTALPDOS[i][5]=0.0;
          TOTALPDOS[i][6]=0.0;
          TOTALPDOS[i][7]=0.0;
          TOTALPDOS[i][8]=0.0;
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=PDOS[j][i][2]*(-1); //sum of s_dn
            TOTALPDOS[i][3]+=PDOS[j][i][3]; //sum of p_up
            TOTALPDOS[i][4]+=PDOS[j][i][4]*(-1); //sum of p_dn
            TOTALPDOS[i][5]+=PDOS[j][i][5]; //sum of d_up
            TOTALPDOS[i][6]+=PDOS[j][i][6]*(-1); //sum of d_dn
            TOTALPDOS[i][7]+=PDOS[j][i][7]; //sum of f_up
            TOTALPDOS[i][8]+=PDOS[j][i][8]*(-1); //sum of f_dn
          }
        }
      }

      //--------------------s, p , d, f(spin-polarized)-----

      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2 (non-spin-polarized)-----
      if(Ncolumns==10) {
        //Storing the DOSDATA of the s , p, d
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(4);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;  //s
          TOTALPDOS[i][2]=0.0;  //p
          TOTALPDOS[i][3]=0.0;  //d
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=(PDOS[j][i][2]+PDOS[j][i][3]+PDOS[j][i][4]); //sum of py, pz, and px
            TOTALPDOS[i][3]+=(PDOS[j][i][5]+PDOS[j][i][6]+PDOS[j][i][7]+PDOS[j][i][8]+PDOS[j][i][9]); //sum of dxy, dyz, dz2, dxz, dx2-y2
          }
        }
      }
      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2 (non-spin-polarized)-----

      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2, f1, f2, f3, f4, f5, f6, f7 (non-spin-polarized)-----
      if(Ncolumns==17 && (!isLSCOUPLING)) {
        //Storing the DOSDATA of the s , p, d , f
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(5);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;  //s
          TOTALPDOS[i][2]=0.0;  //p
          TOTALPDOS[i][3]=0.0;  //d
          TOTALPDOS[i][4]=0.0;  //f
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=(PDOS[j][i][2]+PDOS[j][i][3]+PDOS[j][i][4]); //sum of py, pz, and px
            TOTALPDOS[i][3]+=(PDOS[j][i][5]+PDOS[j][i][6]+PDOS[j][i][7]+PDOS[j][i][8]+PDOS[j][i][9]); //sum of dxy, dyz, dz2, dxz, dx2-y2
            TOTALPDOS[i][4]+=(PDOS[j][i][10]+PDOS[j][i][11]+PDOS[j][i][12]+PDOS[j][i][13]+PDOS[j][i][14]+PDOS[j][i][15]+PDOS[j][i][16]); //sum of f orbital
          }
        }
      }
      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2, f1, f2, f3, f4, f5, f6, f7 (non-spin-polarized)-----

      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn (spin-polarized)-----
      if(Ncolumns==19) {
        //Storing the DOSDATA of the s , p, d
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(7);
          TOTALPDOS[i][0]=PDOS[0][i][0]; //Energy
          TOTALPDOS[i][1]=0.0;  //s_up
          TOTALPDOS[i][2]=0.0;  //s_dn
          TOTALPDOS[i][3]=0.0;  //p_up
          TOTALPDOS[i][4]=0.0;  //p_dn
          TOTALPDOS[i][5]=0.0;  //d_up
          TOTALPDOS[i][6]=0.0;  //d_dn
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=PDOS[j][i][2]*(-1); //sum of s_dn
            TOTALPDOS[i][3]+=(PDOS[j][i][3]+PDOS[j][i][5]+PDOS[j][i][7]); //sum of p_up // py, pz, and px
            TOTALPDOS[i][4]+=(PDOS[j][i][4]+PDOS[j][i][6]+PDOS[j][i][8])*(-1); //sum of p_dn // py, pz, and px
            TOTALPDOS[i][5]+=(PDOS[j][i][9]+PDOS[j][i][11]+PDOS[j][i][13]+PDOS[j][i][15]+PDOS[j][i][17]); //sum of d_up //dxy, dyz, dz2, dxz, dx2-y2
            TOTALPDOS[i][6]+=(PDOS[j][i][10]+PDOS[j][i][12]+PDOS[j][i][14]+PDOS[j][i][16]+PDOS[j][i][18])*(-1); //sum of d_up //dxy, dyz, dz2, dxz, dx2-y2
          }
        }
      }
      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn (spin-polarized)-----

      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn, (f1, f2, f3...) (spin-polarized)-----
      if(Ncolumns==33) {
        //Storing the DOSDATA of the s , p, d, f
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(9);
          TOTALPDOS[i][0]=PDOS[0][i][0]; //Energy
          TOTALPDOS[i][1]=0.0;  //s_up
          TOTALPDOS[i][2]=0.0;  //s_dn
          TOTALPDOS[i][3]=0.0;  //p_up
          TOTALPDOS[i][4]=0.0;  //p_dn
          TOTALPDOS[i][5]=0.0;  //d_up
          TOTALPDOS[i][6]=0.0;  //d_dn
          TOTALPDOS[i][7]=0.0;  //f_dn
          TOTALPDOS[i][8]=0.0;  //f_dn
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=PDOS[j][i][2]*(-1); //sum of s_dn
            TOTALPDOS[i][3]+=(PDOS[j][i][3]+PDOS[j][i][5]+PDOS[j][i][7]); //sum of p_up // py, pz, and px
            TOTALPDOS[i][4]+=(PDOS[j][i][4]+PDOS[j][i][6]+PDOS[j][i][8])*(-1); //sum of p_dn // py, pz, and px
            TOTALPDOS[i][5]+=(PDOS[j][i][9]+PDOS[j][i][11]+PDOS[j][i][13]+PDOS[j][i][15]+PDOS[j][i][17]); //sum of d_up //dxy, dyz, dz2, dxz, dx2-y2
            TOTALPDOS[i][6]+=(PDOS[j][i][10]+PDOS[j][i][12]+PDOS[j][i][14]+PDOS[j][i][16]+PDOS[j][i][18])*(-1); //sum of d_up //dxy, dyz, dz2, dxz, dx2-y2
            TOTALPDOS[i][7]+=(PDOS[j][i][19]+PDOS[j][i][21]+PDOS[j][i][23]+PDOS[j][i][25]+PDOS[j][i][27]+PDOS[j][i][29]+PDOS[j][i][31]); //sum of f_up
            TOTALPDOS[i][8]+=(PDOS[j][i][20]+PDOS[j][i][22]+PDOS[j][i][24]+PDOS[j][i][26]+PDOS[j][i][28]+PDOS[j][i][30]+PDOS[j][i][32])*(-1); //sum of f_dn
          }
        }
      }
      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn (spin-polarized)-----

      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... (LS COUPLINT)------------
      if(Ncolumns==13 && isLSCOUPLING) {
        //Storing the DOSDATA of the s , p, d
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(4);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;
          TOTALPDOS[i][2]=0.0;
          TOTALPDOS[i][3]=0.0;
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up & s_dn orbitals
            TOTALPDOS[i][2]+=PDOS[j][i][5]; //sum of p_up & p_dn orbitals
            TOTALPDOS[i][3]+=PDOS[j][i][9]; //sum of d_up & d_dn orbitals
          }
        }	
      }
      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... (LS COUPLINT)------------

      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... ftotal ...(LS COUPLINT)------------
      if(Ncolumns==17 && isLSCOUPLING) {
        //Storing the DOSDATA of the s , p, d, f
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(5);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;
          TOTALPDOS[i][2]=0.0;
          TOTALPDOS[i][3]=0.0;
          TOTALPDOS[i][4]=0.0;
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s orbitals
            TOTALPDOS[i][2]+=PDOS[j][i][5]; //sum of p orbitals
            TOTALPDOS[i][3]+=PDOS[j][i][9]; //sum of d orbitals
            TOTALPDOS[i][4]+=PDOS[j][i][13]; //sum of f orbitals
          }
        }	
      }
      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... ftotal ...(LS COUPLINT)------------

      //-------------------------------------------------------------------------------------------------------------------------------------------------
      //-------------------------------------------------------------------------------------------------------------------------------------------------
      //Shifting the Energy to Fermi level
      for (int i=0; i< DOSGRID; i++) {
        TOTALPDOS[i][0]=TOTALPDOS[i][0]-Efermi;
        TDOS[i][0]=TDOS[i][0]-Efermi;
      }

      //Finding the maxmium value of TOTALPDOS including s, p, d or f orbitals
      //-----------------------------------------------------------------------
      for (int i=0; i< DOSGRID; i++) {
        if(TDOS.at(0).size()==3) {
          if(TOTALPDOS[i][0]>=DOS_Emin && TOTALPDOS[i][0]<=DOS_Emax) {
            if(TDOS[i][1]>=DOSMAX) DOSMAX=TDOS[i][1];
          }
        }
        if(TDOS.at(0).size()==5) {
          if(TOTALPDOS[i][0]>=DOS_Emin && TOTALPDOS[i][0]<=DOS_Emax) {
            if(TDOS[i][1]>=DOSMAX) DOSMAX=TDOS[i][1];
            if(TDOS[i][2]>=DOSMAX) DOSMAX=TDOS[i][2];
          }
        }
      }

      //Wringting into file
      string dosdatafile = ICSDName + "_DOS.dat";
      ofstream fin;
      fin.open(dosdatafile.c_str());
      fin.setf(ios_base::fixed,ios_base::floatfield);
      fin.precision(6);
      //Non-spin-polarized calculations  Format: Energy, s, p, d, Total
      if(TOTALPDOS.at(0).size()==4) {	
        for (int i=0; i< DOSGRID; i++) {
          for (int j=0; j<4; j++) {
            fin << TOTALPDOS[i][j] << "  ";
          }
          fin << TDOS[i][1];
          fin << endl;
        }
      }
      //Non-spin-polarized calculations  Format: Energy, s, p, d, f, Total
      else if(TOTALPDOS.at(0).size()==5) {
        for (int i=0; i< DOSGRID; i++) {
          for (int j=0; j<5; j++) {
            fin << TOTALPDOS[i][j] << "  ";
          }
          fin << TDOS[i][1];
          fin << endl;
        }
      }
      //Spin-polarized calculations Format: Energy, s_up, s_dn, p_up, p_dn, d_up, d_dn, Total_up, Total_dn
      else if(TOTALPDOS.at(0).size()==7) {
        for (int i=0; i< DOSGRID; i++) {
          for (int j=0; j<7; j++) {
            fin << TOTALPDOS[i][j] << "  ";
          }
          fin << TDOS[i][1] << "  " << TDOS[i][2]*(-1);
          fin << endl;
        }
      }
      //Spin-polarized calculations Format: Energy, s_up, s_dn, p_up, p_dn, d_up, d_dn, f_up, f_dn, Total_up, Total_dn
      else if(TOTALPDOS.at(0).size()==9) {
        for (int i=0; i< DOSGRID; i++) {
          for (int j=0; j<9; j++) {
            fin << TOTALPDOS[i][j] << "  ";
          }
          fin << TDOS[i][1] << "  " << TDOS[i][2]*(-1);
          fin << endl;
        }
      }
      else {
        throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"Unexpected size of the TOTALPDOS. Please check.",_VALUE_RANGE_);
      }
      fin.close();

      //***********************************GENERATING GNUPLOT SCRIPT**************************************************************

      //Writing Gnuplot Script
      string gnuplotscript = aurostd::ProperFileName("GNUPLOT_" + ICSDName + "_DOS.gp");
      //////ofstream fin;
      fin.open(gnuplotscript.c_str());
      fin << "#Generated by AFLOW (Kesong Yang [kesong.yang@gmail.com], 2011, Duke University)" << endl;
      fin << "set term postscript eps enhanced color font \"Helvetica, 40\" size 18, 10.125" << endl;
      fin << "set output " << "\"" << ICSDName <<"_DOS.eps" << "\"" << endl;
      fin << "set title \"" << estructure::changeICSDNameGunplot(ICSDName) << "\""<< endl;
      //fin << "set border lw 5" << endl; //CO20170830 - thick border
      fin << "unset border" << endl; //CO20170830 - looks better
      fin << "set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb '#E4E4E4' behind fs noborder" << endl;  //CO20170830 - gray background
      fin << "set grid back lt 1 lc rgb 'white' lw 5" << endl; //CO20170830 - white grid
      fin << endl;

      fin << "#DOS PLOT" << endl;
      fin << "set xtics 2" << endl;
      fin << "set ytics" << endl;
      fin << "set xrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
      if(TOTALPDOS.at(0).size()==9||(TOTALPDOS.at(0).size()==7)) { 	
        if(DOSMAX*DOSSCALE!=0) {
          fin << "set yrange [" << DOSMAX*DOSSCALE*(-1) <<":"  << DOSMAX*DOSSCALE << "]" << endl;
        }
        else {
          fin << "set yrange [0:2]" << endl;
        }
      }
      if(TOTALPDOS.at(0).size()==4||(TOTALPDOS.at(0).size()==5)) {
        if(DOSMAX*DOSSCALE!=0) {
          fin << "set yrange [0:" << DOSMAX*DOSSCALE << "]" << endl;
        }
      }
      fin << endl;
      fin << "set label '" << AFLOWLIB_CONSORTIUM_STRING << "' at screen 0.70, 0.02 font \"Helvetica, 32\"" << endl;
      fin << "set xlabel 'energy (eV)' offset graph 0.00" << endl;
      fin << "set ylabel 'eDOS (states/eV)' offset graph 0.00" << endl;
      //fin << "set label 'Written by Kesong Yang [kesong.yang@gmail.com]' at graph 0.02, graph 0.98 font \"Helvetica, 28\" tc rgb 'white'" << endl;
      fin << "set label '{/Helvetica-Oblique E}_F' at 0.05, graph 0.95" << endl;
      fin << "set arrow from 0, 0 to first 0, graph 1 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
      fin << "set arrow from 0, 0 to first 0, graph 0 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
      fin << endl;
      fin << "plot[][] \\" << endl;
      if(TOTALPDOS.at(0).size()==4) { // Only works for s, p and d orbitals	
        fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:5 w l lt -1 lw 6 title 'total'" << endl;
      }
      if(TOTALPDOS.at(0).size()==5) { // Works for s, p, d and f orbitals	
        fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:6 w l lt -1 lw 6 title 'total'" << endl;
      }
      if(TOTALPDOS.at(0).size()==7) { // Only works for s, p and d orbitals; Spin-polarized	
        fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:6 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:7 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:8 w l lt -1 lw 6 title 'total', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:9 w l lt -1 lw 6 notitle" << endl;
      }
      if(TOTALPDOS.at(0).size()==9) { // Only works for s, p, d and f orbitals; Spin-polarized	
        fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:4 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:5 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:6 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:7 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:8 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:9 w l lt 1 lc rgb '#8172B2' lw 6 notitle, \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:10 w l lt -1 lw 6 title 'total', \\" << endl;
        fin << "\"" << dosdatafile << "\"" << " u 1:11 w l lt -1 lw 6 notitle" << endl;
      }
      fin << endl;
      fin << endl;
      fin.close();

      //Call gnuplot to plot the bands structure	
      aurostd::execute(XHOST.command("gnuplot")+" " + gnuplotscript);
      aurostd::execute(XHOST.command("convert")+" -background white ./" + ICSDName + "_DOS.eps ./" + ICSDName + "_DOS.png");
      aurostd::execute(XHOST.command("epstopdf")+" ./" + ICSDName + "_DOS.eps ");
    }
    else {
      //Only works for total dos
      //Shifting the Energy to Fermi level
      for (int i=0; i< DOSGRID; i++) {
        TDOS[i][0]=TDOS[i][0]-Efermi;
      }
      //Finding the maxmium value of TOTALPDOS including s, p, d or f orbitals
      //-----------------------------------------------------------------------
      for (int i=0; i< DOSGRID; i++) {
        if(TDOS.at(0).size()==3) {
          if(TDOS[i][0]>=DOS_Emin && TDOS[i][0]<=DOS_Emax) {
            if(TDOS[i][1]>=DOSMAX) DOSMAX=TDOS[i][1];
          }
        }
        if(TDOS.at(0).size()==5) {
          if(TDOS[i][0]>=DOS_Emin && TDOS[i][0]<=DOS_Emax) {
            if(TDOS[i][1]>=DOSMAX) DOSMAX=TDOS[i][1];
            if(TDOS[i][2]>=DOSMAX) DOSMAX=TDOS[i][2];
          }
        }
      }
      //Wringting into file
      string dosdatafile = ICSDName + "_TDOS.dat";
      ofstream fin;
      fin.open(dosdatafile.c_str());
      fin.setf(ios_base::fixed,ios_base::floatfield);
      fin.precision(6);
      //Non-spin-polarized calculations  Format: Energy, DOS, SUM
      if(TDOS.at(0).size()==3) {	
        for (int i=0; i< DOSGRID; i++) {
          for (int j=0; j<3; j++) {
            fin << TDOS[i][j] << "  ";
          }
          fin << endl;
        }
      }
      //Spin-polarized calculations  Format: Energy,DOS_UP, DOS_DN, SUM_UP, SUM_DN
      else if(TDOS.at(0).size()==5) {
        for (int i=0; i< DOSGRID; i++) {
          for (int j=0; j<2; j++) {
            fin << TDOS[i][j] << "  ";
          }
          fin << TDOS[i][2]*(-1) << " ";
          fin << TDOS[i][3] << " ";
          fin << TDOS[i][4]*(-1) << " ";
          fin << endl;
        }
      }
      fin.close();
      //***********************************GENERATING GNUPLOT SCRIPT**************************************************************
      //Writing Gnuplot Script
      string gnuplotscript = aurostd::ProperFileName("GNUPLOT_" + ICSDName + "_DOS.gp");
      //////ofstream fin;
      fin.open(gnuplotscript.c_str());
      fin << "#Generated by AFLOW (Kesong Yang [kesong.yang@gmail.com], 2011, Duke University)" << endl;
      fin << "set term postscript eps enhanced color font \"Helvetica, 40\" size 18, 10.125" << endl;
      fin << "set output " << "\"" << ICSDName <<"_DOS.eps" << "\"" << endl;
      fin << "set title \"" << estructure::changeICSDNameGunplot(ICSDName) << "\""<< endl;
      //fin << "set border lw 5" << endl; //CO20170830 - thick border
      fin << "unset border" << endl; //CO20170830 - looks better
      fin << "set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb '#E4E4E4' behind fs noborder" << endl;  //CO20170830 - gray background
      fin << "set grid back lt 1 lc rgb 'white' lw 5" << endl; //CO20170830 - white grid
      fin << endl;

      fin << "#DOS PLOT" << endl;
      fin << "set xtics 2" << endl;
      fin << "set ytics" << endl;
      fin << "set xrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
      if(TDOS.at(0).size()==5) { 	
        if(DOSMAX*DOSSCALE!=0) {
          fin << "set yrange [" << DOSMAX*DOSSCALE*(-1) <<":"  << DOSMAX*DOSSCALE << "]" << endl;
        }
        else {
          fin << "set yrange [0:2]" << endl;
        }
        fin << "set arrow from graph 0,first 0 to graph 1,first 0 nohead lt -1 lw 10" << endl;
      }
      if(TDOS.at(0).size()==3) {
        if(DOSMAX*DOSSCALE!=0) {
          fin << "set yrange [0:" << DOSMAX*DOSSCALE << "]" << endl;
        }
      }
      fin << endl;
      fin << "set label '" << AFLOWLIB_CONSORTIUM_STRING << "' at screen 0.70, 0.02 font \"Helvetica, 32\"" << endl;
      fin << "set xlabel 'energy (eV)' offset graph 0.00" << endl;
      fin << "set ylabel 'eDOS (states/eV)' offset graph 0.00" << endl;
      //fin << "set label 'Written by Kesong Yang [kesong.yang@gmail.com]' at graph 0.02, graph 0.98 font \"Helvetica, 28\" tc rgb 'white'" << endl;
      fin << "set label '{/Helvetica-Oblique E}_F' at 0.05, graph 0.95" << endl;
      fin << "set arrow from 0, 0 to first 0, graph 1 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
      fin << "set arrow from 0, 0 to first 0, graph 0 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
      fin << endl;
      fin << "plot[][] \\" << endl;
      if(TDOS.at(0).size()==3) { // non-spin-polarized
        //fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt -1 lw 6 title 'total'" << endl;  //CO20170830 - MAKE DOS DISTINCT
        fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#8172B2' lw 6 title 'total'" << endl;
      }
      if(TDOS.at(0).size()==5) { // spin-polarized
        //fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt -1 lw 6 title 'total spin up', \\" << endl;                //CO20170830 - MAKE SPIN UP DISTINCT
        fin << "\"" << dosdatafile << "\"" << " u 1:2 w l lt 1 lc rgb '#8172B2' lw 6 title 'total spin up', \\" << endl;                //CO20170830 - total spin\\_UP
        fin << "\"" << dosdatafile << "\"" << " u 1:3 w l lt 1 lc rgb '#C44E52' lw 6 title 'total spin down'" << endl;  //CO20170830 - total spin\\_DN
      }
      fin << endl;
      fin << endl;
      fin.close();

      aurostd::execute(XHOST.command("gnuplot")+" " + gnuplotscript);
      aurostd::execute(XHOST.command("convert")+" -background white ./" + ICSDName + "_DOS.eps ./" + ICSDName + "_DOS.png");
      aurostd::execute(XHOST.command("epstopdf")+" ./" + ICSDName + "_DOS.eps ");
    }
    if(LDEBUG) cerr << function_name << " END" << endl;
  }
} // namespace estructure

// ***************************************************************************
// estructure::PLOT_PEDOSALL_AFLOWLIB(string options)
// ***************************************************************************
namespace estructure {
  void PLOT_PEDOSALL_AFLOWLIB(string options, _aflags& aflags) {
    // Generate partial DOS plots for all the inquivalent atoms  using GNUPLOT
    // Usage: aflow --plotpedosall_nonquivalent[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]
    // or aflow --ppan=directory[[,DOS_Emin,DOS_Emax],DOSSCALE]
    // The following files must reside in the directory
    //  DOSCAR.static
    //  OUTCAR.static
    //  POSCAR.static

    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::PLOT_PEDOSALL_AFLOWLIB():";
    if(LDEBUG) cerr << function_name << " BEGIN" << endl;

    vector<string> tokens;
    aurostd::string2tokens(options,tokens,",");
    double DOS_Emin=DEFAULT_DOS_EMIN,DOS_Emax=DEFAULT_DOS_EMAX,DOSSCALE=DEFAULT_DOS_SCALE;  // some defaults

    if(LDEBUG) cerr << function_name << " options=[" << options << "]" << endl;
    if(LDEBUG) cerr << function_name << " tokens.size()=" << tokens.size() << endl;
    if(LDEBUG) for(uint i=0;i<tokens.size();i++) cerr << function_name << " tokens.at(i)=" << tokens.at(i) << endl;

    int NIONS, Natom;
    string directory="./", ICSDName, DOSCARfile, OUTCARfile, POSCARfile, stmp, line;
    stringstream straus, strline; //, stringstreamtmp, strline;  
    stringstream ss_doscar, ss_poscar, ss_outcar; 

    if(tokens.size()<1) {
      init::ErrorOption(options,function_name,"aflow --plotpedosall_nonquivalent[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]");
    }
    if(tokens.size()>=1) directory = tokens.at(0);
    if(tokens.size()>=2) DOS_Emin = aurostd::string2utype<double>(tokens.at(1)); 
    if(tokens.size()>=3) DOS_Emax = aurostd::string2utype<double>(tokens.at(2));
    if(tokens.size()>=4) DOSSCALE = aurostd::string2utype<double>(tokens.at(3));

    if(LDEBUG) cerr << function_name << " directory=[" << directory << "]" << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emin=" << DOS_Emin << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emax=" << DOS_Emax << endl;
    if(LDEBUG) cerr << function_name << " DOSSCALE=" << DOSSCALE << endl;

    cout << function_name << " working in directory=" << directory << endl;

    //Get the atomic lable for each atom
    vector<string> AtomicName=KBIN::ExtractAtomicSpecies(directory);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //READ POSCAR.bands
    aflowlib::vaspfile2stringstream(directory,"POSCAR.bands", ss_poscar);
    xstructure xstr_bands(ss_poscar, IOVASP_POSCAR);

    //Extract the inequivalent atom type
    vector<int> InequivalentAtomType;
    aflags.QUIET=TRUE;
    bool WRITE=FALSE;
    ofstream File("/dev/null");
    //bool verbose=FALSE;

    //DX+CO START
    if(xstr_bands.iatoms_calculated==FALSE){
      _kflags kflags;
      pflow::PerformFullSymmetry(xstr_bands,File,aflags,kflags,WRITE,cout);
    }
    //SYM::CalculateInequivalentAtoms(File,xstr_bands,aflags,WRITE,verbose,cout); // new symmetry DX+CO
    //DX+CO END
    xstr_bands.write_inequivalent_flag=TRUE;

    // cerr << xstr_bands << endl;
    // cerr << xstr_bands.atoms.size() << endl;

    for(unsigned int iat=0;iat<xstr_bands.atoms.size();iat++) {
      InequivalentAtomType.push_back(xstr_bands.atoms.at(iat).equivalent);
    }

    vector<int> InequiAtomTypePlot;
    int n=xstr_bands.atoms.size();
    for (int i=0; i<n;i++) {
      bool matching=false;
      for(int j = 0; (j < i) && (matching == false); j++ )
        if(InequivalentAtomType[i]==InequivalentAtomType[j]) matching = true;
      if(!matching)  InequiAtomTypePlot.push_back(InequivalentAtomType[i]);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    xOUTCAR pedos_outcar; pedos_outcar.GetPropertiesFile(aflowlib::vaspfile2stringstream(directory, "OUTCAR"));

    bool isLSCOUPLING = pedos_outcar.isLSCOUPLING; 
    if(isLSCOUPLING) {   
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"Not working on isLSCOUPLING now!",_RUNTIME_ERROR_);
    }
    NIONS = pedos_outcar.NIONS;
    //Efermi = pedos_outcar.Efermi;

    ICSDName=KBIN::ExtractSystemName(directory); //Get SystemName
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    aflowlib::vaspfile2stringstream(directory, "DOSCAR", ss_doscar);
    double DOSMAX=0.0;
    vector<vector<vector<double> > > PDOS;
    estructure::GET_PDOSDATA(ss_doscar, ss_outcar, PDOS);
    //int DOSGRID = PDOS.at(0).size();

    for (unsigned int i=0; i<InequiAtomTypePlot.size(); i++) {
      Natom= InequiAtomTypePlot[i]+1;
      string str_out = aurostd::PaddedPRE(aurostd::utype2string(Natom),(uint) (1+log10(NIONS)),"0") + "/" 
        + aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0") + "/"
        + AtomicName[Natom-1] + " atom!";
      cout << function_name << " working on " << str_out << endl;

      // cerr << "i=" << i << endl;
      // cerr << "InequiAtomTypePlot.size()=" << InequiAtomTypePlot.size() << endl;
      // cerr << "Natom=" << Natom << endl;
      // cerr << "NIONS=" << NIONS << endl;


      //************************************************************************************************************************
      //Get PDOS
      //************************************************************************************************************************
      //----------------------GETTING PDOS DATA-------------------------
      if(Natom>0 && Natom<=NIONS) {
        if(LDEBUG) cerr << function_name << " [1]" << endl;
        //Generate the Name for PDOS
        string PDOSNAME = "PEDOS_"+aurostd::PaddedPRE(aurostd::utype2string(Natom),(uint) (1+log10(NIONS)),"0")+
          "_" + aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0") + "_" 
          + AtomicName[Natom-1];

        //************************************************************************************************************************
        //************************************************************************************************************************
        //Finding the maxmium value of PDOS
        int Natom_pdos=Natom-1;  //Make the Nth atom corespond to the (Nth-1) data in PDOS data array.
        DOSMAX = aurostd::FindMaxIn2DvectorExcept1stColumn(PDOS[Natom_pdos], DOS_Emin, DOS_Emax);
        //************************************************************************************************************************

        //Writing PEDOS data into file
        string pdosdatafile = ICSDName + "_PEDOS_" + aurostd::PaddedPRE(aurostd::utype2string(Natom),(uint) (1+log10(NIONS)),"0")
          + "_" + aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0")+"_"+AtomicName[Natom-1] + ".dat";

        ofstream fin;
        fin.open(pdosdatafile.c_str());
        fin.setf(ios_base::fixed,ios_base::floatfield);
        fin.precision(6);
        string str_pdos = aurostd::vector2string(PDOS[Natom_pdos]);
        fin << str_pdos;
        fin.close();

        //
        //***********************************GENERATING GNUPLOT SCRIPT************************************
        //Writing Gnuplot Script
        string gnuplotscript = aurostd::ProperFileName("GNUPLOT_" + ICSDName + "_PEDOS_" 
            + aurostd::PaddedPRE(aurostd::utype2string(Natom),(uint) (1+log10(NIONS)),"0") + "_" 
            + aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0")+"_"+AtomicName[Natom-1] + ".gp");

        string plot_pdosname = ICSDName + "_" + PDOSNAME;

        string PEDOStitle=estructure::changeICSDNameGunplot(ICSDName) + "\\\\_" + "PEDOS\\\\_" 
          + aurostd::PaddedPRE(aurostd::utype2string(Natom),(uint) (1+log10(NIONS)),"0")+"\\\\_"
          + aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0") + "\\\\_" 
          + AtomicName[Natom-1] +"(" + aurostd::utype2string(InequivalentAtomType[Natom-1])+") \"";

        ofstream gscript_fin;
        gscript_fin.open(gnuplotscript.c_str());
        string gscript = estructure::PEDOS_GENERATE_GNUPLOTSCRIPT(plot_pdosname, PEDOStitle, DOS_Emin, DOS_Emax, DOSMAX, DOSSCALE, Natom_pdos, PDOS, pdosdatafile);
        gscript_fin << gscript;
        gscript_fin.close();
        //Call gnuplot to plot the PDOS

        aurostd::execute(XHOST.command("gnuplot")+" " + gnuplotscript);
        aurostd::execute(XHOST.command("convert")+" -background white ./" + plot_pdosname + ".eps ./" + plot_pdosname + ".png");
        if(aurostd::FileExist(plot_pdosname+".eps"))  aurostd::execute(DEFAULT_KZIP_BIN+" -9f " + plot_pdosname + ".eps"); // [CORMAC]
        //Postprocess
        if(!XHOST.vflag_control.flag("KEEP::GPL")) { 
          aurostd::RemoveFile(pdosdatafile);
          aurostd::RemoveFile(gnuplotscript);
        }
        if(!XHOST.vflag_control.flag("KEEP::EPS")) { 
          aurostd::RemoveFile(plot_pdosname + ".eps ");
        }
      } //If loop
      //PostProcess
      ss_doscar.seekg (0, ios_base::beg);
    }
    if(LDEBUG) cerr << function_name << " END" << endl;
    cout << function_name << " END" << endl;
  } // function
}

// ***************************************************************************
// estructure::PLOT_PEDOSALL(string options)
// ***************************************************************************
namespace estructure {
  void PLOT_PEDOSALL(string options) {
    // Generate partial DOS plots of all ions using GNUPLOT
    // Usage: aflow --plotpedosall[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]
    // The following file must reside in the directory
    //  DOSCAR.static
    //  OUTCAR.static
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::PLOT_PEDOSALL():";
    if(LDEBUG) cerr << function_name << " BEGIN" << endl;
    int  NIONS;
    string OUTCARfile, stmp, line, directory;
    stringstream straus, strline, ss_outcar; //, stringstreamtmp, strline;  

    vector<string> tokens;
    aurostd::string2tokens(options,tokens,",");
    double DOS_Emin=DEFAULT_DOS_EMIN,DOS_Emax=DEFAULT_DOS_EMAX,DOSSCALE=DEFAULT_DOS_SCALE;  // some defaults

    if(LDEBUG) cerr << function_name << " options=[" << options << "]" << endl;
    if(LDEBUG) cerr << function_name << " tokens.size()=" << tokens.size() << endl;
    if(LDEBUG) for(uint i=0;i<tokens.size();i++) cerr << function_name << " tokens.at(i)=" << tokens.at(i) << endl;

    if(tokens.size()<1) {
      init::ErrorOption(options,function_name,"aflow --plotpedosall[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]");
    }
    if(tokens.size()>=1) directory = tokens.at(0);
    if(tokens.size()>=2) DOS_Emin = aurostd::string2utype<double>(tokens.at(1)); 
    if(tokens.size()>=3) DOS_Emax = aurostd::string2utype<double>(tokens.at(2));
    if(tokens.size()>=4) DOSSCALE = aurostd::string2utype<double>(tokens.at(3));

    if(LDEBUG) cerr << function_name << " directory=[" << directory << "]" << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emin=" << DOS_Emin << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emax=" << DOS_Emax << endl;
    if(LDEBUG) cerr << function_name << " DOSSCALE=" << DOSSCALE << endl;

    string command_postfix="";
    if(tokens.size()>=2) command_postfix+=","+tokens.at(1);
    if(tokens.size()>=3) command_postfix+=","+tokens.at(2);
    if(tokens.size()>=4) command_postfix+=","+tokens.at(3);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    xOUTCAR pedos_outcar; pedos_outcar.GetPropertiesFile(aflowlib::vaspfile2stringstream(directory,"OUTCAR"));


    NIONS = pedos_outcar.NIONS;
    if(LDEBUG) cerr << function_name << " NIONS=" << NIONS << endl;

    string command_local;
    for (int i=1; i<=NIONS; i++) {
      command_local=directory;
      command_local+=","+aurostd::utype2string(i);
      command_local+=command_postfix;
      estructure::PLOT_PEDOS(command_local);
      cout << function_name << " working on "
        << aurostd::PaddedPRE(aurostd::utype2string(i),(uint) (1+log10(NIONS)),"0")
        << "/" << aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0") << " atom!" <<  endl;
    }
    // done now
    if(LDEBUG) cerr << function_name << " END" << endl;
  }
}

// ***************************************************************************
// estructure::PLOT_PEDOS(string options)
// ***************************************************************************
namespace estructure {
  void PLOT_PEDOS(string options) {
    // Generate partial DOS plot using GNUPLOT
    // Usage: aflow --plotpedos[=directory[,number_atom[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]
    // For example: aflow --plotpedos=/common/DATA/ZnO,2
    // The following files must reside in the directory
    //  DOSCAR.static
    //  OUTCAR.static

    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::PLOT_PEDOS():";
    stringstream message;
    if(LDEBUG) cerr << function_name << " BEGIN" << endl;

    string numatom="1",directory="./";  // some defaults 
    vector<string> tokens;
    aurostd::string2tokens(options,tokens,",");
    double DOS_Emin=DEFAULT_DOS_EMIN,DOS_Emax=DEFAULT_DOS_EMAX,DOSSCALE=DEFAULT_DOS_SCALE;  // some defaults

    if(LDEBUG) cerr << function_name << " options=[" << options << "]" << endl;
    if(LDEBUG) cerr << function_name << " tokens.size()=" << tokens.size() << endl;
    if(LDEBUG) for(uint i=0;i<tokens.size();i++) cerr << function_name << " tokens.at(i)=" << tokens.at(i) << endl;

    if(tokens.size()<1) {
      init::ErrorOption(options,function_name,"aflow --plotpedos[=directory[,number_atom[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]");
    }
    if(tokens.size()>=1) directory = tokens.at(0);
    if(tokens.size()>=2) numatom = tokens.at(1);
    if(tokens.size()>=3) DOS_Emin = aurostd::string2utype<double>(tokens.at(2)); 
    if(tokens.size()>=4) DOS_Emax = aurostd::string2utype<double>(tokens.at(3));
    if(tokens.size()>=5) DOSSCALE = aurostd::string2utype<double>(tokens.at(4));

    if(LDEBUG) cerr << function_name << " directory=[" << directory << "]" << endl;
    if(LDEBUG) cerr << function_name << " numatom=[" << numatom << "]" << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emin=" << DOS_Emin << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emax=" << DOS_Emax << endl;
    if(LDEBUG) cerr << function_name << " DOSSCALE=" << DOSSCALE << endl;

    int NIONS, Natom;
    //double Emax, Emin;
    double DOSMAX=0.0;
    string ICSDName, DOSCARfile, OUTCARfile, POSCARfile, stmp, line;
    stringstream straus, strline, dosfile, ss_outcar, ss_doscar; //, stringstreamtmp, strline;  

    cout << function_name << " working in directory=" << directory << endl;
    ICSDName=KBIN::ExtractSystemName(directory); //Get SystemName
    //Get the atomic lable for each atom
    vector<string> AtomicName= KBIN::ExtractAtomicSpecies(directory);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    xOUTCAR pedos_outcar; pedos_outcar.GetPropertiesFile(aflowlib::vaspfile2stringstream(directory,"OUTCAR"));

    bool isLSCOUPLING = pedos_outcar.isLSCOUPLING;
    if(isLSCOUPLING) {
      message << "Not working on isLSCOUPLING now!";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_RUNTIME_ERROR_);
    }
    NIONS = pedos_outcar.NIONS;
    //Efermi = pedos_outcar.Efermi;

    //Judge whether a proper parameter is input
    if(!( numatom[0] >= '0' && numatom[0] <= '9')) {
      //CO20170830 - let's not insult the user?
      //cout << "I HOPE YOU KNOW, WHAT YOU ARE  DOING! You had better read the manual of aconvasp carefully!" << endl;
      //cout << "I REFUSE TO CONTINUE WITH THIS SICK JOB...,BYE!!!<----" << endl;
      //cout << "Anyway, I still give you a promot, the second input must be a digit!"<< endl;
      message << "The second input must be a digit!";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_INPUT_ILLEGAL_);
    }
    Natom=aurostd::string2utype<int>(numatom); //directory
    if(Natom > NIONS) {
      //CO20170830 - let's not insult the user?
      //cout << "The number you put excceds the number of ions (" << NIONS << ")!!" << endl;
      //cout << "How silly you are!!!" << endl;
      message << "The number you put excceds the number of ions (" << NIONS << ")!";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_VALUE_RANGE_);
    }
    if(Natom==0) {
      //CO20170830 - let's not insult the user?
      //cout << "You input 0! I guess you want to plot TDOS, so I recommend you to use 'aflow --plotdos " + directory +"'" << endl;
      //cout << "I do not want to produce TDOS in this way! BYE!!!..." << endl;
      message << "No input! If you want to plot TDOS, use 'aflow --plotdos " + directory +"'";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_INPUT_MISSING_);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    aflowlib::vaspfile2stringstream(directory, "DOSCAR", ss_doscar);
    vector<vector<vector<double> > > PDOS;
    estructure::GET_PDOSDATA(ss_doscar, ss_outcar, PDOS);
    //int DOSGRID = PDOS.at(0).size();

    string str_out = aurostd::PaddedPRE(aurostd::utype2string(Natom),(uint) (1+log10(NIONS)),"0") + "/" 
      + aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0") + "/"
      + AtomicName[Natom-1] + " atom!";
    cerr << function_name << " working on " << str_out << endl;

    //************************************************************************************************************************
    // Get PDOS
    //************************************************************************************************************************
    //----------------------GETTING PDOS DATA-------------------------
    if(Natom>0 && Natom<=NIONS) {
      //Generate the Name for PDOS
      string PDOSNAME = "PEDOS_"+aurostd::PaddedPRE(aurostd::utype2string(Natom),(uint) (1+log10(NIONS)),"0")+
        "_" + aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0") + "_" 
        + AtomicName[Natom-1];

      //************************************************************************************************************************
      //Finding the maxmium value of PDOS
      int Natom_pdos=Natom-1;  //Make the Nth atom corespond to the (Nth-1) data in PDOS data array.
      DOSMAX = aurostd::FindMaxIn2DvectorExcept1stColumn(PDOS[Natom_pdos], DOS_Emin, DOS_Emax);
      //************************************************************************************************************************

      //Writing PEDOS data into file
      string pdosdatafile = ICSDName + "_PEDOS_" + aurostd::PaddedPRE(aurostd::utype2string(Natom),(uint) (1+log10(NIONS)),"0")
        + "_" + aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0")+"_"+AtomicName[Natom-1] + ".dat";

      ofstream fin;
      fin.open(pdosdatafile.c_str());
      fin.setf(ios_base::fixed,ios_base::floatfield);
      fin.precision(6);
      string str_pdos = aurostd::vector2string(PDOS[Natom_pdos]);
      fin << str_pdos;
      fin.close();

      //
      //***********************************GENERATING GNUPLOT SCRIPT************************************
      //Writing Gnuplot Script
      string gnuplotscript = aurostd::ProperFileName("GNUPLOT_" + ICSDName + "_PEDOS_" 
          + aurostd::PaddedPRE(aurostd::utype2string(Natom),(uint) (1+log10(NIONS)),"0") + "_" 
          + aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0")+"_"+AtomicName[Natom-1] + ".gp");

      string plot_pdosname = ICSDName + "_" + PDOSNAME;

      string PEDOStitle=estructure::changeICSDNameGunplot(ICSDName) + "\\\\_" + "PEDOS\\\\_" 
        + aurostd::PaddedPRE(aurostd::utype2string(Natom),(uint) (1+log10(NIONS)),"0")+"\\\\_"
        + aurostd::PaddedPRE(aurostd::utype2string(NIONS),(uint) (1+log10(NIONS)),"0") + "\\\\_" + AtomicName[Natom-1];

      ofstream gscript_fin;
      gscript_fin.open(gnuplotscript.c_str());
      string gscript = estructure::PEDOS_GENERATE_GNUPLOTSCRIPT(plot_pdosname, PEDOStitle, DOS_Emin, DOS_Emax, DOSMAX, DOSSCALE, Natom_pdos, PDOS, pdosdatafile);
      gscript_fin << gscript;
      gscript_fin.close();
      //Call gnuplot to plot the PDOS

      aurostd::execute(XHOST.command("gnuplot")+" " + gnuplotscript);
      aurostd::execute(XHOST.command("convert")+" -background white ./" + plot_pdosname + ".eps ./" + plot_pdosname + ".png");
      //Postprocess
      if(!XHOST.vflag_control.flag("KEEP::GPL")) { 
        aurostd::RemoveFile(pdosdatafile);
        aurostd::RemoveFile(gnuplotscript);
      }
      if(!XHOST.vflag_control.flag("KEEP::EPS")) { 
        aurostd::RemoveFile(plot_pdosname + ".eps ");
      }
    } //If loop
    dosfile.seekg (0, ios_base::beg);
    //PostProcess
    if(LDEBUG) cerr << function_name << " END" << endl;
  } // function
}

// ***************************************************************************
// estructure::fixKPOINT(string kpoint)
// ***************************************************************************
// creates correctly italicized kpoint
namespace estructure {
  bool isSpecialKPOINT(string kpoint){
    if(kpoint.compare("\\Gamma")==0){return true;}
    if(kpoint.compare("Gamma")==0){return true;}
    if(kpoint.compare("\\Sigma_1")==0){return true;}
    if(kpoint.compare("Sigma_1")==0){return true;}
    if(kpoint.compare("\\Sigma")==0){return true;}
    if(kpoint.compare("Sigma")==0){return true;}
    return false;
  }
  string fixSpecialKPOINT_GNUPLOT(string kpoint,bool json){
    if(kpoint.compare("\\Gamma")==0){return "{"+(json?string("\\"):"")+"/Symbol G}";} //NO ITALICS, Gamma is from GOD -- says SC
    if(kpoint.compare("Gamma")==0){return "{"+(json?string("\\"):"")+"/Symbol G}";} //NO ITALICS, Gamma is from GOD -- says SC
    if(kpoint.compare("\\Sigma_1")==0){return "{"+(json?string("\\"):"")+"/Symbol-Oblique S}_1";}
    if(kpoint.compare("Sigma_1")==0){return "{"+(json?string("\\"):"")+"/Symbol-Oblique S}_1";}
    if(kpoint.compare("\\Sigma")==0){return "{"+(json?string("\\"):"")+"/Symbol-Oblique S}";}
    if(kpoint.compare("Sigma")==0){return "{"+(json?string("\\"):"")+"/Symbol-Oblique S}";}
    return kpoint;
  }
  string fixSpecialKPOINT_HTML(string kpoint){
    if(kpoint.compare("\\Gamma")==0){return "&Gamma;";} //NO ITALICS, Gamma is from GOD -- says SC
    if(kpoint.compare("Gamma")==0){return "&Gamma;";} //NO ITALICS, Gamma is from GOD -- says SC
    if(kpoint.compare("\\Sigma_1")==0){return "<i>&Sigma;<\\/i><sub>1<\\/sub>";}
    if(kpoint.compare("Sigma_1")==0){return "<i>&Sigma;<\\/i><sub>1<\\/sub>";}
    if(kpoint.compare("\\Sigma")==0){return "<i>&Sigma;<\\/i>";}
    if(kpoint.compare("Sigma")==0){return "<i>&Sigma;<\\/i>";}
    return kpoint;
  }
  string fixSpecialKPOINT_LATEX(string kpoint){
    if(kpoint.compare("\\Gamma")==0){return "$\\Gamma$";} //NO ITALICS, Gamma is from GOD -- says SC
    if(kpoint.compare("Gamma")==0){return "$\\Gamma$";} //NO ITALICS, Gamma is from GOD -- says SC
    if(kpoint.compare("\\Sigma_1")==0){return "$\\mathit{\\Sigma}_{1}$";}
    if(kpoint.compare("Sigma_1")==0){return "$\\mathit{\\Sigma}_{1}$";}
    if(kpoint.compare("\\Sigma")==0){return "$\\mathit{\\Sigma}$";}
    if(kpoint.compare("Sigma")==0){return "$\\mathit{\\Sigma}$";}
    return kpoint;
  }
  string fixKPOINT_GNUPLOT(string kpoint,bool json) {
    if(isSpecialKPOINT(kpoint)){return fixSpecialKPOINT_GNUPLOT(kpoint,json);}
    else {
      if(aurostd::substring2bool(kpoint,"_")){
        vector<string> parts;
        aurostd::string2tokens(kpoint,parts,"_");
        if(parts.size()!=2){return kpoint;} //not expected, code this exception
        kpoint="{"+(json?string("\\"):"")+"/Helvetica-Oblique "+parts[0]+"}_"+parts[1];
      } else {kpoint="{"+(json?string("\\"):"")+"/Helvetica-Oblique "+kpoint+"}";}
      return kpoint;
    }
  }
  string fixKPOINT_HTML(string kpoint) {
    if(isSpecialKPOINT(kpoint)){return fixSpecialKPOINT_HTML(kpoint);}
    else {
      if(aurostd::substring2bool(kpoint,"_")){
        vector<string> parts;
        aurostd::string2tokens(kpoint,parts,"_");
        if(parts.size()!=2){return kpoint;} //not expected, code this exception
        kpoint="<i>"+parts[0]+"<\\/i><sub>"+parts[1]+"<\\/sub>";
      }//else {kpoint=kpoint;}
      return kpoint;
    }
  }
  string fixKPOINT_LATEX(string kpoint) {
    if(isSpecialKPOINT(kpoint)){return fixSpecialKPOINT_LATEX(kpoint);}
    else {
      if(aurostd::substring2bool(kpoint,"_")){
        vector<string> parts;
        aurostd::string2tokens(kpoint,parts,"_");
        if(parts.size()!=2){return kpoint;} //not expected, code this exception
        kpoint="$"+parts[0]+"_{"+parts[1]+"}$";
      } else {kpoint="$"+kpoint+"$";}
      return kpoint;
    }
  }
  string fixKPOINT_SPECIALONLY(string kpoint) {
    if(aurostd::substring2bool(kpoint,"\\")){return aurostd::StringSubst(kpoint,"\\","\\\\");}
    return kpoint;
  }
}

// ***************************************************************************
// estructure::PLOT_BANDDOS(string options) {
// ***************************************************************************
namespace estructure {
  void PLOT_BANDDOS(string options) {
    // Usage: aflow --plotbanddos[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]
    // This function call PLOTBAND AND PLOTDOS to generate the band and dos!
    estructure::PLOT_BAND(options);
    estructure::PLOT_DOS(options) ;
  }
}

// ***************************************************************************
// estructure::PLOT_BAND(string options) {
// ***************************************************************************
namespace estructure {
  void PLOT_BAND(string options) {
    // Generate bandstructure plot using GNUPLOT
    // In this function, the spin-polarized DOS plot can be generated!
    // Usage: aflow --plotband[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]
    // The following files must reside in the directory
    //   DOSCAR.static
    //   EIGENVAL.bands
    //   KPOINTS.bands
    //   OUTCAR.static

    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::PLOT_BAND():";
    stringstream message;
    if(LDEBUG) cerr << function_name << " BEGIN" << endl;
    vector<string> tokens;
    aurostd::string2tokens(options,tokens,",");
    double DOS_Emin=DEFAULT_DOS_EMIN,DOS_Emax=DEFAULT_DOS_EMAX,DOSSCALE=DEFAULT_DOS_SCALE;  // some defaults

    if(LDEBUG) cerr << function_name << " options=[" << options << "]" << endl;
    if(LDEBUG) cerr << function_name << " tokens.size()=" << tokens.size() << endl;
    if(LDEBUG) for(uint i=0;i<tokens.size();i++) cerr << function_name << " tokens.at(i)=" << tokens.at(i) << endl;

    //bool isLSCOUPLING=FALSE;
    int ISPIN=1,NIONS, NELECT, Nbands, NKPOINTS, KPOINTSGRID;
    double Efermi, ftmp, ftmpup, ftmpdn;
    double DOSMAX=0.0;
    string directory="./", LattName, ICSDName, DOSCARfile, OUTCARfile, EIGENVALfile, POSCARfile, KPOINTSfile, stmp, line;
    stringstream straus, stringstreamtmp, strline, dosfile, ss_outcar, ss_doscar, ss_engenval, ss_kpoints; 

    if(tokens.size()<1) {
      init::ErrorOption(options,function_name,"aflow --plotband[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]");
    }
    if(tokens.size()>=1) directory = tokens.at(0);
    if(tokens.size()>=2) DOS_Emin = aurostd::string2utype<double>(tokens.at(1)); 
    if(tokens.size()>=3) DOS_Emax = aurostd::string2utype<double>(tokens.at(2));
    if(tokens.size()>=4) DOSSCALE = aurostd::string2utype<double>(tokens.at(3));

    if(LDEBUG) cerr << function_name << " directory=[" << directory << "]" << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emin=" << DOS_Emin << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emax=" << DOS_Emax << endl;
    if(LDEBUG) cerr << function_name << " DOSSCALE=" << DOSSCALE << endl;

    cout << function_name << " working in directory=" << directory << endl;

    ICSDName=KBIN::ExtractSystemName(directory); //Get SystemName

    if(LDEBUG) cerr << function_name << " [2]" << endl;
    // cout << aurostd::execute2string("ls "+s) << endl;
    aflowlib::vaspfile2stringstream(directory, "OUTCAR", ss_outcar);

    if(LDEBUG) cerr << function_name << " [3]" << endl;

    //GET Fermi Level, Number of IONS
    //GET lattice vector and reciprocal lattice vectors
    string anchor_word_Efermi = "E-fermi";
    string anchor_word_NIONS = "NIONS";
    string anchor_word_vc = "volume of cell";
    string anchor_word_LSORBIT="LSORBIT =      T";
    xvector<double> a1(3); xvector<double> a2(3); xvector<double> a3(3);
    xvector<double> b1(3); xvector<double> b2(3); xvector<double> b3(3);
    while(getline(ss_outcar, line)) {
      if(line.find(anchor_word_Efermi) !=string::npos) {
        strline.clear();	
        strline.str(line);
        strline >> stmp >> stmp >> Efermi;
      }
      if(line.find(anchor_word_NIONS) !=string::npos) {
        strline.clear();	
        strline.str(line);
        strline >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> NIONS;
      }
      if(line.find(anchor_word_vc) !=string::npos) {
        getline(ss_outcar, line); ss_outcar >> a1[1] >> a1[2] >> a1[3] >> b1[1] >> b1[2] >> b1[3];
        getline(ss_outcar, line); ss_outcar >> a2[1] >> a2[2] >> a2[3] >> b2[1] >> b2[2] >> b2[3];
        getline(ss_outcar, line); ss_outcar >> a3[1] >> a3[2] >> a3[3] >> b3[1] >> b3[2] >> b3[3];	
      }
    }

    if(LDEBUG) cerr << function_name << " [4]" << endl;
    aflowlib::vaspfile2stringstream(directory, "DOSCAR", ss_doscar);
    if(LDEBUG) cerr << function_name << " [4b]" << endl;
    vector<vector<double> > TDOS;
    vector<vector<double> > TOTALPDOS;
    //CO20180216 - this function needs PDOS
    if(!(estructure::GET_DOS_DATA(ss_doscar, ss_outcar, Efermi, TDOS, TOTALPDOS) && TOTALPDOS.size()>0)){
      message << "DOSCAR extraction failed, perhaps there is no PDOS";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_INPUT_MISSING_);
    }

    vector<vector<double> > vvDOS;
    CombineTDOSAndTOTALPDOS(TDOS, TOTALPDOS, vvDOS);
    DOSMAX = aurostd::FindMaxIn2DvectorExcept1stColumn(vvDOS, DOS_Emin, DOS_Emax);

    if(LDEBUG) cerr << function_name << " [5]" << endl;

    //Writing into file
    string str_PDOS = aurostd::vector2string(vvDOS); //TOTALPDOS);  //CO20170830 - plot both tdos and pdos!
    string dosdatafile = ICSDName + "_DOS.dat";
    ofstream dosfin;
    dosfin.open(dosdatafile.c_str());
    dosfin << str_PDOS;
    dosfin.close();

    //Finding the maxmium value of s, p, d or f orbitals
    //-----------------------------------------------------------------------
    //DOSMAX = aurostd::FindMaxIn2DvectorExcept1stColumn(TOTALPDOS, DOS_Emin, DOS_Emax);  //CO20170830 - we want max for TOTAL now
    //-------------------------------------------------------------------------------------------------------------------------------------------------
    if(LDEBUG) cerr << function_name << " [6]" << endl;

    //***********************************DEALING WITH BANDSDATA**************************************************************
    aflowlib::vaspfile2stringstream(directory, "EIGENVAL", ss_engenval);
    //  cout << ss_engenval.str() << endl;throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"Throw for debugging purposes.",_GENERIC_ERROR_);

    //Read FLAG of SPIN, if SPIN=1,Non-spin-polarized; IF SPIN=2, spin-polarized
    ss_engenval >> stmp >> stmp >> stmp >> ISPIN;	

    //Read the headfile of EIGENVAL	
    for(int i=0; i< 5; i++) getline(ss_engenval, stmp);
    ss_engenval >> NELECT >> NKPOINTS >> Nbands;
    getline(ss_engenval, stmp);  //Read the line containing NELECT, NKPOINTS, NBANDS

    //Creating data to store bands data
    vector<vector<double> > datakpoints(NKPOINTS);
    vector<vector<double> > dataup(NKPOINTS); //Define two-dimensional arrary
    vector<vector<double> > datadn(NKPOINTS); //Define two-dimensional arrary
    for (int i=0; i<NKPOINTS; i++) {
      datakpoints[i].resize(3);
    }
    for (int i=0; i<NKPOINTS; i++) {
      dataup[i].resize(Nbands); datadn[i].resize(Nbands);
    }
    //Obtain the bands data and store them into dataup and datadn, respectively
    if(ISPIN==1) {
      for(int ik=0; ik< NKPOINTS; ik++) {
        getline(ss_engenval, stmp); //Negelecting empty line
        ss_engenval >> datakpoints[ik][0] >> datakpoints[ik][1] >> datakpoints[ik][2];	
        getline(ss_engenval, stmp); //Negelecting kpoint coordinate
        int ib=-1;	
        for(int i=0; i<Nbands; i++) {
          ss_engenval>>ftmp>>ftmp;
          ib=ib+1;
          dataup[ik][ib]=ftmp;
        }
        getline(ss_engenval,stmp);
      }
    }
    else if(ISPIN==2) {
      for(int ik=0; ik< NKPOINTS; ik++) {
        getline(ss_engenval, stmp); //Negelecting empty line
        ss_engenval >> datakpoints[ik][0] >> datakpoints[ik][1] >> datakpoints[ik][2];	
        getline(ss_engenval, stmp); //Negelecting kpoint coordinate
        int ib=-1;	
        for(int i=0; i<Nbands; i++) {
          ss_engenval>>ftmp>>ftmpup>>ftmpdn;
          ib=ib+1;
          dataup[ik][ib]=ftmpup;
          datadn[ik][ib]=ftmpdn;
        }
        getline(ss_engenval,stmp);
      }
    }
    else {
      message << "Can not detect spin flag! Error, Aborting!";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_RUNTIME_ERROR_);
    }

    //READ KPOINTS	
    aflowlib::vaspfile2stringstream(directory, "KPOINTS", ss_kpoints);

    ss_kpoints >> LattName >> stmp; getline(ss_kpoints, stmp);
    ss_kpoints >> KPOINTSGRID >> stmp >> stmp >> stmp; getline(ss_kpoints, stmp);
    getline(ss_kpoints, stmp);
    getline(ss_kpoints, stmp);

    // Get special kpoints from KPOINTS.bands
    // Get Lables of KPOINTS from KPOINTS.bands
    vector<vector<double> > kpoints;  
    vector<string> kpointslabel;      
    int count=0, j=0; //count is the number of rows of kpoints
    // cout << ss_kpoints.str() << endl;
    while(getline(ss_kpoints, line)) {
      if(aurostd::CountWordsinString(line)>=3) {
        vector<double> kpt_tmp;
        double a1, a2, a3;
        string a5;
        strline.clear();
        strline.str(line);
        strline >> a1 >> a2 >> a3 >> stmp >> a5;
        kpt_tmp.push_back(a1);
        kpt_tmp.push_back(a2);
        kpt_tmp.push_back(a3);
        kpoints.push_back(kpt_tmp);
        kpointslabel.push_back(a5);
        j++;
      }
      count = j;
    }
    //*******************************Redefine the symbols of special kpoints
    for (int i=0; i< count; i++) {kpointslabel[i]=fixKPOINT_GNUPLOT(kpointslabel[i]);}  //CO20170831 - fix all at once
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //Combine the Labels of special kpoints	
    for (int i=1; i< (count-1); i=i+2) {
      if(kpointslabel[i].compare(kpointslabel[i+1])!=0) {
        bool need_space=!aurostd::substring2bool(kpointslabel[i],"_"); //CO20170830 - if subscript, extra space looks ODD!
        string newlabel = aurostd::attach(kpointslabel[i]+(need_space?" ":""),kpointslabel[i+1]);  //CO20170830 - italics and make space for first italics
        kpointslabel[i] = newlabel;
        kpointslabel[i+1] = newlabel;
      }
    }
    //*******************************Redefine the symbols of special kpoints

    //Converting kpoints into Cartesian
    vector<vector<double> > kpcart;
    for (int i=0; i<count; i++) {
      vector<double> kpcart_tmp;
      double c1=0, c2=0, c3=0;
      c1=kpoints[i][0]*b1[1]+kpoints[i][1]*b2[1]+kpoints[i][2]*b3[1];
      c2=kpoints[i][0]*b1[2]+kpoints[i][1]*b2[2]+kpoints[i][2]*b3[2];
      c3=kpoints[i][0]*b1[3]+kpoints[i][1]*b2[3]+kpoints[i][2]*b3[3];
      kpcart_tmp.push_back(c1);
      kpcart_tmp.push_back(c2);
      kpcart_tmp.push_back(c3);
      kpcart.push_back(kpcart_tmp);
    }

    //Check number of kpoints

    if(LDEBUG) cerr << function_name << " [7]" << endl;
    if((count/2)*KPOINTSGRID!=NKPOINTS) {
      message << "Please check your KPOINTS.bands and EIGENVAL.bands files! The number of kpoints are different!!!" << endl;
      message << "KPOINTSGRID=" << KPOINTSGRID << endl;
      message << "count=" << count << endl;
      message << "(count/2)*KPOINTSGRID=" << (count/2)*KPOINTSGRID << endl;
      message << "NKPOINTS=" << NKPOINTS << endl;
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_VALUE_ERROR_);
    }

    //Calcuating klinedirect from the direct points
    vector<double> klinecart(NKPOINTS); 	
    double koffset=0;
    double kx1, ky1, kz1, kx2, ky2, kz2, dkx, dky, dkz, dk;
    int ind=0;
    for (int i=0; i<count/2; i++) {
      j=2*i;
      kx1=kpcart[j][0]; ky1=kpcart[j][1]; kz1=kpcart[j][2];
      kx2=kpcart[j+1][0]; ky2=kpcart[j+1][1]; kz2=kpcart[j+1][2];
      dkx = kx2-kx1;
      dky = ky2-ky1;
      dkz = kz2-kz1;
      dk= (sqrt(dkx*dkx + dky*dky +dkz*dkz))/(KPOINTSGRID-1);
      klinecart[ind]=koffset; ind++;
      for (int ii=1; ii<KPOINTSGRID; ii++) {
        klinecart[ind]= koffset + ii*dk;
        ind++;
      }
      koffset = koffset + dk*(KPOINTSGRID-1);
    }

    //*******************************Redefine the symbols of special kpoints
    //CO20170830 - already done above ?? - not sure why we do twice...
    //[OBSOLETE]for (int i=0; i< count; i++) {
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]}
    //[OBSOLETE]//Combine the Labels of special kpoints	
    //[OBSOLETE]for (int i=1; i< (count-1); i=i+2) {
    //[OBSOLETE]  if(kpointslabel[i].compare(kpointslabel[i+1])!=0) {
    //[OBSOLETE]    string newlabel = aurostd::attach(fixKPOINT(kpointslabel[i])+" ",fixKPOINT(kpointslabel[i+1]));  //CO20170830 - italics and make space for first italics
    //[OBSOLETE]    kpointslabel[i] = newlabel;
    //[OBSOLETE]    kpointslabel[i+1] = newlabel;
    //[OBSOLETE]  } else {
    //[OBSOLETE]    kpointslabel[i] = fixKPOINT(kpointslabel[i]); //CO20170830 - italics
    //[OBSOLETE]    kpointslabel[i+1] = fixKPOINT(kpointslabel[i+1]); //CO20170830 - italics
    //[OBSOLETE]  }
    //[OBSOLETE]}
    //*******************************Redefine the symbols of special kpoints

    //**************************************Redefine the cartesian coordinates of special kpoints****************************************
    vector<double>  SPKPOINTScart(count);
    vector<double>  SPKPOINTScart_LABEL(count);

    //Get the cartesian coordinates of the special kpoints and store them into SPKPOINTScart
    for (int i=0; i<count; i=i+2) {
      SPKPOINTScart[i]=klinecart[(i/2)*(KPOINTSGRID)];
      SPKPOINTScart[i+1]=klinecart[(i/2+1)*(KPOINTSGRID)-1];
    }
    //NO SHIFT - CO20170830
    for (int i=0; i< count; i=i+2) {SPKPOINTScart_LABEL[i]=SPKPOINTScart[i];}
    SPKPOINTScart_LABEL[count-1]=SPKPOINTScart[count-1];
    //Shifting the cartesian coordinates of special KPOINTS;
    //[OBSOLETE]for (int i=0; i< count; i=i+2) {
    //[OBSOLETE]  if(kpointslabel[i].size()==1)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.006;
    //[OBSOLETE]  else if(kpointslabel[i].size()==3)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.018;
    //[OBSOLETE]  else if(kpointslabel[i].size()==5)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.030;
    //[OBSOLETE]  else  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i];
    //[OBSOLETE]}
    //[OBSOLETE]SPKPOINTScart_LABEL[count-1]=SPKPOINTScart[count-1]-0.006;
    //**************************************Redefine the cartesian coordinates of special kpoints****************************************

    string bandsdatafile = ICSDName + "_BANDS.dat";
    ofstream bandsfin;
    bandsfin.open(bandsdatafile.c_str());
    bandsfin.setf(ios_base::fixed,ios_base::floatfield);  //Formating output
    bandsfin.precision(BANDS_PRECISION);  //needs to match with labels
    vector<vector<double> > bandsdata(NKPOINTS);
    //Writing bands data into file
    if(ISPIN==1) {	
      for (int i=0; i<NKPOINTS; i++) {
        bandsdata[i].resize(Nbands+1);
        bandsdata[i][0]=klinecart[i];
      }
      for (int i=0; i<NKPOINTS; i++)
        for (int ib=0; ib<Nbands; ib++) {
          bandsdata[i][ib+1]=dataup[i][ib]-Efermi;  //Zero point Shifts to Efermi
        }

      for (int ik=0;ik<NKPOINTS;ik++) {
        if(ik&&!(ik%KPOINTSGRID)){bandsfin << endl << endl;}  //CO20170831 - make sure there is NO continuation between KPOINTS, not valid assumption
        for (int ib=0; ib<Nbands+1; ib++) {
          bandsfin << bandsdata[ik][ib] << "  " ;
        }
        bandsfin << endl;
      }
      bandsfin.close();
    }
    //Spin-polarized
    if(ISPIN==2) {	
      for (int i=0; i<NKPOINTS; i++) {
        bandsdata[i].resize(2*Nbands+1);
        bandsdata[i][0]=klinecart[i];
      }
      for (int i=0; i<NKPOINTS; i++)
        for (int ib=0; ib<Nbands; ib++) {
          bandsdata[i][2*ib+1]=dataup[i][ib]-Efermi;  //Zero point Shifts to Efermi
          bandsdata[i][2*ib+2]=datadn[i][ib]-Efermi;  //Zero point Shifts to Efermi
        }
      for (int ik=0;ik<NKPOINTS;ik++) {
        if(ik&&!(ik%KPOINTSGRID)){bandsfin << endl << endl;}  //CO20170831 - make sure there is NO continuation between KPOINTS, not valid assumption
        for (int ib=0; ib<2*Nbands+1; ib++) {
          bandsfin << bandsdata[ik][ib] << "  " ;
        }
        bandsfin << endl;
      }
      bandsfin.close();
    }

    //***********************************GENERATING GNUPLOT SCRIPT**************************************************************
    //Writing Gnuplot Script
    string gnuplotscript = aurostd::ProperFileName("GNUPLOT_" + ICSDName + ".gp");
    ofstream fin;
    fin.open(gnuplotscript.c_str());
    fin << "#Generated by AFLOW (Kesong Yang [kesong.yang@gmail.com], 2011, Duke University)" << endl;
    fin << "set term postscript eps enhanced color font \"Helvetica, 40\" size 18, 10.125" << endl;
    fin << "set output " << "\"" << ICSDName <<".eps" << "\"" << endl;
    fin << "set multiplot title \"" << estructure::changeICSDNameGunplot(ICSDName) << " (" << LattName << ")" << "\""<< endl;
    fin << "set label '" << AFLOWLIB_CONSORTIUM_STRING << "' at screen 0.75, 0.02 font \"Helvetica, 32\"" << endl;
    //fin << "set border lw 5" << endl; //CO20170830 - thick border
    fin << "unset border" << endl; //CO20170830 - looks better
    fin << "set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb '#E4E4E4' behind fs noborder" << endl;  //CO20170830 - gray background
    fin << "set grid back lt 1 lc rgb 'white' lw 5" << endl; //CO20170830 - white grid
    //fin << "set label 'Generated by AFLOW (Kesong Yang \\& Stefano Curtarolo)' at screen 0.985, 0.5 font \"Helvetica, 22\" rotate by -90 center " << endl;
    fin << endl;

    fin << "#DOS PLOT" << endl;
    fin << "set lmargin at screen 0.72" << endl;
    fin << "set rmargin at screen 0.98" << endl;
    fin << "set tmargin at screen 0.94" << endl;
    fin << "set bmargin at screen 0.09" << endl;
    fin << "set title 'eDOS (states/eV)' offset 0,-0.7" << endl;
    fin << "set xtics " << endl;
    //fin << "unset ytics" << endl;
    fin << "set ytics " << endl;
    fin << "set format y \"\"" << endl; //CO20170830 - keep grid
    fin << "set yrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
    if(TOTALPDOS.at(0).size()==9||(TOTALPDOS.at(0).size()==7)) {
      if(DOSMAX*DOSSCALE!=0) {
        fin << "set xrange [" << DOSMAX*DOSSCALE*(-1) <<":"  << DOSMAX*DOSSCALE << "]" << endl;
      }
      else {
        fin << "set xrange [0:2]" << endl;
      }
    }
    if(TOTALPDOS.at(0).size()==4||(TOTALPDOS.at(0).size()==5)) {
      if(DOSMAX*DOSSCALE!=0) {
        fin << "set xrange [0:" << DOSMAX*DOSSCALE << "]" << endl;
      }
    }
    fin << endl;
    fin << "set arrow from 0, 0 to graph 1, first 0 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
    fin << "set arrow from 0, 0 to graph 0, first 0 nohead lt 3 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
    fin << "set key font \"Helvetica, 40\"" << endl; 	
    fin << endl;
    fin << "plot[][] \\" << endl;
    if(TOTALPDOS.at(0).size()==4) { // Only works for s, p and d orbitals  
      fin << "\"" << dosdatafile << "\"" << " u 2:1 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 3:1 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 4:1 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 5:1 w l lt -1 lw 6 title 'total'" << endl;
    }
    if(TOTALPDOS.at(0).size()==5) { // Works for s, p, d and f orbitals    
      fin << "\"" << dosdatafile << "\"" << " u 2:1 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 3:1 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 4:1 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 5:1 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 6:1 w l lt -1 lw 6 title 'total'" << endl;
    }
    if(TOTALPDOS.at(0).size()==7) { // Only works for s, p and d orbitals; Spin-polarized  
      fin << "\"" << dosdatafile << "\"" << " u 2:1 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 3:1 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 4:1 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 5:1 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 6:1 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 7:1 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 8:1 w l lt -1 lw 6 title 'total', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 9:1 w l lt -1 lw 6 notitle" << endl;
    }
    if(TOTALPDOS.at(0).size()==9) { // Only works for s, p, d and f orbitals; Spin-polarized      
      fin << "\"" << dosdatafile << "\"" << " u 2:1 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 3:1 w l lt 1 lc rgb '#4C72B0' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 4:1 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 5:1 w l lt 1 lc rgb '#55A868' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 6:1 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 7:1 w l lt 1 lc rgb '#C44E52' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 8:1 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 9:1 w l lt 1 lc rgb '#8172B2' lw 6 notitle, \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 10:1 w l lt -1 lw 6 title 'total', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 11:1 w l lt -1 lw 6 notitle" << endl;
    }
    fin << endl;
    fin << endl;

    fin << "#BANDS PLOT" << endl;
    fin << "set lmargin at screen 0.06" << endl;
    fin << "set rmargin at screen 0.7" << endl;
    fin << "set tmargin at screen 0.94" << endl;
    fin << "set bmargin at screen 0.09" << endl;
    fin << endl;
    fin << "unset title" << endl;
    fin << "unset key" << endl;
    fin << "unset xtics" << endl;
    //CO20170830 - add tics at the right spot, but leave labels out - START
    fin << "set xtics (";
    for (int i=0; i< count; i=i+2) {
      fin << "\"" << kpointslabel[i] <<"\"";
      fin << " " << std::setprecision(BANDS_PRECISION) << SPKPOINTScart_LABEL[i] << ",";  //needs to match bandsdatafile
    } //(i+2<count ? "," : "" );
    fin << "\"" << kpointslabel[count-1] <<"\"";
    fin << " " << std::setprecision(BANDS_PRECISION) << SPKPOINTScart_LABEL[count-1] << ")" << endl;  //needs to match bandsdatafile
    fin << "set format x \"\"" << endl;
    fin << "unset format y" << endl;
    //CO20170830 - add tics at the right spot, but leave labels out - STOP
    fin << "set ytics" << endl;
    fin << "set xrange [* : *]" << endl;
    fin << "set yrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
    fin << "set ylabel 'energy (eV)' offset graph 0.002" << endl;
    fin << endl;
    //CO20170831 - now we do with xtics - START
    //[OBSOLETE]for (int i=0; i< count; i=i+2) {
    //[OBSOLETE]  if(kpointslabel[i].compare("G")==0) {
    //[OBSOLETE]fin << "set label " << "\"{/Symbol G}\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
    //[OBSOLETE]}
    //[OBSOLETE]else if(kpointslabel[i].compare("Sigm")==0) {
    //[OBSOLETE]fin << "set label " << "\"{/Symbol-Oblique S}\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
    //[OBSOLETE]}
    //[OBSOLETE]else if(kpointslabel[i].compare("Sigm_1")==0) {
    //[OBSOLETE]fin << "set label " << "\"{/Symbol-Oblique S}" << "_1\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
    //[OBSOLETE]}
    //[OBSOLETE]else {
    //[OBSOLETE]fin << "set label " << "\"" << kpointslabel[i] <<"\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
    //[OBSOLETE]}
    //[OBSOLETE]}
    //[OBSOLETE]fin << "set label " << "\"" << kpointslabel[count-1] <<"\"" << " center at " << SPKPOINTScart_LABEL[count-1] <<", " << "graph - 0.03" << endl;	
    //CO20170831 - now we do with xtics - STOP
    //CO20170830 - manual grid not needed - START
    //for (int i=0; i< count; i=i+2) {
    //  fin << "set arrow from first  " << SPKPOINTScart[i] <<", graph 0 to first " << SPKPOINTScart[i] <<", graph 1 nohead lt 1 lc rgb 'white' lw 5" << endl;
    //}
    //CO20170830 - manual grid not needed - STOP
    fin << endl;
    fin << "set arrow from 0, 0 to graph 1, first 0 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
    fin << endl;
    fin << "plot[][] \\" << endl;
    if(ISPIN==1) {
      for (unsigned int i=1; i<(bandsdata.at(0).size()-1); i++) {
        fin << "\"" << bandsdatafile << "\"" << " u 1:" << i+1 << " w l lt -1 lw 3, \\" << endl;
      }
      fin << "\"" << bandsdatafile << "\"" << " u 1:" << bandsdata.at(0).size() << " w l lt -1 lw 3" << endl;
    }
    if(ISPIN==2) {
      for (unsigned int i=1; i<(bandsdata.at(0).size()-2); i=i+2) {
        fin << "\"" << bandsdatafile << "\"" << " u 1:" << i+1 << " w l lt -1 lw 3, \\" << endl;
        fin << "\"" << bandsdatafile << "\"" << " u 1:" << i+2 << " w l lt 1 lc rgb '#C44E52' lw 3, \\" << endl;
      }
      fin << "\"" << bandsdatafile << "\"" << " u 1:" << bandsdata.at(0).size()-1 << " w l lt -1 lw 3, \\" << endl;
      fin << "\"" << bandsdatafile << "\"" << " u 1:" << bandsdata.at(0).size() << " w l lt 1 lc rgb '#C44E52' lw 3" << endl;
    }
    fin.close();

    //Call gnuplot to plot the bands structure	
    aurostd::execute(XHOST.command("gnuplot")+" " + gnuplotscript);
    aurostd::execute(XHOST.command("convert")+" -background white ./" + ICSDName + ".eps  ./" + ICSDName + ".png");
    //KY in the future we can remove these 4 lines, but for now we need to patch plotbz.sh
    if(aurostd::FileExist("bz_.eps")) aurostd::file2file("bz_.eps",ICSDName+"_BZ.eps");
    if(aurostd::FileExist("bz_.png")) aurostd::file2file("bz_.png",ICSDName+"_BZ.png");
    if(aurostd::FileExist("bz_"+ICSDName+".eps")) aurostd::file2file("bz_"+ICSDName+".eps",ICSDName+"_BZ.eps");
    if(aurostd::FileExist("bz_"+ICSDName+".png")) aurostd::file2file("bz_"+ICSDName+".png",ICSDName+"_BZ.png");
    //if(aurostd::FileExist(ICSDName+"_BZ.eps")) aurostd::execute(DEFAULT_KZIP_BIN+" -9f \"" + ICSDName + "_BZ.eps\"");
    // REMOVE if(aurostd::FileExist(ICSDName+"_BZ.eps")) aurostd::RemoveFile(ICSDName + \""_BZ.eps\"");  [CORMAC]
    if(aurostd::FileExist(ICSDName+"_BZ.eps"))  aurostd::execute(DEFAULT_KZIP_BIN+" -9f \"" + ICSDName + "_BZ.eps\"");

    //Postprocess
    if(!XHOST.vflag_control.flag("KEEP::GPL")) { 
      aurostd::RemoveFile(bandsdatafile);
      aurostd::RemoveFile(dosdatafile);
      aurostd::RemoveFile(gnuplotscript); //Delete the gnuplot script
    }
    //  aurostd::RemoveFile(ICSDName + ".eps"); // [CORMAC]
    if(aurostd::FileExist(ICSDName+".eps"))  aurostd::execute(DEFAULT_KZIP_BIN+" -9f \"" + ICSDName + ".eps\""); // [CORMAC]
  }
}

// ***************************************************************************
//  estructure::PLOT_BAND(string options) 
// ***************************************************************************
namespace estructure {
  void PLOT_BAND2(string options) {
    //Generate bandstructure plot using GNUPLOT
    //In this function, the spin-polarized DOS plot can be generated!
    //Usage: aflow --plotband2[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]
    //The following files must reside in the directory
    //  DOSCAR.static
    //  EIGENVAL.bands
    //  KPOINTS.bands
    //  OUTCAR.static

    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::PLOT_BAND2():";
    stringstream message;
    if(LDEBUG) cerr << function_name << " BEGIN" << endl;
    vector<string> tokens;
    aurostd::string2tokens(options,tokens,",");
    double DOS_Emin=DEFAULT_DOS_EMIN,DOS_Emax=DEFAULT_DOS_EMAX,DOSSCALE=DEFAULT_DOS_SCALE;  // some defaults

    if(LDEBUG) cerr << function_name << " options=[" << options << "]" << endl;
    if(LDEBUG) cerr << function_name << " tokens.size()=" << tokens.size() << endl;
    if(LDEBUG) for(uint i=0;i<tokens.size();i++) cerr << function_name << " tokens.at(i)=" << tokens.at(i) << endl;

    //bool isLSCOUPLING=FALSE;
    int ISPIN=1,NIONS, NELECT, Nbands, NKPOINTS, KPOINTSGRID;
    double Efermi, ftmp, ftmpup, ftmpdn;
    double DOSMAX=0.0;
    string directory="./", LattName, ICSDName, DOSCARfile, OUTCARfile, EIGENVALfile, POSCARfile, KPOINTSfile, stmp, line;
    stringstream straus, stringstreamtmp, strline, dosfile, ss_outcar, ss_doscar, ss_engenval, ss_kpoints; 

    if(tokens.size()<1) {
      init::ErrorOption(options,function_name,"aflow --plotband2[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]");
    }
    if(tokens.size()>=1) directory = tokens.at(0);
    if(tokens.size()>=2) DOS_Emin = aurostd::string2utype<double>(tokens.at(1)); 
    if(tokens.size()>=3) DOS_Emax = aurostd::string2utype<double>(tokens.at(2));
    if(tokens.size()>=4) DOSSCALE = aurostd::string2utype<double>(tokens.at(3));

    // [OBSOLETE]    if(directory=="") directory="./";
    // [OBSOLETE]    if(DOS_Emin<=-999.9) DOS_Emin=DEFAULT_DOS_EMIN;
    // [OBSOLETE]    if(DOS_Emax<=-999.9) DOS_Emax=DEFAULT_DOS_EMAX;
    // [OBSOLETE]    if(DOSSCALE<=-999.9) DOSSCALE=DEFAULT_DOS_SCALE;

    if(LDEBUG) cerr << function_name << " directory=[" << directory << "]" << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emin=" << DOS_Emin << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emax=" << DOS_Emax << endl;
    if(LDEBUG) cerr << function_name << " DOSSCALE=" << DOSSCALE << endl;

    cerr << function_name << " working in directory=" << directory << endl;

    ICSDName=KBIN::ExtractSystemName(directory); //Get SystemName

    aflowlib::vaspfile2stringstream(directory, "OUTCAR", ss_outcar);

    //GET Fermi Level, Number of IONS
    //GET lattice vector and reciprocal lattice vectors
    string anchor_word_Efermi = "E-fermi";
    string anchor_word_NIONS = "NIONS";
    string anchor_word_vc = "volume of cell";
    string anchor_word_LSORBIT="LSORBIT =      T";
    xvector<double> a1(3); xvector<double> a2(3); xvector<double> a3(3);
    xvector<double> b1(3); xvector<double> b2(3); xvector<double> b3(3);
    while(getline(ss_outcar, line)) {
      if(line.find(anchor_word_Efermi) !=string::npos) {
        strline.clear();	
        strline.str(line);
        strline >> stmp >> stmp >> Efermi;
      }
      if(line.find(anchor_word_NIONS) !=string::npos) {
        strline.clear();	
        strline.str(line);
        strline >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> NIONS;
      }
      if(line.find(anchor_word_vc) !=string::npos) {
        getline(ss_outcar, line); ss_outcar >> a1[1] >> a1[2] >> a1[3] >> b1[1] >> b1[2] >> b1[3];
        getline(ss_outcar, line); ss_outcar >> a2[1] >> a2[2] >> a2[3] >> b2[1] >> b2[2] >> b2[3];
        getline(ss_outcar, line); ss_outcar >> a3[1] >> a3[2] >> a3[3] >> b3[1] >> b3[2] >> b3[3];	
      }
    }

    aflowlib::vaspfile2stringstream(directory, "DOSCAR", ss_doscar);
    vector<vector<double> > TDOS;
    vector<vector<double> >  TOTALPDOS_SPIN;
    //CO20180216 - this function needs PDOS
    if(!(estructure::GET_DOS_DATA(ss_doscar, ss_outcar, Efermi, TDOS, TOTALPDOS_SPIN) && TOTALPDOS_SPIN.size()>0)){
      message << "DOSCAR extraction failed, perhaps there is no PDOS" << endl;
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_INPUT_MISSING_);
    }

    vector<vector<double> >  TOTALPDOS;
    if(TOTALPDOS_SPIN.at(0).size() == 4) TOTALPDOS = TOTALPDOS_SPIN;
    else if(TOTALPDOS_SPIN.at(0).size() == 5) TOTALPDOS = TOTALPDOS_SPIN;
    else if(TOTALPDOS_SPIN.at(0).size() == 7) {
      for (uint i=0; i<TOTALPDOS_SPIN.size();i++) {
        vector<double> vtmp; vtmp.clear();
        vtmp.push_back(TOTALPDOS_SPIN[i][0]); //Energy
        vtmp.push_back(TOTALPDOS_SPIN[i][1] + TOTALPDOS_SPIN[i][2]); //s_up + s_dn
        vtmp.push_back(TOTALPDOS_SPIN[i][3] + TOTALPDOS_SPIN[i][4]); //p_up + p_dn
        vtmp.push_back(TOTALPDOS_SPIN[i][5] + TOTALPDOS_SPIN[i][6]); //d_up + d_dn
        TOTALPDOS.push_back(vtmp);
      }
    }
    else if(TOTALPDOS_SPIN.at(0).size() == 9) {
      for (uint i=0; i<TOTALPDOS_SPIN.size();i++) {
        vector<double> vtmp; vtmp.clear();
        vtmp.push_back(TOTALPDOS_SPIN[i][0]); //Energy
        vtmp.push_back(TOTALPDOS_SPIN[i][1] + TOTALPDOS_SPIN[i][2]); //s_up + s_dn
        vtmp.push_back(TOTALPDOS_SPIN[i][3] + TOTALPDOS_SPIN[i][4]); //p_up + p_dn
        vtmp.push_back(TOTALPDOS_SPIN[i][5] + TOTALPDOS_SPIN[i][6]); //d_up + d_dn
        vtmp.push_back(TOTALPDOS_SPIN[i][7] + TOTALPDOS_SPIN[i][8]); //f_up + f_dn
        TOTALPDOS.push_back(vtmp);
      }
    }

    string str_PDOS = aurostd::vector2string(TOTALPDOS);
    //Wringting into file
    string dosdatafile = ICSDName + "_DOS.dat";
    ofstream dosfin;
    dosfin.open(dosdatafile.c_str());
    dosfin << str_PDOS;
    dosfin.close();

    //Finding the maxmium value of s, p, d or f orbitals
    //-----------------------------------------------------------------------
    DOSMAX = aurostd::FindMaxIn2DvectorExcept1stColumn(TOTALPDOS, DOS_Emin, DOS_Emax);
    //-------------------------------------------------------------------------------------------------------------------------------------------------

    //***********************************DEALING WITH BANDSDATA**************************************************************
    aflowlib::vaspfile2stringstream(directory, "EIGENVAL", ss_engenval);

    //Read FLAG of SPIN, if SPIN=1,Non-spin-polarized; IF SPIN=2, spin-polarized
    ss_engenval >> stmp >> stmp >> stmp >> ISPIN;	

    //Read the headfile of EIGENVAL	
    for(int i=0; i< 5; i++) getline(ss_engenval, stmp);
    ss_engenval >> NELECT >> NKPOINTS >> Nbands;
    getline(ss_engenval, stmp);  //Read the line containing NELECT, NKPOINTS, NBANDS

    //Creating data to store bands data
    vector<vector<double> > datakpoints(NKPOINTS);
    vector<vector<double> > dataup(NKPOINTS); //Define two-dimensional arrary
    vector<vector<double> > datadn(NKPOINTS); //Define two-dimensional arrary
    for (int i=0; i<NKPOINTS; i++) {
      datakpoints[i].resize(3);
    }
    for (int i=0; i<NKPOINTS; i++) {
      dataup[i].resize(Nbands); datadn[i].resize(Nbands);
    }
    //Obtain the bands data and store them into dataup and datadn, respectively
    if(ISPIN==1) {
      for(int ik=0; ik< NKPOINTS; ik++) {
        getline(ss_engenval, stmp); //Negelecting empty line
        ss_engenval >> datakpoints[ik][0] >> datakpoints[ik][1] >> datakpoints[ik][2];	
        getline(ss_engenval, stmp); //Negelecting kpoint coordinate
        int ib=-1;	
        for(int i=0; i<Nbands; i++) {
          ss_engenval>>ftmp>>ftmp;
          ib=ib+1;
          dataup[ik][ib]=ftmp;
        }
        getline(ss_engenval,stmp);
      }
    }
    else if(ISPIN==2) {
      for(int ik=0; ik< NKPOINTS; ik++) {
        getline(ss_engenval, stmp); //Negelecting empty line
        ss_engenval >> datakpoints[ik][0] >> datakpoints[ik][1] >> datakpoints[ik][2];	
        getline(ss_engenval, stmp); //Negelecting kpoint coordinate
        int ib=-1;	
        for(int i=0; i<Nbands; i++) {
          ss_engenval>>ftmp>>ftmpup>>ftmpdn;
          ib=ib+1;
          dataup[ik][ib]=ftmpup;
          datadn[ik][ib]=ftmpdn;
        }
        getline(ss_engenval,stmp);
      }
    }
    else {
      message << "Can not detect spin flag! Error, Aborting!";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_RUNTIME_ERROR_);
    }

    //READ KPOINTS	
    aflowlib::vaspfile2stringstream(directory, "KPOINTS", ss_kpoints);

    ss_kpoints >> LattName >> stmp; getline(ss_kpoints, stmp);
    ss_kpoints >> KPOINTSGRID >> stmp >> stmp >> stmp; getline(ss_kpoints, stmp);
    getline(ss_kpoints, stmp);
    getline(ss_kpoints, stmp);

    // Get special kpoints from KPOINTS.bands
    // Get Lables of KPOINTS from KPOINTS.bands
    vector<vector<double> > kpoints;  
    vector<string> kpointslabel;      
    int count=0, j=0; //count is the number of rows of kpoints
    while(getline(ss_kpoints, line)) {
      if(aurostd::CountWordsinString(line)>=3) {
        vector<double> kpt_tmp;
        double a1, a2, a3;
        string a5;
        strline.clear();
        strline.str(line);
        strline >> a1 >> a2 >> a3 >> stmp >> a5;
        kpt_tmp.push_back(a1);
        kpt_tmp.push_back(a2);
        kpt_tmp.push_back(a3);
        kpoints.push_back(kpt_tmp);
        kpointslabel.push_back(a5);
        j++;
      }
      count = j;
    }
    //*******************************Redefine the symbols of special kpoints
    for (int i=0; i< count; i++) {kpointslabel[i]=fixKPOINT_GNUPLOT(kpointslabel[i]);}  //CO20170831 - fix all at once
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //Combine the Labels of special kpoints	
    for (int i=1; i< (count-1); i=i+2) {
      if(kpointslabel[i].compare(kpointslabel[i+1])!=0) {
        bool need_space=!aurostd::substring2bool(kpointslabel[i],"_"); //CO20170830 - if subscript, extra space looks ODD!
        string newlabel = aurostd::attach(kpointslabel[i]+(need_space?" ":""),kpointslabel[i+1]);  //CO20170830 - italics and make space for first italics
        kpointslabel[i] = newlabel;
        kpointslabel[i+1] = newlabel;
      }
    }
    //*******************************Redefine the symbols of special kpoints

    //Converting kpoints into Cartesian
    vector<vector<double> > kpcart;
    for (int i=0; i<count; i++) {
      vector<double> kpcart_tmp;
      double c1=0, c2=0, c3=0;
      c1=kpoints[i][0]*b1[1]+kpoints[i][1]*b2[1]+kpoints[i][2]*b3[1];
      c2=kpoints[i][0]*b1[2]+kpoints[i][1]*b2[2]+kpoints[i][2]*b3[2];
      c3=kpoints[i][0]*b1[3]+kpoints[i][1]*b2[3]+kpoints[i][2]*b3[3];
      kpcart_tmp.push_back(c1);
      kpcart_tmp.push_back(c2);
      kpcart_tmp.push_back(c3);
      kpcart.push_back(kpcart_tmp);
    }

    //Check number of kpoints
    if((count/2)*KPOINTSGRID!=NKPOINTS) {
      //  if(LDEBUG) cerr << function_name << " [26]" << endl;
      message << "ERROR: Please check your KPOINTS.bands and EIGENVALE.bands files! The number of kpoints are different!!!";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_VALUE_ERROR_);
    }

    //Calcuating klinedirect from the direct points
    vector<double> klinecart(NKPOINTS); 	
    double koffset=0;
    double kx1, ky1, kz1, kx2, ky2, kz2, dkx, dky, dkz, dk;
    int ind=0;
    for (int i=0; i<count/2; i++) {
      j=2*i;
      kx1=kpcart[j][0]; ky1=kpcart[j][1]; kz1=kpcart[j][2];
      kx2=kpcart[j+1][0]; ky2=kpcart[j+1][1]; kz2=kpcart[j+1][2];
      dkx = kx2-kx1;
      dky = ky2-ky1;
      dkz = kz2-kz1;
      dk= (sqrt(dkx*dkx + dky*dky +dkz*dkz))/(KPOINTSGRID-1);
      klinecart[ind]=koffset; ind++;
      for (int ii=1; ii<KPOINTSGRID; ii++) {
        klinecart[ind]= koffset + ii*dk;
        ind++;
      }
      koffset = koffset + dk*(KPOINTSGRID-1);
    }

    //*******************************Redefine the symbols of special kpoints
    //CO20170830 - already done above ?? - not sure why we do twice...
    //[OBSOLETE]for (int i=0; i< count; i++) {
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]}
    //[OBSOLETE]//Combine the Labels of special kpoints	
    //[OBSOLETE]for (int i=1; i< (count-1); i=i+2) {
    //[OBSOLETE]  if(kpointslabel[i].compare(kpointslabel[i+1])!=0) {
    //[OBSOLETE]    string newlabel = aurostd::attach(fixKPOINT(kpointslabel[i])+" ",fixKPOINT(kpointslabel[i+1]));  //CO20170830 - italics and make space for first italics
    //[OBSOLETE]    kpointslabel[i] = newlabel;
    //[OBSOLETE]    kpointslabel[i+1] = newlabel;
    //[OBSOLETE]  } else {
    //[OBSOLETE]    kpointslabel[i] = fixKPOINT(kpointslabel[i]); //CO20170830 - italics
    //[OBSOLETE]    kpointslabel[i+1] = fixKPOINT(kpointslabel[i+1]); //CO20170830 - italics
    //[OBSOLETE]  }
    //[OBSOLETE]}
    //*******************************Redefine the symbols of special kpoints

    //**************************************Redefine the cartesian coordinates of special kpoints****************************************
    vector<double>  SPKPOINTScart(count);
    vector<double>  SPKPOINTScart_LABEL(count);

    //Get the cartesian coordinates of the special kpoints and store them into SPKPOINTScart
    for (int i=0; i<count; i=i+2) {
      SPKPOINTScart[i]=klinecart[(i/2)*(KPOINTSGRID)];
      SPKPOINTScart[i+1]=klinecart[(i/2+1)*(KPOINTSGRID)-1];
    }
    //NO SHIFT - CO20170830
    for (int i=0; i< count; i=i+2) {SPKPOINTScart_LABEL[i]=SPKPOINTScart[i];}
    SPKPOINTScart_LABEL[count-1]=SPKPOINTScart[count-1];
    //Shifting the cartesian coordinates of special KPOINTS;
    //[OBSOLETE]for (int i=0; i< count; i=i+2) {
    //[OBSOLETE]  if(kpointslabel[i].size()==1)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.006;
    //[OBSOLETE]  else if(kpointslabel[i].size()==3)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.018;
    //[OBSOLETE]  else if(kpointslabel[i].size()==5)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.030;
    //[OBSOLETE]  else  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i];
    //[OBSOLETE]}
    //[OBSOLETE]SPKPOINTScart_LABEL[count-1]=SPKPOINTScart[count-1]-0.006;
    //**************************************Redefine the cartesian coordinates of special kpoints****************************************

    string bandsdatafile = ICSDName + "_BANDS.dat";
    ofstream bandsfin;
    bandsfin.open(bandsdatafile.c_str());
    bandsfin.setf(ios_base::fixed,ios_base::floatfield);  //Formating output
    bandsfin.precision(4);
    vector<vector<double> > bandsdata(NKPOINTS);
    //Writing bands data into file
    if(ISPIN==1) {	
      for (int i=0; i<NKPOINTS; i++) {
        bandsdata[i].resize(Nbands+1);
        bandsdata[i][0]=klinecart[i];
      }
      for (int i=0; i<NKPOINTS; i++)
        for (int ib=0; ib<Nbands; ib++) {
          bandsdata[i][ib+1]=dataup[i][ib]-Efermi;  //Zero point Shifts to Efermi
        }

      for (int ik=0;ik<NKPOINTS;ik++) {
        for (int ib=0; ib<Nbands+1; ib++) {
          bandsfin << bandsdata[ik][ib] << "  " ;
        }
        bandsfin << endl;
      }
      bandsfin.close();
    }
    //Spin-polarized
    if(ISPIN==2) {	
      for (int i=0; i<NKPOINTS; i++) {
        bandsdata[i].resize(2*Nbands+1);
        bandsdata[i][0]=klinecart[i];
      }
      for (int i=0; i<NKPOINTS; i++)
        for (int ib=0; ib<Nbands; ib++) {
          bandsdata[i][2*ib+1]=dataup[i][ib]-Efermi;  //Zero point Shifts to Efermi
          bandsdata[i][2*ib+2]=datadn[i][ib]-Efermi;  //Zero point Shifts to Efermi
        }
      for (int ik=0;ik<NKPOINTS;ik++) {
        for (int ib=0; ib<2*Nbands+1; ib++) {
          bandsfin << bandsdata[ik][ib] << "  " ;
        }
        bandsfin << endl;
      }
      bandsfin.close();
    }

    //***********************************GENERATING GNUPLOT SCRIPT**************************************************************
    //Writing Gnuplot Script
    string gnuplotscript = aurostd::ProperFileName("GNUPLOT_" + ICSDName + ".gp");
    ofstream fin;
    fin.open(gnuplotscript.c_str());
    fin << "#Generated by AFLOW (Kesong Yang [kesong.yang@gmail.com], 2011, Duke University)" << endl;
    fin << "set term postscript eps enhanced color font \"Helvetica, 40\" size 18, 10.125" << endl;
    fin << "set output " << "\"" << ICSDName <<".eps" << "\"" << endl;
    fin << "set multiplot title \"" << estructure::changeICSDNameGunplot(ICSDName) << " (" << LattName << ")" << "\""<< endl;
    fin << "set label '" << AFLOWLIB_CONSORTIUM_STRING << "' at screen 0.75, 0.02 font \"Helvetica, 32\"" << endl;
    //fin << "set border lw 5" << endl; //CO20170830 - thick border
    fin << "unset border" << endl; //CO20170830 - looks better
    fin << "set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb '#E4E4E4' behind fs noborder" << endl;  //CO20170830 - gray background
    fin << "set grid back lt 1 lc rgb 'white' lw 5" << endl; //CO20170830 - white grid
    //fin << "set label 'Generated by AFLOW (Kesong Yang \\& Stefano Curtarolo)' at screen 0.985, 0.5 font \"Helvetica, 22\" rotate by -90 center " << endl;
    fin << endl;

    fin << "#DOS PLOT" << endl;
    fin << "set lmargin at screen 0.72" << endl;
    fin << "set rmargin at screen 0.98" << endl;
    fin << "set tmargin at screen 0.94" << endl;
    fin << "set bmargin at screen 0.09" << endl;
    fin << "set title 'eDOS (states/eV)' offset 0,-0.7" << endl;
    fin << "set xtics " << endl;
    //fin << "unset ytics" << endl;
    fin << "set ytics " << endl;
    fin << "set format y \"\"" << endl; //CO20170830 - keep grid
    fin << "set yrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
    if(TOTALPDOS.at(0).size()==9||(TOTALPDOS.at(0).size()==7)) {
      if(DOSMAX*DOSSCALE!=0) {
        fin << "set xrange [" << DOSMAX*DOSSCALE*(-1) <<":"  << DOSMAX*DOSSCALE << "]" << endl;
      }
      else {
        fin << "set xrange [0:2]" << endl;
      }
    }
    if(TOTALPDOS.at(0).size()==4||(TOTALPDOS.at(0).size()==5)) {
      if(DOSMAX*DOSSCALE!=0) {
        fin << "set xrange [0:" << DOSMAX*DOSSCALE << "]" << endl;
      }
    }
    fin << endl;
    fin << "set arrow from 0, 0 to graph 1, first 0 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
    fin << "set arrow from 0, 0 to graph 0, first 0 nohead lt 3 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
    fin << "set key font \"Helvetica, 40\"" << endl; 	
    fin << endl;
    fin << "plot[][] \\" << endl;
    if(TOTALPDOS.at(0).size()==4) { // Only works for s, p and d orbitals  
      fin << "\"" << dosdatafile << "\"" << " u 2:1 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 3:1 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 4:1 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
    }
    if(TOTALPDOS.at(0).size()==5) { // Works for s, p, d and f orbitals    
      fin << "\"" << dosdatafile << "\"" << " u 2:1 w l lt 1 lc rgb '#4C72B0' lw 6 title '{/Helvetica-Oblique s}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 3:1 w l lt 1 lc rgb '#55A868' lw 6 title '{/Helvetica-Oblique p}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 4:1 w l lt 1 lc rgb '#C44E52' lw 6 title '{/Helvetica-Oblique d}', \\" << endl;
      fin << "\"" << dosdatafile << "\"" << " u 5:1 w l lt 1 lc rgb '#8172B2' lw 6 title '{/Helvetica-Oblique f}', \\" << endl;
    }
    fin << endl;
    fin << endl;

    fin << "#BANDS PLOT" << endl;
    fin << "set lmargin at screen 0.06" << endl;
    fin << "set rmargin at screen 0.7" << endl;
    fin << "set tmargin at screen 0.94" << endl;
    fin << "set bmargin at screen 0.09" << endl;
    fin << endl;
    fin << "unset title" << endl;
    fin << "unset key" << endl;
    fin << "unset xtics" << endl;
    //CO20170830 - add tics at the right spot, but leave labels out - START
    fin << "set xtics (";
    for (int i=0; i< count; i=i+2) {
      fin << "\"" << kpointslabel[i] <<"\"";
      fin << " " << SPKPOINTScart_LABEL[i] << ",";
    } //(i+2<count ? "," : "" );
    fin << "\"" << kpointslabel[count-1] <<"\"";
    fin << " " << SPKPOINTScart_LABEL[count-1] << ")" << endl;
    fin << "set format x \"\"" << endl;
    fin << "unset format y" << endl;
    //CO20170830 - add tics at the right spot, but leave labels out - STOP
    fin << "set ytics" << endl;
    fin << "set xrange [* : *]" << endl;
    fin << "set yrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
    fin << "set ylabel 'energy (eV)' offset graph 0.002" << endl;
    fin << endl;
    //CO20170831 - now we do with xtics - START
    //[OBSOLETE]for (int i=0; i< count; i=i+2) {
    //[OBSOLETE]  if(kpointslabel[i].compare("G")==0) {
    //[OBSOLETE]fin << "set label " << "\"{/Symbol G}\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
    //[OBSOLETE]}
    //[OBSOLETE]else if(kpointslabel[i].compare("Sigm")==0) {
    //[OBSOLETE]fin << "set label " << "\"{/Symbol-Oblique S}\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
    //[OBSOLETE]}
    //[OBSOLETE]else if(kpointslabel[i].compare("Sigm_1")==0) {
    //[OBSOLETE]fin << "set label " << "\"{/Symbol-Oblique S}" << "_1\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
    //[OBSOLETE]}
    //[OBSOLETE]else {
    //[OBSOLETE]fin << "set label " << "\"" << kpointslabel[i] <<"\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
    //[OBSOLETE]}
    //[OBSOLETE]}
    //[OBSOLETE]fin << "set label " << "\"" << kpointslabel[count-1] <<"\"" << " center at " << SPKPOINTScart_LABEL[count-1] <<", " << "graph - 0.03" << endl;	
    //CO20170831 - now we do with xtics - STOP
    //CO20170830 - manual grid not needed - START
    //for (int i=0; i< count; i=i+2) {
    //  fin << "set arrow from first  " << SPKPOINTScart[i] <<", graph 0 to first " << SPKPOINTScart[i] <<", graph 1 nohead lt 1 lc rgb 'white' lw 5" << endl;
    //}
    //CO20170830 - manual grid not needed - STOP
    fin << endl;
    fin << "set arrow from 0, 0 to graph 1, first 0 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
    fin << endl;
    fin << "plot[][] \\" << endl;
    for (unsigned int i=1; i<(bandsdata.at(0).size()-1); i++) {
      fin << "\"" << bandsdatafile << "\"" << " u 1:" << i+1 << " w l lt -1 lw 3, \\" << endl;
    }
    fin << "\"" << bandsdatafile << "\"" << " u 1:" << bandsdata.at(0).size() << " w l lt -1 lw 3" << endl;

    fin.close();

    //Call gnuplot to plot the bands structure	
    aurostd::execute(XHOST.command("gnuplot")+" " + gnuplotscript);
    aurostd::execute(XHOST.command("convert")+" -background white ./" + ICSDName + ".eps  ./" + ICSDName + ".png");
    //KY in the future we can remove these 4 lines, but for now we need to patch plotbz.sh
    if(aurostd::FileExist("bz_.eps")) aurostd::file2file("bz_.eps",ICSDName+"_BZ.eps");
    if(aurostd::FileExist("bz_.png")) aurostd::file2file("bz_.png",ICSDName+"_BZ.png");
    if(aurostd::FileExist("bz_"+ICSDName+".eps")) aurostd::file2file("bz_"+ICSDName+".eps",ICSDName+"_BZ.eps");
    if(aurostd::FileExist("bz_"+ICSDName+".png")) aurostd::file2file("bz_"+ICSDName+".png",ICSDName+"_BZ.png");
    //if(aurostd::FileExist(ICSDName+"_BZ.eps")) aurostd::execute(DEFAULT_KZIP_BIN+" -9f \"" + ICSDName + "_BZ.eps\"");
    if(aurostd::FileExist(ICSDName+"_BZ.eps")) aurostd::RemoveFile(ICSDName + "_BZ.eps");

    //Postprocess
    if(!XHOST.vflag_control.flag("KEEP::GPL")) { 
      aurostd::RemoveFile(bandsdatafile);
      aurostd::RemoveFile(dosdatafile);
      aurostd::RemoveFile(gnuplotscript); //Delete the gnuplot script
    }
    if(!XHOST.vflag_control.flag("KEEP::EPS")) { 
      aurostd::RemoveFile(ICSDName + ".eps");
    }
    if(LDEBUG) cerr << function_name << " END" << endl;
  }
}

// ***************************************************************************
// estructure::PLOT_BAND(string options)
// ***************************************************************************
namespace estructure {
  void PLOT_BAND_SPINSPLIT(string options) {
    //Generate bandstructure plot using GNUPLOT
    //In this function, the spin-polarized DOS plot can be generated!
    //Usage: aflow --plotband_spinsplit[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]
    //The following files must reside in the directory
    //  EIGENVAL.bands
    //  KPOINTS.bands
    //  OUTCAR.bands

    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::PLOT_BAND_SPINSPLIT():";
    stringstream message;
    if(LDEBUG) cerr << function_name << " BEGIN" << endl;

    vector<string> tokens;
    aurostd::string2tokens(options,tokens,",");
    double DOS_Emin=DEFAULT_DOS_EMIN,DOS_Emax=DEFAULT_DOS_EMAX,DOSSCALE=DEFAULT_DOS_SCALE;  // some defaults

    if(LDEBUG) cerr << function_name << " options=[" << options << "]" << endl;
    if(LDEBUG) cerr << function_name << " tokens.size()=" << tokens.size() << endl;
    if(LDEBUG) for(uint i=0;i<tokens.size();i++) cerr << function_name << " tokens.at(i)=" << tokens.at(i) << endl;

    int ISPIN=1,NIONS, NELECT, Nbands, NKPOINTS, KPOINTSGRID;
    double Efermi, ftmp, ftmpup, ftmpdn;
    string directory="./", LattName, ICSDName, POSCARfile, KPOINTSfile, stmp, line;
    // [OBSOLETE]  string EIGENVALfile, DOSCARfile, OUTCARfile, KPOINTSfile
    bool found=FALSE;

    stringstream straus, stringstreamtmp, strline; //, dosfile; //, stringstreamtmp, strline;  

    if(tokens.size()<1) {
      init::ErrorOption(options,function_name,"aflow -plotband_spinsplit[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]");
    }
    if(tokens.size()>=1) directory = tokens.at(0);
    if(tokens.size()>=2) DOS_Emin = aurostd::string2utype<double>(tokens.at(1)); 
    if(tokens.size()>=3) DOS_Emax = aurostd::string2utype<double>(tokens.at(2));
    if(tokens.size()>=4) DOSSCALE = aurostd::string2utype<double>(tokens.at(3));

    if(LDEBUG) cerr << function_name << " directory=[" << directory << "]" << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emin=" << DOS_Emin << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emax=" << DOS_Emax << endl;
    if(LDEBUG) cerr << function_name << " DOSSCALE=" << DOSSCALE << endl;

    cout << function_name << " working in directory=" << directory << endl;

    ICSDName=KBIN::ExtractSystemName(directory); //Get SystemName

    found=FALSE;

    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(!found&&aurostd::FileExist(directory+"/OUTCAR.bands"+XHOST.vext.at(iext)))
        found=aurostd::efile2stringstream(directory+"/OUTCAR.bands"+XHOST.vext.at(iext),straus);
    }
    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(!found&&aurostd::FileExist(directory+"/OUTCAR"+XHOST.vext.at(iext)))
        found=aurostd::efile2stringstream(directory+"/OUTCAR"+XHOST.vext.at(iext),straus);
    }  
    if(!found) {
      message << "OUTCAR[.bands][.EXT] not found in the directory, aborting.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_FILE_NOT_FOUND_);
    }

    //GET Fermi Level, Number of IONS
    //GET lattice vector and reciprocal lattice vectors
    string anchor_word_Efermi = "E-fermi";
    string anchor_word_NIONS = "NIONS";
    string anchor_word_vc = "volume of cell";
    string anchor_word_LSORBIT="LSORBIT =      T";
    xvector<double> a1(3); xvector<double> a2(3); xvector<double> a3(3);
    xvector<double> b1(3); xvector<double> b2(3); xvector<double> b3(3);
    while(getline(straus, line)) {
      if(line.find(anchor_word_Efermi) !=string::npos) {
        strline.clear();	
        strline.str(line);
        strline >> stmp >> stmp >> Efermi;
      }
      if(line.find(anchor_word_NIONS) !=string::npos) {
        strline.clear();	
        strline.str(line);
        strline >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> NIONS;
      }
      if(line.find(anchor_word_vc) !=string::npos) {
        getline(straus, line); straus >> a1[1] >> a1[2] >> a1[3] >> b1[1] >> b1[2] >> b1[3];
        getline(straus, line); straus >> a2[1] >> a2[2] >> a2[3] >> b2[1] >> b2[2] >> b2[3];
        getline(straus, line); straus >> a3[1] >> a3[2] >> a3[3] >> b3[1] >> b3[2] >> b3[3];	
      }
    }

    //***********************************DEALING WITH BANDSDATA**************************************************************
    //READ EIGENVAL    
    found=FALSE;
    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(!found&&aurostd::FileExist(directory+"/EIGENVAL.bands"+XHOST.vext.at(iext)))
        found=aurostd::efile2stringstream(directory+"/EIGENVAL.bands"+XHOST.vext.at(iext),straus);
    }
    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(!found&&aurostd::FileExist(directory+"/EIGENVAL"+XHOST.vext.at(iext)))
        found=aurostd::efile2stringstream(directory+"/EIGENVAL"+XHOST.vext.at(iext),straus);
    }
    if(!found) {
      message << "EIGENVAL[.bands][.EXT] not found in the directory, aborting.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_FILE_NOT_FOUND_);
    }

    //Read FLAG of SPIN, if SPIN=1,Non-spin-polarized; IF SPIN=2, spin-polarized
    straus >> stmp >> stmp >> stmp >> ISPIN;	

    //Read the headfile of EIGENVAL	
    for(int i=0; i< 5; i++) getline(straus, stmp);
    straus >> NELECT >> NKPOINTS >> Nbands;
    getline(straus, stmp);  //Read the line containing NELECT, NKPOINTS, NBANDS

    //Creating data to store bands data
    vector<vector<double> > datakpoints(NKPOINTS);
    vector<vector<double> > dataup(NKPOINTS); //Define two-dimensional arrary
    vector<vector<double> > datadn(NKPOINTS); //Define two-dimensional arrary
    for (int i=0; i<NKPOINTS; i++) {
      datakpoints[i].resize(3);
    }
    for (int i=0; i<NKPOINTS; i++) {
      dataup[i].resize(Nbands); datadn[i].resize(Nbands);
    }
    //Obtain the bands data and store them into dataup and datadn, respectively
    if(ISPIN==1) {
      for(int ik=0; ik< NKPOINTS; ik++) {
        getline(straus, stmp); //Negelecting empty line
        straus >> datakpoints[ik][0] >> datakpoints[ik][1] >> datakpoints[ik][2];	
        getline(straus, stmp); //Negelecting kpoint coordinate
        int ib=-1;	
        for(int i=0; i<Nbands; i++) {
          straus>>ftmp>>ftmp;
          ib=ib+1;
          dataup[ik][ib]=ftmp;
        }
        getline(straus,stmp);
      }
    }
    else if(ISPIN==2) {
      for(int ik=0; ik< NKPOINTS; ik++) {
        getline(straus, stmp); //Negelecting empty line
        straus >> datakpoints[ik][0] >> datakpoints[ik][1] >> datakpoints[ik][2];	
        getline(straus, stmp); //Negelecting kpoint coordinate
        int ib=-1;	
        for(int i=0; i<Nbands; i++) {
          straus>>ftmp>>ftmpup>>ftmpdn;
          ib=ib+1;
          dataup[ik][ib]=ftmpup;
          datadn[ik][ib]=ftmpdn;
        }
        getline(straus,stmp);
      }
    }
    else {
      message << "Can not detect spin flag! Error, Aborting!";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_RUNTIME_ERROR_);
    }

    //READ KPOINTS	
    found=FALSE;
    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(!found&&aurostd::FileExist(directory+"/KPOINTS.bands"+XHOST.vext.at(iext)))
        found=aurostd::efile2stringstream(directory+"/KPOINTS.bands"+XHOST.vext.at(iext),straus);
    }
    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(!found&&aurostd::FileExist(directory+"/KPOINTS"+XHOST.vext.at(iext)))
        found=aurostd::efile2stringstream(directory+"/KPOINTS"+XHOST.vext.at(iext),straus);
    }
    if(!found) {
      message << "KPOINTS[.bands][.EXT] not found in the directory, aborting.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_FILE_NOT_FOUND_);
    }

    straus >> LattName >> stmp; getline(straus, stmp);
    straus >> KPOINTSGRID >> stmp >> stmp >> stmp; getline(straus, stmp);
    getline(straus, stmp);
    getline(straus, stmp);

    // Get special kpoints from KPOINTS.bands
    // Get Lables of KPOINTS from KPOINTS.bands
    vector<vector<double> > kpoints;  
    vector<string> kpointslabel;      
    int count=0, j=0; //count is the number of rows of kpoints
    while(getline(straus, line)) {
      if(aurostd::CountWordsinString(line)>=3) {
        vector<double> kpt_tmp;
        double a1, a2, a3;
        string a5;
        strline.clear();
        strline.str(line);
        strline >> a1 >> a2 >> a3 >> stmp >> a5;
        kpt_tmp.push_back(a1);
        kpt_tmp.push_back(a2);
        kpt_tmp.push_back(a3);
        kpoints.push_back(kpt_tmp);
        kpointslabel.push_back(a5);
        j++;
      }
      count = j;
    }
    //*******************************Redefine the symbols of special kpoints
    for (int i=0; i< count; i++) {kpointslabel[i]=fixKPOINT_GNUPLOT(kpointslabel[i]);}  //CO20170831 - fix all at once
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //Combine the Labels of special kpoints	
    for (int i=1; i< (count-1); i=i+2) {
      if(kpointslabel[i].compare(kpointslabel[i+1])!=0) {
        bool need_space=!aurostd::substring2bool(kpointslabel[i],"_"); //CO20170830 - if subscript, extra space looks ODD!
        string newlabel = aurostd::attach(kpointslabel[i]+(need_space?" ":""),kpointslabel[i+1]);  //CO20170830 - italics and make space for first italics
        kpointslabel[i] = newlabel;
        kpointslabel[i+1] = newlabel;
      }
    }
    //*******************************Redefine the symbols of special kpoints

    //Converting kpoints into Cartesian
    vector<vector<double> > kpcart;
    for (int i=0; i<count; i++) {
      vector<double> kpcart_tmp;
      double c1=0, c2=0, c3=0;
      c1=kpoints[i][0]*b1[1]+kpoints[i][1]*b2[1]+kpoints[i][2]*b3[1];
      c2=kpoints[i][0]*b1[2]+kpoints[i][1]*b2[2]+kpoints[i][2]*b3[2];
      c3=kpoints[i][0]*b1[3]+kpoints[i][1]*b2[3]+kpoints[i][2]*b3[3];
      kpcart_tmp.push_back(c1);
      kpcart_tmp.push_back(c2);
      kpcart_tmp.push_back(c3);
      kpcart.push_back(kpcart_tmp);
    }

    //Check number of kpoints
    if((count/2)*KPOINTSGRID!=NKPOINTS) {
      //    if(LDEBUG) cerr << function_name << " [36]" << endl;
      message << "Please check your KPOINTS.bands and EIGENVAL.bands files! The number of kpoints are different!!!" << endl;
      message << "KPOINTSGRID=" << KPOINTSGRID << endl;
      message << "NKPOINTS=" << NKPOINTS << endl;
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_VALUE_ERROR_);
    }

    //Calcuating klinedirect from the direct points
    vector<double> klinecart(NKPOINTS); 	
    double koffset=0;
    double kx1, ky1, kz1, kx2, ky2, kz2, dkx, dky, dkz, dk;
    int ind=0;
    for (int i=0; i<count/2; i++) {
      j=2*i;
      kx1=kpcart[j][0]; ky1=kpcart[j][1]; kz1=kpcart[j][2];
      kx2=kpcart[j+1][0]; ky2=kpcart[j+1][1]; kz2=kpcart[j+1][2];
      dkx = kx2-kx1;
      dky = ky2-ky1;
      dkz = kz2-kz1;
      dk= (sqrt(dkx*dkx + dky*dky +dkz*dkz))/(KPOINTSGRID-1);
      klinecart[ind]=koffset; ind++;
      for (int ii=1; ii<KPOINTSGRID; ii++) {
        klinecart[ind]= koffset + ii*dk;
        ind++;
      }
      koffset = koffset + dk*(KPOINTSGRID-1);
    }

    //*******************************Redefine the symbols of special kpoints
    //CO20170830 - already done above ?? - not sure why we do twice...
    //[OBSOLETE]for (int i=0; i< count; i++) {
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]  if(kpointslabel[i].compare("\\Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]  if(kpointslabel[i].compare("Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]}
    //[OBSOLETE]//Combine the Labels of special kpoints	
    //[OBSOLETE]for (int i=1; i< (count-1); i=i+2) {
    //[OBSOLETE]  if(kpointslabel[i].compare(kpointslabel[i+1])!=0) {
    //[OBSOLETE]    string newlabel = aurostd::attach(fixKPOINT(kpointslabel[i])+" ",fixKPOINT(kpointslabel[i+1]));  //CO20170830 - italics and make space for first italics
    //[OBSOLETE]    kpointslabel[i] = newlabel;
    //[OBSOLETE]    kpointslabel[i+1] = newlabel;
    //[OBSOLETE]  } else {
    //[OBSOLETE]    kpointslabel[i] = fixKPOINT(kpointslabel[i]); //CO20170830 - italics
    //[OBSOLETE]    kpointslabel[i+1] = fixKPOINT(kpointslabel[i+1]); //CO20170830 - italics
    //[OBSOLETE]  }
    //[OBSOLETE]}
    //*******************************Redefine the symbols of special kpoints

    //**************************************Redefine the cartesian coordinates of special kpoints****************************************
    vector<double>  SPKPOINTScart(count);
    vector<double>  SPKPOINTScart_LABEL(count);

    //Get the cartesian coordinates of the special kpoints and store them into SPKPOINTScart
    for (int i=0; i<count; i=i+2) {
      SPKPOINTScart[i]=klinecart[(i/2)*(KPOINTSGRID)];
      SPKPOINTScart[i+1]=klinecart[(i/2+1)*(KPOINTSGRID)-1];
    }
    //NO SHIFT - CO20170830
    for (int i=0; i< count; i=i+2) {SPKPOINTScart_LABEL[i]=SPKPOINTScart[i];}
    SPKPOINTScart_LABEL[count-1]=SPKPOINTScart[count-1];
    //Shifting the cartesian coordinates of special KPOINTS;
    //[OBSOLETE]for (int i=0; i< count; i=i+2) {
    //[OBSOLETE]  if(kpointslabel[i].size()==1)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.006;
    //[OBSOLETE]  else if(kpointslabel[i].size()==3)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.018;
    //[OBSOLETE]  else if(kpointslabel[i].size()==5)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.030;
    //[OBSOLETE]  else  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i];
    //[OBSOLETE]}
    //[OBSOLETE]SPKPOINTScart_LABEL[count-1]=SPKPOINTScart[count-1]-0.006;
    //**************************************Redefine the cartesian coordinates of special kpoints****************************************

    string bandsdatafile = ICSDName + "_BANDS.dat";
    ofstream bandsfin;
    bandsfin.open(bandsdatafile.c_str());
    bandsfin.setf(ios_base::fixed,ios_base::floatfield);  //Formating output
    bandsfin.precision(4);
    vector<vector<double> > bandsdata(NKPOINTS);
    //Writing bands data into file
    if(ISPIN==1) {	
      for (int i=0; i<NKPOINTS; i++) {
        bandsdata[i].resize(Nbands+1);
        bandsdata[i][0]=klinecart[i];
      }
      for (int i=0; i<NKPOINTS; i++)
        for (int ib=0; ib<Nbands; ib++) {
          bandsdata[i][ib+1]=dataup[i][ib]-Efermi;  //Zero point Shifts to Efermi
        }

      for (int ik=0;ik<NKPOINTS;ik++) {
        for (int ib=0; ib<Nbands+1; ib++) {
          bandsfin << bandsdata[ik][ib] << "  " ;
        }
        bandsfin << endl;
      }
      bandsfin.close();
    }
    //Spin-polarized
    if(ISPIN==2) {	
      for (int i=0; i<NKPOINTS; i++) {
        bandsdata[i].resize(2*Nbands+1);
        bandsdata[i][0]=klinecart[i];
      }
      for (int i=0; i<NKPOINTS; i++)
        for (int ib=0; ib<Nbands; ib++) {
          bandsdata[i][2*ib+1]=dataup[i][ib]-Efermi;  //Zero point Shifts to Efermi
          bandsdata[i][2*ib+2]=datadn[i][ib]-Efermi;  //Zero point Shifts to Efermi
        }
      for (int ik=0;ik<NKPOINTS;ik++) {
        for (int ib=0; ib<2*Nbands+1; ib++) {
          bandsfin << bandsdata[ik][ib] << "  " ;
        }
        bandsfin << endl;
      }
      bandsfin.close();
    }

    //***********************************GENERATING GNUPLOT SCRIPT**************************************************************
    //Writing Gnuplot Script

    if(ISPIN==1) {
      string gnuplotscript = aurostd::ProperFileName("GNUPLOT_" + ICSDName + ".gp");
      ofstream fin;
      fin.open(gnuplotscript.c_str());
      fin << "#Generated by AFLOW (Kesong Yang [kesong.yang@gmail.com], 2011, Duke University)" << endl;
      fin << "set term postscript eps enhanced color font \"Helvetica, 40\" size 18, 10.125" << endl;
      fin << "set output " << "\"" << ICSDName <<"_BANDS.eps" << "\"" << endl;
      fin << "set title \"" << estructure::changeICSDNameGunplot(ICSDName) << " (" << LattName << ") " << "\""<< endl;
      fin << "set label '" << AFLOWLIB_CONSORTIUM_STRING << "' at screen 0.75, 0.02 font \"Helvetica, 32\"" << endl;
      //fin << "set border lw 5" << endl; //CO20170830 - thick border
      fin << "unset border" << endl; //CO20170830 - looks better
      fin << "set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb '#E4E4E4' behind fs noborder" << endl;  //CO20170830 - gray background
      fin << "set grid back lt 1 lc rgb 'white' lw 5" << endl; //CO20170830 - white grid
      //fin << "set label 'Generated by AFLOW (Kesong Yang \\& Stefano Curtarolo)' at screen 0.985, 0.5 font \"Helvetica, 22\" rotate by -90 center " << endl;
      fin << endl;
      fin << "set tmargin at screen 0.94" << endl;
      fin << "set bmargin at screen 0.08" << endl;

      fin << "unset key" << endl;
      fin << "unset xtics" << endl;
      //CO20170830 - add tics at the right spot, but leave labels out - START
      fin << "set xtics (";
      for (int i=0; i< count; i=i+2) {
        fin << "\"" << kpointslabel[i] <<"\"";
        fin << " " << SPKPOINTScart_LABEL[i] << ",";
      } //(i+2<count ? "," : "" );
      fin << "\"" << kpointslabel[count-1] <<"\"";
      fin << " " << SPKPOINTScart_LABEL[count-1] << ")" << endl;
      fin << "set format x \"\"" << endl;
      fin << "unset format y" << endl;
      //CO20170830 - add tics at the right spot, but leave labels out - STOP
      fin << "set ytics" << endl;
      fin << "set xrange [* : *]" << endl;
      fin << "set yrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
      fin << "set ylabel 'energy (eV)' offset graph 0.002" << endl;
      fin << endl;
      //CO20170831 - now we do with xtics - START
      //[OBSOLETE]for (int i=0; i< count; i=i+2) {
      //[OBSOLETE]if(kpointslabel[i].compare("G")==0) {
      //[OBSOLETE]fin << "set label " << "\"{/Symbol G}\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]}
      //[OBSOLETE]else if(kpointslabel[i].compare("Sigm")==0) {
      //[OBSOLETE]fin << "set label " << "\"{/Symbol-Oblique S}\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]}
      //[OBSOLETE]else if(kpointslabel[i].compare("Sigm_1")==0) {
      //[OBSOLETE]fin << "set label " << "\"{/Symbol-Oblique S}" << "_1\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]}
      //[OBSOLETE]else {
      //[OBSOLETE]fin << "set label " << "\"" << kpointslabel[i] <<"\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]}
      //[OBSOLETE]}
      //[OBSOLETE]fin << "set label " << "\"" << kpointslabel[count-1] <<"\"" << " center at " << SPKPOINTScart_LABEL[count-1] <<", " << "graph - 0.03" << endl;	
      //CO20170831 - now we do with xtics - STOP
      //CO20170830 - manual grid not needed - START
      //for (int i=0; i< count; i=i+2) {
      //  fin << "set arrow from first  " << SPKPOINTScart[i] <<", graph 0 to first " << SPKPOINTScart[i] <<", graph 1 nohead lt 1 lc rgb 'white' lw 5" << endl;
      //}
      //CO20170830 - manual grid not needed - STOP
      fin << endl;
      fin << "set arrow from 0, 0 to graph 1, first 0 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
      fin << endl;
      fin << "plot[][] \\" << endl;
      for (unsigned int i=1; i<(bandsdata.at(0).size()-1); i++) {
        fin << "\"" << bandsdatafile << "\"" << " u 1:" << i+1 << " w l lt -1 lw 3, \\" << endl;
      }
      fin << "\"" << bandsdatafile << "\"" << " u 1:" << bandsdata.at(0).size() << " w l lt -1 lw 3" << endl;
      fin.close();

      //Call gnuplot to plot the bands structure	
      aurostd::execute(XHOST.command("gnuplot")+" " + gnuplotscript);
      aurostd::execute(XHOST.command("convert")+" -background white ./" + ICSDName + "_BANDS.eps  ./" + ICSDName + "_BANDS.png");
    }

    if(ISPIN==2) {
      string gnuplotscriptup = aurostd::ProperFileName("GNUPLOT_" + ICSDName + "_BANDS_UP.gp");
      ofstream finup;
      finup.open(gnuplotscriptup.c_str());
      finup << "#Generated by AFLOW (Kesong Yang [kesong.yang@gmail.com], 2011, Duke University)" << endl;
      finup << "set term postscript eps enhanced color font \"Helvetica, 40\" size 18, 10.125" << endl;
      finup << "set output " << "\"" << ICSDName <<"_BANDS_UP.eps" << "\"" << endl;
      finup << "set title \"" << estructure::changeICSDNameGunplot(ICSDName) << " (" << LattName << ") BANDS\\\\_UP" << "\""<< endl;
      finup << "set label '" << AFLOWLIB_CONSORTIUM_STRING << "' at screen 0.75, 0.02 font \"Helvetica, 32\"" << endl;
      //finup << "set border lw 5" << endl; //CO20170830 - thick border
      finup << "unset border" << endl; //CO20170830 - looks better
      finup << "set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb '#E4E4E4' behind fs noborder" << endl;  //CO20170830 - gray background
      finup << "set grid back lt 1 lc rgb 'white' lw 5" << endl; //CO20170830 - white grid
      //finup << "set label 'Generated by AFLOW (Kesong Yang \\& Stefano Curtarolo)' at screen 0.985, 0.5 font \"Helvetica, 22\" rotate by -90 center " << endl;
      finup << endl;
      finup << "set tmargin at screen 0.94" << endl;
      finup << "set bmargin at screen 0.08" << endl;

      finup << "unset key" << endl;
      finup << "unset xtics" << endl;
      //CO20170830 - add tics at the right spot, but leave labels out - START
      finup << "set xtics (";
      for (int i=0; i< count; i=i+2) {
        finup << "\"" << kpointslabel[i] <<"\"";
        finup << " " << SPKPOINTScart_LABEL[i] << ",";
      } //(i+2<count ? "," : "" );
      finup << "\"" << kpointslabel[count-1] <<"\"";
      finup << " " << SPKPOINTScart_LABEL[count-1] << ")" << endl;
      finup << "set format x \"\"" << endl;
      finup << "unset format y" << endl;
      //CO20170830 - add tics at the right spot, but leave labels out - STOP
      finup << "set ytics" << endl;
      finup << "set xrange [* : *]" << endl;
      finup << "set yrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
      finup << "set ylabel 'energy (eV)' offset graph 0.002" << endl;
      finup << endl;
      //CO20170831 - now we do with xtics - START
      //[OBSOLETE]for (int i=0; i< count; i=i+2) {
      //[OBSOLETE]if(kpointslabel[i].compare("G")==0) {
      //[OBSOLETE]finup << "set label " << "\"{/Symbol G}\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]}
      //[OBSOLETE]else if(kpointslabel[i].compare("Sigm")==0) {
      //[OBSOLETE]finup << "set label " << "\"{/Symbol-Oblique S}\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]}
      //[OBSOLETE]else if(kpointslabel[i].compare("Sigm_1")==0) {
      //[OBSOLETE]finup << "set label " << "\"{/Symbol-Oblique S}" << "_1\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]}
      //[OBSOLETE]else {
      //[OBSOLETE]finup << "set label " << "\"" << kpointslabel[i] <<"\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]}
      //[OBSOLETE]}
      //[OBSOLETE]finup << "set label " << "\"" << kpointslabel[count-1] <<"\"" << " center at " << SPKPOINTScart_LABEL[count-1] <<", " << "graph - 0.03" << endl;	
      //CO20170831 - now we do with xtics - STOP
      //CO20170830 - manual grid not needed - START
      //for (int i=0; i< count; i=i+2) {
      //  finup << "set arrow from first  " << SPKPOINTScart[i] <<", graph 0 to first " << SPKPOINTScart[i] <<", graph 1 nohead lt 1 lc rgb 'white' lw 5" << endl;
      //}
      //CO20170830 - manual grid not needed - STOP
      finup << endl;
      finup << "set arrow from 0, 0 to graph 1, first 0 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
      finup << endl;
      finup << "plot[][] \\" << endl;
      for (unsigned int i=1; i<(bandsdata.at(0).size()-2); i=i+2) {
        finup << "\"" << bandsdatafile << "\"" << " u 1:" << i+1 << " w l lt -1 lw 3, \\" << endl;
      }
      finup << "\"" << bandsdatafile << "\"" << " u 1:" << bandsdata.at(0).size()-1 << " w l lt -1 lw 3" << endl;
      finup.close();

      //spin down
      string gnuplotscriptdn = aurostd::ProperFileName("GNUPLOT_" + ICSDName + "_BANDS_DN.gp");
      ofstream findn;
      findn.open(gnuplotscriptdn.c_str());
      findn << "#Generated by AFLOW (Kesong Yang [kesong.yang@gmail.com], 2011, Duke University)" << endl;
      findn << "set term postscript eps enhanced color font \"Helvetica, 40\" size 18, 10.125" << endl;
      findn << "set output " << "\"" << ICSDName <<"_BANDS_DN.eps" << "\"" << endl;
      findn << "set title \"" << estructure::changeICSDNameGunplot(ICSDName) << " (" << LattName << ") BANDS\\\\_DN" << "\""<< endl;
      findn << "set label '" << AFLOWLIB_CONSORTIUM_STRING << "' at screen 0.75, 0.02 font \"Helvetica, 32\"" << endl;
      //findn << "set border lw 5" << endl; //CO20170830 - thick border
      findn << "unset border" << endl; //CO20170830 - looks better
      findn << "set object 1 rectangle from graph 0,0 to graph 1,1 fc rgb '#E4E4E4' behind fs noborder" << endl;  //CO20170830 - gray background
      findn << "set grid back lt 1 lc rgb 'white' lw 5" << endl; //CO20170830 - white grid
      //findn << "set label 'Generated by AFLOW (Kesong Yang \\& Stefano Curtarolo)' at screen 0.985, 0.5 font \"Helvetica, 22\" rotate by -90 center " << endl;
      findn << endl;

      findn << "set tmargin at screen 0.94" << endl;
      findn << "set bmargin at screen 0.08" << endl;
      findn << "unset key" << endl;
      findn << "unset xtics" << endl;
      //CO20170830 - add tics at the right spot, but leave labels out - START
      findn << "set xtics (";
      for (int i=0; i< count; i=i+2) {
        findn << "\"" << kpointslabel[i] <<"\"";
        findn << " " << SPKPOINTScart_LABEL[i] << ",";
      } //(i+2<count ? "," : "" );
      findn << "\"" << kpointslabel[count-1] <<"\"";
      findn << " " << SPKPOINTScart_LABEL[count-1] << ")" << endl;
      findn << "set format x \"\"" << endl;
      findn << "unset format y" << endl;
      //CO20170830 - add tics at the right spot, but leave labels out - STOP
      findn << "set ytics" << endl;
      findn << "set xrange [* : *]" << endl;
      findn << "set yrange [" << DOS_Emin << ":" << DOS_Emax << "]" << endl;
      findn << "set ylabel 'energy (eV)' offset graph 0.002" << endl;
      findn << endl;
      //CO20170831 - now we do with xtics - START
      //[OBSOLETE]for (int i=0; i< count; i=i+2) {
      //[OBSOLETE]if(kpointslabel[i].compare("G")==0) {
      //[OBSOLETE]findn << "set label " << "\"{/Symbol G}\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]} else if(kpointslabel[i].compare("Sigm")==0) {
      //[OBSOLETE]findn << "set label " << "\"{/Symbol-Oblique S}\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]} else if(kpointslabel[i].compare("Sigm_1")==0) {
      //[OBSOLETE]findn << "set label " << "\"{/Symbol-Oblique S}" << "_1\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]} else {
      //[OBSOLETE]findn << "set label " << "\"" << kpointslabel[i] <<"\"" << " center at " << SPKPOINTScart_LABEL[i] <<", " << "graph - 0.03" << endl;	
      //[OBSOLETE]}
      //[OBSOLETE]}
      //[OBSOLETE]findn << "set label " << "\"" << kpointslabel[count-1] <<"\"" << " center at " << SPKPOINTScart_LABEL[count-1] <<", " << "graph - 0.03" << endl;	
      //CO20170831 - now we do with xtics - STOP
      //CO20170830 - manual grid not needed - START
      //for (int i=0; i< count; i=i+2) {
      //  findn << "set arrow from first  " << SPKPOINTScart[i] <<", graph 0 to first " << SPKPOINTScart[i] <<", graph 1 nohead lt 1 lc rgb 'white' lw 5" << endl;
      //}
      //CO20170830 - manual grid not needed - STOP
      findn << endl;
      findn << "set arrow from 0, 0 to graph 1, first 0 nohead lt 1 lc rgb '#0000FF' lw 10" << endl;  //CO20170830 - originally lt 3 lw 1.5
      findn << endl;
      findn << "plot[][] \\" << endl;
      if(ISPIN==2) {
        for (unsigned int i=1; i<(bandsdata.at(0).size()-2); i=i+2) {
          findn << "\"" << bandsdatafile << "\"" << " u 1:" << i+2 << " w l lt -1 lw 3, \\" << endl;
        }
        findn << "\"" << bandsdatafile << "\"" << " u 1:" << bandsdata.at(0).size() << " w l lt -1 lw 3" << endl;
      }
      findn.close();

      //Call gnuplot to plot the bands structure	
      aurostd::execute(XHOST.command("gnuplot")+" " + gnuplotscriptup);
      aurostd::execute(XHOST.command("gnuplot")+" " + gnuplotscriptdn);
      aurostd::execute(XHOST.command("convert")+" -background white ./" + ICSDName + "_BANDS_UP.eps  ./" + ICSDName + "_BANDS_UP.png");
      aurostd::execute(XHOST.command("convert")+" -background white ./" + ICSDName + "_BANDS_DN.eps  ./" + ICSDName + "_BANDS_DN.png");

      //Postprocess
      if(!XHOST.vflag_control.flag("KEEP::GPL")) { 
        aurostd::RemoveFile(bandsdatafile);
        aurostd::RemoveFile(gnuplotscriptup); //Delete the gnuplot script
        aurostd::RemoveFile(gnuplotscriptdn); //Delete the gnuplot script
      }
    }

    //KY in the future we can remove these 4 lines, but for now we need to patch plotbz.sh
    if(aurostd::FileExist("bz_.eps")) aurostd::file2file("bz_.eps",ICSDName+"_BZ.eps");
    if(aurostd::FileExist("bz_.png")) aurostd::file2file("bz_.png",ICSDName+"_BZ.png");
    if(aurostd::FileExist("bz_"+ICSDName+".eps")) aurostd::file2file("bz_"+ICSDName+".eps",ICSDName+"_BZ.eps");
    if(aurostd::FileExist("bz_"+ICSDName+".png")) aurostd::file2file("bz_"+ICSDName+".png",ICSDName+"_BZ.png");
    //if(aurostd::FileExist(ICSDName+"_BZ.eps")) aurostd::execute(DEFAULT_KZIP_BIN+" -9f \"" + ICSDName + "_BZ.eps\"");

    if(!XHOST.vflag_control.flag("KEEP::EPS")) { 
      if(aurostd::FileExist(ICSDName+"_BZ.eps")) 
        aurostd::RemoveFile(ICSDName + "_BZ.eps");
      if(ISPIN==1) 
        aurostd::RemoveFile(ICSDName + ".eps");
      if(ISPIN==2) {
        aurostd::RemoveFile(ICSDName + "_BANDS_UP.eps");
        aurostd::RemoveFile(ICSDName + "_BANDS_DN.eps");
      }
    }

    // [OBSOLETE] if(aurostd::FileExist(kpointsfile_tmp)) aurostd::RemoveFile(kpointsfile_tmp);
    // [OBSOLETE] if(aurostd::FileExist(eigenvalfile_tmp)) aurostd::RemoveFile(eigenvalfile_tmp);
    // [OBSOLETE] if(aurostd::FileExist(outcarfile_tmp)) aurostd::RemoveFile(outcarfile_tmp);
  }
} // namespace estructure

// ***************************************************************************
// string estructure::changeICSDNameGunplot(string ICSDName)
// ***************************************************************************
namespace estructure {
  string changeICSDNameGunplot(string ICSDName) {
    string ICSDNameNew;
    for (uint i=0; i<ICSDName.size(); i++) {
      char ch = ICSDName.at(i);
      if( ch != '_') {
        ICSDNameNew.push_back(ch);
      } else {
        ICSDNameNew.push_back('\\');
        ICSDNameNew.push_back('\\');
        ICSDNameNew.push_back(ch);
      }
    }
    return ICSDNameNew;
  }
} // namespace estructure

// ***************************************************************************
// estructure::CombineTDOSAndPDOS(const vector<vector<double> >& TDOS, const vector<vector<double> >& PDOS, vector<vector<double> >& vvDOS)
// ***************************************************************************
namespace estructure {
  void CombineTDOSAndTOTALPDOS(const vector<vector<double> >& TDOS, const vector<vector<double> >& TOTALPDOS, vector<vector<double> >& vvDOS) {
    //format of vvDOS, s, p, d , f, total
    //similar function POCC_COMBINE_TDOS_PDOS_ONEDOS

    string function_name = XPID + "estructure::CombineTDOSAndTOTALPDOS():";
    vvDOS.clear();
    int Ncolumns = TOTALPDOS.at(0).size();
    for (uint i=0; i<TOTALPDOS.size();i++) {
      vector<double> vtmp;
      for (int j=0; j<Ncolumns; j++) {
        vtmp.push_back(TOTALPDOS.at(i).at(j));
      }
      if((Ncolumns == 4) || (Ncolumns ==5)) vtmp.push_back(TDOS[i][1]);
      else if((Ncolumns == 7) || (Ncolumns ==9)) {
        vtmp.push_back(TDOS[i][1]);
        vtmp.push_back(TDOS[i][2]);
      }
      else {
        throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"Unexpected size of the TOTALPDOS. Please check.",_VALUE_RANGE_);
      }
      vvDOS.push_back(vtmp);
    }
  }
} // estructure

// ***************************************************************************
// estructure::GET_DOS_DATA(const string& str_dir, vector<vector<double> >& TDOS)
// ***************************************************************************
namespace estructure {
  double GET_PDOSDATA(const string& str_dir, vector<vector<vector<double> > >& PDOS) {
    string function_name = XPID + "estructure::GET_PDOSDATA():";
    double Efermi;
    vector<vector<double> > TDOS;
    vector<vector<double> > TOTALPDOS;
    //CO20180216 - this function needs PDOS
    if(!(estructure::GET_DOS_DATA(str_dir, Efermi, TDOS, TOTALPDOS, PDOS) && TOTALPDOS.size()>0)){
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"DOSCAR extraction failed, perhaps there is no PDOS",_INPUT_MISSING_);
    }
    return Efermi;
  }
}

// ***************************************************************************
// estructure::GET_TOTALPDOSDATA(const string& str_dir, vector<vector<double> >& TOTALPDOS, double& TOTALPDOSMAX)
// ***************************************************************************
namespace estructure {
  double GET_TOTALPDOSDATA(const string& str_dir, vector<vector<double> >& TOTALPDOS) {
    string function_name = XPID + "estructure::GET_TOTALPDOSDATA():";
    double  Efermi;
    vector<vector<double> > TDOS;
    vector<vector<vector<double> > > PDOS;
    //CO20180216 - this function needs PDOS
    if(!(estructure::GET_DOS_DATA(str_dir, Efermi, TDOS, TOTALPDOS, PDOS) && TOTALPDOS.size()>0)){
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"DOSCAR extraction failed, perhaps there is no PDOS",_INPUT_MISSING_);
    }
    return Efermi;
  }
}

// ***************************************************************************
// estructure::GET_DOS_DATA(const string& str_dir, vector<vector<double> >& TDOS)
// ***************************************************************************
namespace estructure {
  double GET_TDOSDATA(const string& str_dir, vector<vector<double> >& TDOS) {
    string function_name = XPID + "estructure::GET_TDOSDATA():";
    double Efermi;
    vector<vector<double> > TOTALPDOS;
    vector<vector<vector<double> > > PDOS;
    //CO20180216 - this function needs PDOS
    if(!(estructure::GET_DOS_DATA(str_dir, Efermi, TDOS, TOTALPDOS, PDOS) && TOTALPDOS.size()>0)){
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"DOSCAR extraction failed, perhaps there is no PDOS",_INPUT_MISSING_);
    }
    return Efermi;
  }
}

// ***************************************************************************
// estructure::GET_DOS_DATA(const string& str_dir, vector<vector<double> >& TDOS)
// ***************************************************************************
namespace estructure {
  double GET_PDOSDATA(stringstream& ss_dosfile, stringstream& ss_outfile, vector<vector<vector<double> > >& PDOS) {
    string function_name = XPID + "estructure::GET_PDOSDATA():";
    double Efermi;
    vector<vector<double> > TDOS;
    vector<vector<double> > TOTALPDOS;
    //CO20180216 - this function needs PDOS
    if(!(estructure::GET_DOS_DATA(ss_dosfile, ss_outfile, Efermi, TDOS, TOTALPDOS, PDOS) && TOTALPDOS.size()>0)){
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"DOSCAR extraction failed, perhaps there is no PDOS",_INPUT_MISSING_);
    }
    return Efermi;
  }
}

// ***************************************************************************
// estructure::GET_TOTALPDOSDATA(const string& str_dir, vector<vector<double> >& TOTALPDOS)
// ***************************************************************************
namespace estructure {
  double GET_TOTALPDOSDATA(stringstream& ss_dosfile, stringstream& ss_outfile, vector<vector<double> >& TOTALPDOS) {
    string function_name = XPID + "estructure::GET_TOTALPDOSDATA():";
    double Efermi;
    vector<vector<double> > TDOS;
    vector<vector<vector<double> > > PDOS;
    //CO20180216 - this function needs PDOS
    if(!(estructure::GET_DOS_DATA(ss_dosfile, ss_outfile, Efermi, TDOS, TOTALPDOS, PDOS) && TOTALPDOS.size()>0)){
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"DOSCAR extraction failed, perhaps there is no PDOS",_INPUT_MISSING_);
    }
    return Efermi;
  }
}

// ***************************************************************************
// estructure::GET_TDOSDATA(stringstream& ss_dosfile, stringstream& ss_outcarfile, vector<vector<double> >& TDOS, double& TDOSMAX)
// ***************************************************************************
namespace estructure {
  double GET_TDOSDATA(stringstream& ss_dosfile, stringstream& ss_outfile, vector<vector<double> >& TDOS) {
    string function_name = XPID + "estructure::GET_TDOSDATA():";
    double Efermi;
    vector<vector<double> > TOTALPDOS;
    vector<vector<vector<double> > > PDOS;
    //CO20180216 - this function needs PDOS
    if(!(estructure::GET_DOS_DATA(ss_dosfile, ss_outfile, Efermi, TDOS, TOTALPDOS, PDOS) && TOTALPDOS.size()>0)){
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"DOSCAR extraction failed, perhaps there is no PDOS",_INPUT_MISSING_);
    }
    return Efermi;
  }
}
// ***************************************************************************
// estructure::GET_DOS_DATA(string str_dir, vector<vector<double> >& TDOS)
// ***************************************************************************
namespace estructure {
  bool GET_DOS_DATA(const string& str_dir, double& Efermi, vector<vector<double> >& TDOS, vector<vector<double> >& TOTALPDOS, vector<vector<vector<double> > >& PDOS) {
    stringstream ss_dosfile, ss_outfile, ss_line;
    if(aflowlib::VaspFileExist(str_dir, "OUTCAR")) aflowlib::vaspfile2stringstream(str_dir, "OUTCAR", ss_outfile); //Not return even OUTCAR does not exist
    aflowlib::vaspfile2stringstream(str_dir, "DOSCAR", ss_dosfile); //return if DOSCAR does not exist
    return estructure::GET_DOS_DATA(ss_dosfile, ss_outfile, Efermi, TDOS, TOTALPDOS, PDOS);
  }
}

// ***************************************************************************
// estructure::GET_DOS_DATA(stringstream& ss_dosfile, stringstream& ss_outfile, double& Efermi, vector<vector<double> >& TDOS, vector<vector<double> >& TOTALPDOS)
// ***************************************************************************
namespace estructure {
  bool GET_DOS_DATA(stringstream& ss_dosfile, stringstream& ss_outfile, double& Efermi, vector<vector<double> >& TDOS, vector<vector<double> >& TOTALPDOS) {
    vector<vector<vector<double> > > PDOS;
    return estructure::GET_DOS_DATA(ss_dosfile, ss_outfile, Efermi, TDOS, TOTALPDOS, PDOS);
  }
}

// ***************************************************************************
// estructure::GET_DOS_DATA(string str_dir, vector<vector<double> >& TDOS)
// ***************************************************************************
namespace estructure {
  bool GET_DOS_DATA(stringstream& ss_dosfile, stringstream& ss_outfile, double& Efermi, vector<vector<double> >& TDOS, vector<vector<double> >& TOTALPDOS, vector<vector<vector<double> > >& PDOS) {
    string strtmp, line;
    stringstream ss_line;
    int DOSGRID, NIONS=0;
    bool isLSCOUPLING = false;
    double Emax=0.0, Emin=0.0;
    Efermi=0;
    //CO20180216 - reset EVERYTHING, so if we return false, there's no garbage inside
    for(uint i=0;i<TDOS.size();i++){TDOS[i].clear();} TDOS.clear();
    for(uint i=0;i<TOTALPDOS.size();i++){TOTALPDOS[i].clear();} TOTALPDOS.clear();
    for(uint i=0;i<PDOS.size();i++){for(uint j=0;j<PDOS[i].size();j++){PDOS[i][j].clear();} PDOS[i].clear();} PDOS.clear();

    // ***************************************************************************
    //READ OUTCAR, get the number of IONS, Fermi Level  
    string anchor_word_NIONS = "NIONS";
    string anchor_word_LSORBIT="LSORBIT =      T";
    while(getline(ss_outfile, line)) {
      if(line.find(anchor_word_NIONS) !=string::npos) {
        ss_line.clear(); ss_line.str(line);
        ss_line >> strtmp >> strtmp >> strtmp >> strtmp >> strtmp >> strtmp >> strtmp >> strtmp >> strtmp >> strtmp >> strtmp >> NIONS;
      }
      if(line.find(anchor_word_LSORBIT) !=string::npos) isLSCOUPLING = true;
    }

    // ***************************************************************************
    for (int i=0; i<5; i++) getline(ss_dosfile, strtmp); 
    ss_dosfile >> Emax >> Emin >> DOSGRID >> Efermi >> strtmp; getline(ss_dosfile, strtmp);

    int TotNoDOSCAR = aurostd::GetNLinesString(ss_dosfile);
    //int TotNoDOSCAR = CountofLinesinStringstream(ss_dosfile);
    //CO20180217 - I added the (-6) because header is 6 lines
    //usually, DOSGRID is 301, and TotNoDOSCAR is 307, so 307-6 == 301 ! conservation of lines
    //therefore TotNoDOSCAR-6 should never be less than DOSGRID, but at least equal
    if(TotNoDOSCAR-6 < DOSGRID) {cerr << "DOSCAR is cut-off, likely an IO problem" << endl; return false;} //"DOSCAR is not intergrated!" << endl; return false;  //CO20180216
    bool FLAG_PDOS = false;
    if(NIONS==0) NIONS = (int (TotNoDOSCAR-5)/(DOSGRID+1))-1; //if OUTCAR does not exist
    //CO20180217
    //DOSGRID 301, and TotNoDOSCAR is 301*2+6+1=609, the +1 is for the next DOSGRID line
    //because of +1 line, TotNoDOSCAR-6 must be greater, never equal
    if(TotNoDOSCAR-6 > 2*DOSGRID) FLAG_PDOS = true; //CO20180217

    //----------------------GETTING TDOS DATA-----------------------
    TDOS.resize(DOSGRID);
    getline(ss_dosfile, line);

    //Dealing with spin-polarized calculations
    if(aurostd::CountWordsinString(line)==5) {
      for (int i=0; i<DOSGRID; i++) {
        TDOS[i].resize(5);
      }
      ss_line.clear();
      ss_line.str(line);
      ss_line >> TDOS[0][0]; //Energy
      ss_line >> TDOS[0][1] >> TDOS[0][2]; TDOS[0][2] *= (-1); //Spin_up & Spin_dn
      ss_line >> TDOS[0][3] >> TDOS[0][4]; TDOS[0][4] *= (-1); //Sum_up & Sum_dn
      for (int j=1; j<DOSGRID; j++) {
        ss_dosfile >> TDOS[j][0]; //Energy
        ss_dosfile >> TDOS[j][1] >> TDOS[j][2];  TDOS[j][2] *= (-1); //Spin_up & Spin_dn
        ss_dosfile >> TDOS[j][3] >> TDOS[j][4];  TDOS[j][4] *= (-1); //Sum_up & Sum_dn
        getline(ss_dosfile, strtmp);
      }	
    }

    //Notes: TDOS[j][0] stores the Energy, TDOS[j][1] stores the spinup, TDOS[j][2] stores the spindown, TDOS[j][3] stores the integral of spinup ...

    //Dealing with non-spin-polarized calculations
    if(aurostd::CountWordsinString(line)==3) {
      for (int i=0; i<DOSGRID; i++) {
        TDOS[i].resize(3);
      }
      ss_line.clear();
      ss_line.str(line);
      ss_line >> TDOS[0][0]; //Energy
      ss_line >> TDOS[0][1]; //DOS
      ss_line >> TDOS[0][2]; //Sum
      for (int j=1; j<DOSGRID; j++) {
        ss_dosfile >> TDOS[j][0];
        ss_dosfile >> TDOS[j][1];
        ss_dosfile >> TDOS[j][2];
        getline(ss_dosfile, strtmp);
      }	
    }
    //-------------------------------------------------------------------------------------------------------------------------------------------------
    //Shifting the Energy to Fermi level
    for (int i=0; i< DOSGRID; i++) {
      TDOS[i][0]=TDOS[i][0]-Efermi;
    }

    //************************************************************************************************************************
    //Get PDOS
    //************************************************************************************************************************
    //----------------------GETTING PDOS DATA-------------------------
    //vector<vector<vector<double> > > PDOS(NIONS);
    //if(!FLAG_PDOS) { cerr << "Partial DOS has not been calculated yet or your DOSCAR file is damaged!" << endl; return false;} //CO20180216 //we may not have PDOS in static anymore, see AGL
    if(FLAG_PDOS) {
      PDOS.resize(NIONS);
      getline(ss_dosfile, line); //Negelecting the title line after the TDOS
      getline(ss_dosfile, line); //Read the 1st line of PDOS
      int Ncolumns;
      Ncolumns=aurostd::CountWordsinString(line);

      //--------------------s, p , d-----------------------
      if(Ncolumns==4) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(4);
        }
        //Storing the DOSDATA of the 1st atom	
        ss_line.clear();
        ss_line.str(line);
        //            ss_line >> PDOS[0][0][0] >> PDOS[0][0][1] >> PDOS[0][0][2] >> PDOS[0][0][3];
        ss_line >> PDOS[0][0][0]; //Energy
        ss_line >> PDOS[0][0][1]; //s
        ss_line >> PDOS[0][0][2]; //p
        ss_line >> PDOS[0][0][3]; //d
        for (int j=1; j<DOSGRID; j++) {
          //                ss_dosfile >> PDOS[0][j][0] >> PDOS[0][j][1] >> PDOS[0][j][2] >> PDOS[0][j][3];
          ss_dosfile >> PDOS[0][j][0];
          ss_dosfile >> PDOS[0][j][1];
          ss_dosfile >> PDOS[0][j][2];
          ss_dosfile >> PDOS[0][j][3];
          getline(ss_dosfile, strtmp);
        }

        //Storing the DOSDATA of the left atoms	
        for (int i=1; i<NIONS; i++) {
          getline(ss_dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            ss_dosfile >> PDOS[i][j][0];
            ss_dosfile >> PDOS[i][j][1];
            ss_dosfile >> PDOS[i][j][2];
            ss_dosfile >> PDOS[i][j][3];
            getline(ss_dosfile, strtmp);
          }
        }	
      }
      //--------------------s, p , d-----------------------

      //--------------------s, p , d, f-----------------------
      if(Ncolumns==5) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(5);
        }
        //Storing the DOSDATA of the 1st atom	
        ss_line.clear();
        ss_line.str(line);
        ss_line >> PDOS[0][0][0];
        ss_line >> PDOS[0][0][1];
        ss_line >> PDOS[0][0][2];
        ss_line >> PDOS[0][0][3];
        ss_line >> PDOS[0][0][4];
        for (int j=1; j<DOSGRID; j++) {
          ss_dosfile >> PDOS[0][j][0];
          ss_dosfile >> PDOS[0][j][1];
          ss_dosfile >> PDOS[0][j][2];
          ss_dosfile >> PDOS[0][j][3];
          ss_dosfile >> PDOS[0][j][4];
          getline(ss_dosfile, strtmp);
        }

        //Storing the DOSDATA of the left atoms	
        for (int i=1; i<NIONS; i++) {
          getline(ss_dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            ss_dosfile >> PDOS[i][j][0];
            ss_dosfile >> PDOS[i][j][1];
            ss_dosfile >> PDOS[i][j][2];
            ss_dosfile >> PDOS[i][j][3];
            ss_dosfile >> PDOS[i][j][4];
            getline(ss_dosfile, strtmp);
          }
        }	
      }
      //--------------------s, p , d, f-----------------------
      //--------------------s, p , d (spin-polarized)-----
      if(Ncolumns==7) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(7);
        }
        //Storing the DOSDATA of the 1st atom	
        ss_line.clear();
        ss_line.str(line);
        //            ss_line >> PDOS[0][0][0] >> PDOS[0][0][1] >> PDOS[0][0][2] >> PDOS[0][0][3] >> PDOS[0][0][4] >> PDOS[0][0][5] >> PDOS[0][0][6];
        ss_line >> PDOS[0][0][0];  //Energy
        ss_line >> PDOS[0][0][1] >> PDOS[0][0][2];  //s
        ss_line >> PDOS[0][0][3] >> PDOS[0][0][4]; //p
        ss_line >> PDOS[0][0][5] >> PDOS[0][0][6]; //d
        for (int j=1; j<DOSGRID; j++) {
          ss_dosfile >> PDOS[0][j][0];
          ss_dosfile >> PDOS[0][j][1] >> PDOS[0][j][2]; //s
          ss_dosfile >> PDOS[0][j][3] >> PDOS[0][j][4]; //p
          ss_dosfile >> PDOS[0][j][5] >> PDOS[0][j][6]; //d
          getline(ss_dosfile, strtmp);
        }
        //Storing the DOSDATA of the left atoms	
        for (int i=1; i<NIONS; i++) {
          getline(ss_dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            ss_dosfile >> PDOS[i][j][0];
            ss_dosfile >> PDOS[i][j][1] >> PDOS[i][j][2]; //s
            ss_dosfile >> PDOS[i][j][3] >> PDOS[i][j][4]; //p
            ss_dosfile >> PDOS[i][j][5] >> PDOS[i][j][6]; //d
            getline(ss_dosfile, strtmp);
          }
        }	
      }

      //--------------------s, p , d , f(spin-polarized)-----
      if(Ncolumns==9) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(9);
        }
        //Storing the DOSDATA of the 1st atom	
        ss_line.clear();
        ss_line.str(line);
        ss_line >> PDOS[0][0][0];
        ss_line >> PDOS[0][0][1] >> PDOS[0][0][2]; //s
        ss_line >> PDOS[0][0][3] >> PDOS[0][0][4]; //p
        ss_line >> PDOS[0][0][5] >> PDOS[0][0][6]; //d
        ss_line >> PDOS[0][0][7] >> PDOS[0][0][8]; //f
        for (int j=1; j<DOSGRID; j++) {
          ss_dosfile >> PDOS[0][j][0];
          ss_dosfile >> PDOS[0][j][1] >> PDOS[0][j][2];
          ss_dosfile >> PDOS[0][j][3] >> PDOS[0][j][4];
          ss_dosfile >> PDOS[0][j][5] >> PDOS[0][j][6];
          ss_dosfile >> PDOS[0][j][7] >> PDOS[0][j][8];
          getline(ss_dosfile, strtmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(ss_dosfile, line);
          //cout << line << "hi" << endl;
          for (int j=0; j<DOSGRID; j++) {
            ss_dosfile >> PDOS[i][j][0];
            ss_dosfile >> PDOS[i][j][1] >> PDOS[i][j][2];
            ss_dosfile >> PDOS[i][j][3] >> PDOS[i][j][4];
            ss_dosfile >> PDOS[i][j][5] >> PDOS[i][j][6];
            ss_dosfile >>PDOS[i][j][7] >> PDOS[i][j][8];
            getline(ss_dosfile, strtmp);
          }
        }	
      }
      //--------------------s, p , d (spin-polarized)-----

      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2 (non-spin-polarized)-----
      if(Ncolumns==10) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(10);
        }
        //Storing the DOSDATA of the 1st atom	
        ss_line.clear();
        ss_line.str(line);
        ss_line >> PDOS[0][0][0]; //Energy
        ss_line >> PDOS[0][0][1]; //s
        ss_line >> PDOS[0][0][2] >> PDOS[0][0][3] >> PDOS[0][0][4]; //py, pz, px
        ss_line >> PDOS[0][0][5] >> PDOS[0][0][6] >> PDOS[0][0][7] >> PDOS[0][0][8] >> PDOS[0][0][9]; //dxy, dyz, dz2, dxz, dx2-y2
        for (int j=1; j<DOSGRID; j++) {
          ss_dosfile >> PDOS[0][j][0];
          ss_dosfile >> PDOS[0][j][1];
          ss_dosfile >> PDOS[0][j][2] >> PDOS[0][j][3] >> PDOS[0][j][4];
          ss_dosfile >> PDOS[0][j][5] >> PDOS[0][j][6] >> PDOS[0][0][7] >> PDOS[0][0][8] >> PDOS[0][0][9];
          getline(ss_dosfile, strtmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(ss_dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            ss_dosfile >> PDOS[i][j][0];
            ss_dosfile >> PDOS[i][j][1];
            ss_dosfile >> PDOS[i][j][2] >> PDOS[i][j][3] >> PDOS[i][j][4];
            ss_dosfile >> PDOS[i][j][5] >> PDOS[i][j][6] >> PDOS[i][j][7] >> PDOS[i][j][8] >> PDOS[i][j][9];
            getline(ss_dosfile, strtmp);
          }
        }	
      }
      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2 (non-spin-polarized)-----

      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... (LS COUPLINT)------------
      if(Ncolumns==13) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(13);
        }
        //Storing the DOSDATA of the 1st atom	
        ss_line.clear();
        ss_line.str(line);
        ss_line >> PDOS[0][0][0]; //Energy
        ss_line >> PDOS[0][0][1] >> PDOS[0][0][2] >> PDOS[0][0][3] >> PDOS[0][0][4]; //stotal, sx, sy, sz
        ss_line >> PDOS[0][0][5] >> PDOS[0][0][6] >> PDOS[0][0][7] >> PDOS[0][0][8]; //ptotal, px, py, pz
        ss_line >> PDOS[0][0][9] >> PDOS[0][0][10] >> PDOS[0][0][11] >> PDOS[0][0][12]; //dtotal, dx, dy, dz
        for (int j=1; j<DOSGRID; j++) {
          ss_dosfile >> PDOS[0][j][0];
          ss_dosfile >> PDOS[0][j][1] >> PDOS[0][j][2] >> PDOS[0][j][3] >> PDOS[0][j][4];
          ss_dosfile >> PDOS[0][j][5] >> PDOS[0][j][6] >> PDOS[0][j][7] >> PDOS[0][j][8];
          ss_dosfile >> PDOS[0][j][9] >> PDOS[0][j][10] >> PDOS[0][j][11] >> PDOS[0][j][12];
          getline(ss_dosfile, strtmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(ss_dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            ss_dosfile >> PDOS[i][j][0]; //Energy
            ss_dosfile >> PDOS[i][j][1] >> PDOS[i][j][2] >> PDOS[i][j][3] >> PDOS[i][j][4];
            ss_dosfile >> PDOS[i][j][5] >> PDOS[i][j][6] >> PDOS[i][j][7] >> PDOS[i][j][8];
            ss_dosfile >> PDOS[i][j][9] >> PDOS[i][j][10] >> PDOS[i][j][11] >> PDOS[i][j][12];
            getline(ss_dosfile, strtmp);
          }
        }	
      }
      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... (LS COUPLINT)------------

      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... ftotal, fx, fy, fz (LS COUPLINT)------------
      if(Ncolumns==17) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(17);
        }
        //Storing the DOSDATA of the 1st atom	
        ss_line.clear();
        ss_line.str(line);
        ss_line >> PDOS[0][0][0]; //Energy
        ss_line >> PDOS[0][0][1] >> PDOS[0][0][2] >> PDOS[0][0][3] >> PDOS[0][0][4]; //s
        ss_line >> PDOS[0][0][5] >> PDOS[0][0][6] >> PDOS[0][0][7] >> PDOS[0][0][8]; //p
        ss_line >> PDOS[0][0][9] >> PDOS[0][0][10] >> PDOS[0][0][11] >> PDOS[0][0][12]; //d
        ss_line >> PDOS[0][0][13] >> PDOS[0][0][14] >> PDOS[0][0][15] >> PDOS[0][0][16]; //f
        for (int j=1; j<DOSGRID; j++) {
          ss_dosfile >> PDOS[0][j][0];
          ss_dosfile >> PDOS[0][j][1] >> PDOS[0][j][2] >> PDOS[0][j][3] >> PDOS[0][j][4];
          ss_dosfile >> PDOS[0][j][5] >> PDOS[0][j][6] >> PDOS[0][j][7] >> PDOS[0][j][8];
          ss_dosfile >> PDOS[0][j][9] >> PDOS[0][j][10] >> PDOS[0][j][11] >> PDOS[0][j][12];
          ss_dosfile >> PDOS[0][j][13] >> PDOS[0][j][14] >>PDOS[0][j][15] >> PDOS[0][j][16];
          getline(ss_dosfile, strtmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(ss_dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            ss_dosfile >> PDOS[i][j][0];
            ss_dosfile >> PDOS[i][j][1] >> PDOS[i][j][2] >> PDOS[i][j][3] >> PDOS[i][j][4];
            ss_dosfile >> PDOS[i][j][5] >> PDOS[i][j][6] >> PDOS[i][j][7] >> PDOS[i][j][8];
            ss_dosfile >> PDOS[i][j][9] >> PDOS[i][j][10] >> PDOS[i][j][11] >> PDOS[i][j][12];
            ss_dosfile >> PDOS[i][j][13] >> PDOS[i][j][14] >> PDOS[i][j][15] >> PDOS[i][j][16];
            getline(ss_dosfile, strtmp);
          }
        }	
      }
      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... ftotal, fx, fy, fz (LS COUPLINT)------------

      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn (spin-polarized)-----
      if(Ncolumns==19) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(19);
        }
        //Storing the DOSDATA of the 1st atom	
        //
        //KY UNFISNISHED
        ss_line.clear();
        ss_line.str(line);
        ss_line >> PDOS[0][0][0]; //Energy
        ss_line >> PDOS[0][0][1] >> PDOS[0][0][2]; //s_up & s_dn
        ss_line >> PDOS[0][0][3] >> PDOS[0][0][4]; //py_up & py_dn
        ss_line >> PDOS[0][0][5] >> PDOS[0][0][6]; //pz_up & pz_dn
        ss_line >> PDOS[0][0][7] >> PDOS[0][0][8]; //px_up & px_dn
        ss_line >> PDOS[0][0][9] >> PDOS[0][0][10]; //dxy_up & dxy_dn
        ss_line >> PDOS[0][0][11] >> PDOS[0][0][12]; //dyz_up & dyz_dn
        ss_line >> PDOS[0][0][13] >> PDOS[0][0][14]; //dz2_up & dz2_dn
        ss_line >> PDOS[0][0][15] >> PDOS[0][0][16]; //dxz_up & dxz_dn
        ss_line >> PDOS[0][0][17] >> PDOS[0][0][18]; //dx2-y2_up & dx2-y2_dn
        for (int j=1; j<DOSGRID; j++) {
          ss_dosfile >> PDOS[0][j][0];
          ss_dosfile >> PDOS[0][j][1] >> PDOS[0][j][2];
          ss_dosfile >> PDOS[0][j][3] >> PDOS[0][j][4];
          ss_dosfile >> PDOS[0][j][5] >> PDOS[0][j][6];
          ss_dosfile >> PDOS[0][0][7] >> PDOS[0][0][8];
          ss_dosfile >> PDOS[0][0][9] >> PDOS[0][0][10];
          ss_dosfile >> PDOS[0][0][11] >> PDOS[0][0][12];
          ss_dosfile >> PDOS[0][0][13] >> PDOS[0][0][14];
          ss_dosfile >> PDOS[0][0][15] >> PDOS[0][0][16];
          ss_dosfile >> PDOS[0][0][17] >> PDOS[0][0][18];
          getline(ss_dosfile, strtmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(ss_dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            ss_dosfile >> PDOS[i][j][0];
            ss_dosfile >> PDOS[i][j][1] >> PDOS[i][j][2];
            ss_dosfile >> PDOS[i][j][3] >> PDOS[i][j][4];
            ss_dosfile >> PDOS[i][j][5] >> PDOS[i][j][6];
            ss_dosfile >> PDOS[i][j][7] >> PDOS[i][j][8];
            ss_dosfile >> PDOS[i][j][9] >> PDOS[i][j][10];
            ss_dosfile >> PDOS[i][j][11] >> PDOS[i][j][12];
            ss_dosfile >> PDOS[i][j][13] >> PDOS[i][j][14];
            ss_dosfile >> PDOS[i][j][15] >> PDOS[i][j][16];
            ss_dosfile >> PDOS[i][j][17] >> PDOS[i][j][18];
            getline(ss_dosfile, strtmp);
          }
        }	
      }
      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn, f1, f2, f3, f4, f5, f6, f7 (spin-polarized)-----
      if(Ncolumns==33) {
        for (int i=0; i<NIONS; i++) {
          PDOS[i].resize(DOSGRID);
          for (int j=0; j<DOSGRID; j++)
            PDOS[i][j].resize(33);
        }
        //Storing the DOSDATA of the 1st atom	
        //
        //KY UNFISNISHED
        ss_line.clear();
        ss_line.str(line);
        ss_line >> PDOS[0][0][0]; //Energy
        ss_line >> PDOS[0][0][1] >> PDOS[0][0][2]; //s_up & s_dn
        ss_line >> PDOS[0][0][3] >> PDOS[0][0][4]; //py_up & py_dn
        ss_line >> PDOS[0][0][5] >> PDOS[0][0][6]; //pz_up & pz_dn
        ss_line >> PDOS[0][0][7] >> PDOS[0][0][8]; //px_up & px_dn
        ss_line >> PDOS[0][0][9] >> PDOS[0][0][10]; //dxy_up & dxy_dn
        ss_line >> PDOS[0][0][11] >> PDOS[0][0][12]; //dyz_up & dyz_dn
        ss_line >> PDOS[0][0][13] >> PDOS[0][0][14]; //dz2_up & dz2_dn
        ss_line >> PDOS[0][0][15] >> PDOS[0][0][16]; //dxz_up & dxz_dn
        ss_line >> PDOS[0][0][17] >> PDOS[0][0][18]; //dx2-y2_up & dx2-y2_dn
        ss_line >> PDOS[0][0][19] >> PDOS[0][0][20]; //f1_up & f1_dn
        ss_line >> PDOS[0][0][21] >> PDOS[0][0][22]; //f2_up & f2_dn
        ss_line >> PDOS[0][0][23] >> PDOS[0][0][24]; //f3_up & f3_dn
        ss_line >> PDOS[0][0][25] >> PDOS[0][0][26]; //f4_up & f4_dn
        ss_line >> PDOS[0][0][27] >> PDOS[0][0][28]; //f5_up & f5_dn
        ss_line >> PDOS[0][0][29] >> PDOS[0][0][30]; //f6_up & f6_dn
        ss_line >> PDOS[0][0][31] >> PDOS[0][0][32]; //f7_up & f7_dn
        for (int j=1; j<DOSGRID; j++) {
          ss_dosfile >> PDOS[0][j][0];
          ss_dosfile >> PDOS[0][j][1] >> PDOS[0][j][2];
          ss_dosfile >> PDOS[0][j][3] >> PDOS[0][j][4];
          ss_dosfile >> PDOS[0][j][5] >> PDOS[0][j][6];
          ss_dosfile >> PDOS[0][j][7] >> PDOS[0][j][8];
          ss_dosfile >> PDOS[0][j][9] >> PDOS[0][j][10];
          ss_dosfile >> PDOS[0][j][11] >> PDOS[0][j][12];
          ss_dosfile >> PDOS[0][j][13] >> PDOS[0][j][14];
          ss_dosfile >> PDOS[0][j][15] >> PDOS[0][j][16];
          ss_dosfile >> PDOS[0][j][17] >> PDOS[0][j][18];
          ss_dosfile >> PDOS[0][j][19] >> PDOS[0][j][20]; //f1_up & f1_dn
          ss_dosfile >> PDOS[0][j][21] >> PDOS[0][j][22]; //f2_up & f2_dn
          ss_dosfile >> PDOS[0][j][23] >> PDOS[0][j][24]; //f3_up & f3_dn
          ss_dosfile >> PDOS[0][j][25] >> PDOS[0][j][26]; //f4_up & f4_dn
          ss_dosfile >> PDOS[0][j][27] >> PDOS[0][j][28]; //f5_up & f5_dn
          ss_dosfile >> PDOS[0][j][29] >> PDOS[0][j][30]; //f6_up & f6_dn
          ss_dosfile >> PDOS[0][j][31] >> PDOS[0][j][32]; //f7_up & f7_dn
          getline(ss_dosfile, strtmp);
        }

        for (int i=1; i<NIONS; i++) {
          getline(ss_dosfile, line);
          for (int j=0; j<DOSGRID; j++) {
            ss_dosfile >> PDOS[i][j][0];
            ss_dosfile >> PDOS[i][j][1] >> PDOS[i][j][2];
            ss_dosfile >> PDOS[i][j][3] >> PDOS[i][j][4];
            ss_dosfile >> PDOS[i][j][5] >> PDOS[i][j][6];
            ss_dosfile >> PDOS[i][j][7] >> PDOS[i][j][8];
            ss_dosfile >> PDOS[i][j][9] >> PDOS[i][j][10];
            ss_dosfile >> PDOS[i][j][11] >> PDOS[i][j][12];
            ss_dosfile >> PDOS[i][j][13] >> PDOS[i][j][14];
            ss_dosfile >> PDOS[i][j][15] >> PDOS[i][j][16];
            ss_dosfile >> PDOS[i][j][17] >> PDOS[i][j][18];
            ss_dosfile >> PDOS[i][j][19] >> PDOS[i][j][20]; //f1_up & f1_dn
            ss_dosfile >> PDOS[i][j][21] >> PDOS[i][j][22]; //f2_up & f2_dn
            ss_dosfile >> PDOS[i][j][23] >> PDOS[i][j][24]; //f3_up & f3_dn
            ss_dosfile >> PDOS[i][j][25] >> PDOS[i][j][26]; //f4_up & f4_dn
            ss_dosfile >> PDOS[i][j][27] >> PDOS[i][j][28]; //f5_up & f5_dn
            ss_dosfile >> PDOS[i][j][29] >> PDOS[i][j][30]; //f6_up & f6_dn
            ss_dosfile >> PDOS[i][j][31] >> PDOS[i][j][32]; //f7_up & f7_dn
            getline(ss_dosfile, strtmp);
          }
        }
      }
      //************************************************************************************************************************

      //Calculating total PDOS of s orbital
      //vector<vector<double> > TOTALPDOS(DOSGRID);
      TOTALPDOS.resize(DOSGRID);
      //--------------------s, p , d-----------------------
      if(Ncolumns==4) {
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(4);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s orbitals
            TOTALPDOS[i][2]+=PDOS[j][i][2]; //sum of p orbitals
            TOTALPDOS[i][3]+=PDOS[j][i][3]; //sum of d orbitals
          }
        }
      }
      //--------------------s, p , d-----------------------

      //--------------------s, p , d, f-----------------------
      if(Ncolumns==5) {
        //Storing the DOSDATA of the s , p, d
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(5);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s orbitals
            TOTALPDOS[i][2]+=PDOS[j][i][2]; //sum of p orbitals
            TOTALPDOS[i][3]+=PDOS[j][i][3]; //sum of d orbitals
            TOTALPDOS[i][4]+=PDOS[j][i][4]; //sum of f orbitals
          }
        }
      }
      //--------------------s, p , d, f-----------------------

      //--------------------s, p , d (spin-polarized)-----
      if(Ncolumns==7) {
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(7);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;
          TOTALPDOS[i][2]=0.0;
          TOTALPDOS[i][3]=0.0;
          TOTALPDOS[i][4]=0.0;
          TOTALPDOS[i][5]=0.0;
          TOTALPDOS[i][6]=0.0;
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=PDOS[j][i][2]*(-1); //sum of s_dn
            TOTALPDOS[i][3]+=PDOS[j][i][3]; //sum of p_up
            TOTALPDOS[i][4]+=PDOS[j][i][4]*(-1); //sum of p_dn
            TOTALPDOS[i][5]+=PDOS[j][i][5]; //sum of d_up
            TOTALPDOS[i][6]+=PDOS[j][i][6]*(-1); //sum of d_dn
          }    
        }    
      }

      //--------------------s, p , d (spin-polarized)-----

      //--------------------s, p , d, f(spin-polarized)-----
      if(Ncolumns==9) {
        //Storing the DOSDATA of the s , p, d
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(9);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;
          TOTALPDOS[i][2]=0.0;
          TOTALPDOS[i][3]=0.0;
          TOTALPDOS[i][4]=0.0;
          TOTALPDOS[i][5]=0.0;
          TOTALPDOS[i][6]=0.0;
          TOTALPDOS[i][7]=0.0;
          TOTALPDOS[i][8]=0.0;
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=PDOS[j][i][2]*(-1); //sum of s_dn
            TOTALPDOS[i][3]+=PDOS[j][i][3]; //sum of p_up
            TOTALPDOS[i][4]+=PDOS[j][i][4]*(-1); //sum of p_dn
            TOTALPDOS[i][5]+=PDOS[j][i][5]; //sum of d_up
            TOTALPDOS[i][6]+=PDOS[j][i][6]*(-1); //sum of d_dn
            TOTALPDOS[i][7]+=PDOS[j][i][7]; //sum of f_up
            TOTALPDOS[i][8]+=PDOS[j][i][8]*(-1); //sum of f_dn
          }
        }
      }

      //--------------------s, p , d, f(spin-polarized)-----

      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2 (non-spin-polarized)-----
      if(Ncolumns==10) {
        //Storing the DOSDATA of the s , p, d
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(4);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;  //s
          TOTALPDOS[i][2]=0.0;  //p
          TOTALPDOS[i][3]=0.0;  //d
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=(PDOS[j][i][2]+PDOS[j][i][3]+PDOS[j][i][4]); //sum of py, pz, and px
            TOTALPDOS[i][3]+=(PDOS[j][i][5]+PDOS[j][i][6]+PDOS[j][i][7]+PDOS[j][i][8]+PDOS[j][i][9]); //sum of dxy, dyz, dz2, dxz, dx2-y2
          }
        }
      }
      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2 (non-spin-polarized)-----

      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2, f1, f2, f3, f4, f5, f6, f7 (non-spin-polarized)-----
      if(Ncolumns==17 && (!isLSCOUPLING)) {
        //Storing the DOSDATA of the s , p, d , f
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(5);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;  //s
          TOTALPDOS[i][2]=0.0;  //p
          TOTALPDOS[i][3]=0.0;  //d
          TOTALPDOS[i][4]=0.0;  //f
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=(PDOS[j][i][2]+PDOS[j][i][3]+PDOS[j][i][4]); //sum of py, pz, and px
            TOTALPDOS[i][3]+=(PDOS[j][i][5]+PDOS[j][i][6]+PDOS[j][i][7]+PDOS[j][i][8]+PDOS[j][i][9]); //sum of dxy, dyz, dz2, dxz, dx2-y2
            TOTALPDOS[i][4]+=(PDOS[j][i][10]+PDOS[j][i][11]+PDOS[j][i][12]+PDOS[j][i][13]+PDOS[j][i][14]+PDOS[j][i][15]+PDOS[j][i][16]); //sum of f orbital
          }
        }
      }
      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2, f1, f2, f3, f4, f5, f6, f7 (non-spin-polarized)-----

      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn (spin-polarized)-----
      if(Ncolumns==19) {
        //Storing the DOSDATA of the s , p, d
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(7);
          TOTALPDOS[i][0]=PDOS[0][i][0]; //Energy
          TOTALPDOS[i][1]=0.0;  //s_up
          TOTALPDOS[i][2]=0.0;  //s_dn
          TOTALPDOS[i][3]=0.0;  //p_up
          TOTALPDOS[i][4]=0.0;  //p_dn
          TOTALPDOS[i][5]=0.0;  //d_up
          TOTALPDOS[i][6]=0.0;  //d_dn
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=PDOS[j][i][2]*(-1); //sum of s_dn
            TOTALPDOS[i][3]+=(PDOS[j][i][3]+PDOS[j][i][5]+PDOS[j][i][7]); //sum of p_up // py, pz, and px
            TOTALPDOS[i][4]+=(PDOS[j][i][4]+PDOS[j][i][6]+PDOS[j][i][8])*(-1); //sum of p_dn // py, pz, and px
            TOTALPDOS[i][5]+=(PDOS[j][i][9]+PDOS[j][i][11]+PDOS[j][i][13]+PDOS[j][i][15]+PDOS[j][i][17]); //sum of d_up //dxy, dyz, dz2, dxz, dx2-y2
            TOTALPDOS[i][6]+=(PDOS[j][i][10]+PDOS[j][i][12]+PDOS[j][i][14]+PDOS[j][i][16]+PDOS[j][i][18])*(-1); //sum of d_up //dxy, dyz, dz2, dxz, dx2-y2
          }
        }
      }
      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn (spin-polarized)-----

      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn, (f1, f2, f3...) (spin-polarized)-----
      if(Ncolumns==33) {
        //Storing the DOSDATA of the s , p, d, f
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(9);
          TOTALPDOS[i][0]=PDOS[0][i][0]; //Energy
          TOTALPDOS[i][1]=0.0;  //s_up
          TOTALPDOS[i][2]=0.0;  //s_dn
          TOTALPDOS[i][3]=0.0;  //p_up
          TOTALPDOS[i][4]=0.0;  //p_dn
          TOTALPDOS[i][5]=0.0;  //d_up
          TOTALPDOS[i][6]=0.0;  //d_dn
          TOTALPDOS[i][7]=0.0;  //f_dn
          TOTALPDOS[i][8]=0.0;  //f_dn
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up
            TOTALPDOS[i][2]+=PDOS[j][i][2]*(-1); //sum of s_dn
            TOTALPDOS[i][3]+=(PDOS[j][i][3]+PDOS[j][i][5]+PDOS[j][i][7]); //sum of p_up // py, pz, and px
            TOTALPDOS[i][4]+=(PDOS[j][i][4]+PDOS[j][i][6]+PDOS[j][i][8])*(-1); //sum of p_dn // py, pz, and px
            TOTALPDOS[i][5]+=(PDOS[j][i][9]+PDOS[j][i][11]+PDOS[j][i][13]+PDOS[j][i][15]+PDOS[j][i][17]); //sum of d_up //dxy, dyz, dz2, dxz, dx2-y2
            TOTALPDOS[i][6]+=(PDOS[j][i][10]+PDOS[j][i][12]+PDOS[j][i][14]+PDOS[j][i][16]+PDOS[j][i][18])*(-1); //sum of d_up //dxy, dyz, dz2, dxz, dx2-y2
            TOTALPDOS[i][7]+=(PDOS[j][i][19]+PDOS[j][i][21]+PDOS[j][i][23]+PDOS[j][i][25]+PDOS[j][i][27]+PDOS[j][i][29]+PDOS[j][i][31]); //sum of f_up
            TOTALPDOS[i][8]+=(PDOS[j][i][20]+PDOS[j][i][22]+PDOS[j][i][24]+PDOS[j][i][26]+PDOS[j][i][28]+PDOS[j][i][30]+PDOS[j][i][32])*(-1); //sum of f_dn
          }
        }
      }
      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn (spin-polarized)-----

      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... (LS COUPLINT)------------
      if(Ncolumns==13 && isLSCOUPLING) {
        //Storing the DOSDATA of the s , p, d
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(4);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;
          TOTALPDOS[i][2]=0.0;
          TOTALPDOS[i][3]=0.0;
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s_up & s_dn orbitals
            TOTALPDOS[i][2]+=PDOS[j][i][5]; //sum of p_up & p_dn orbitals
            TOTALPDOS[i][3]+=PDOS[j][i][9]; //sum of d_up & d_dn orbitals
          }
        }	
      }
      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... (LS COUPLINT)------------

      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... ftotal ...(LS COUPLINT)------------
      if(Ncolumns==17 && isLSCOUPLING) {
        //Storing the DOSDATA of the s , p, d, f
        for (int i=0; i< DOSGRID; i++) {
          TOTALPDOS[i].resize(5);
          TOTALPDOS[i][0]=PDOS[0][i][0];
          TOTALPDOS[i][1]=0.0;
          TOTALPDOS[i][2]=0.0;
          TOTALPDOS[i][3]=0.0;
          TOTALPDOS[i][4]=0.0;
          for (int j=0; j< NIONS; j++) {
            TOTALPDOS[i][1]+=PDOS[j][i][1]; //sum of s orbitals
            TOTALPDOS[i][2]+=PDOS[j][i][5]; //sum of p orbitals
            TOTALPDOS[i][3]+=PDOS[j][i][9]; //sum of d orbitals
            TOTALPDOS[i][4]+=PDOS[j][i][13]; //sum of f orbitals
          }
        }	
      }
      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... ftotal ...(LS COUPLINT)------------
      //-------------------------------------------------------------------------------------------------------------------------------------------------
      //-------------------------------------------------------------------------------------------------------------------------------------------------
      //Shifting the Energy to Fermi level
      for (int i=0; i< DOSGRID; i++) {
        TOTALPDOS[i][0]=TOTALPDOS[i][0]-Efermi;
      }
      for (int i=0; i<NIONS;i++) {
        for (int j=0; j< DOSGRID; j++) {
          PDOS[i][j][0]=PDOS[i][j][0]-Efermi;
        }
      }
      estructure::FormatSpinofPDOS(PDOS);
    }
    return true;
  }
} // namespace estructure

//************************************************************************************************************************
// estructure::FormatSpinofPDOS(vector<vector<vector<double> > >& vvva)
//************************************************************************************************************************
namespace estructure {
  void FormatSpinofPDOS(vector<vector<vector<double> > >& vvva) {
    vector<vector<double> > vvtmp;
    int DOSGRID = vvva.at(0).size();
    for (uint i=0; i<vvva.size();i++) {
      for (int j=0; j<DOSGRID; j++) {
        if(vvva[i].at(0).size()==7) {
          vvva[i][j][2] *=(-1);
          vvva[i][j][4] *=(-1);
          vvva[i][j][6] *=(-1);
        }
        if(vvva[i].at(0).size()==9) {
          vvva[i][j][2] *=(-1);
          vvva[i][j][4] *=(-1);
          vvva[i][j][6] *=(-1);
          vvva[i][j][8] *=(-1);
        }
        if(vvva[i].at(0).size()==19) {
          vvva[i][j][2] *=(-1);
          vvva[i][j][4] *=(-1);
          vvva[i][j][6] *=(-1);
          vvva[i][j][8] *=(-1);
          vvva[i][j][10]*=(-1);
          vvva[i][j][12]*=(-1);
          vvva[i][j][14]*=(-1);
          vvva[i][j][16]*=(-1);
          vvva[i][j][18]*=(-1);
        }
        if(vvva[i].at(0).size()==33) {
          vvva[i][j][2]*=(-1);
          vvva[i][j][4]*=(-1);
          vvva[i][j][6]*=(-1);
          vvva[i][j][8]*=(-1);
          vvva[i][j][10]*=(-1);
          vvva[i][j][12]*=(-1);
          vvva[i][j][14]*=(-1);
          vvva[i][j][16]*=(-1);
          vvva[i][j][18]*=(-1);
          vvva[i][j][20]*=(-1);
          vvva[i][j][22]*=(-1);
          vvva[i][j][24]*=(-1);
          vvva[i][j][26]*=(-1);
          vvva[i][j][28]*=(-1);
          vvva[i][j][30]*=(-1);
          vvva[i][j][32]*=(-1);
        }

      }
    }
  }
} // namespace estructure


/***************************************************************
 *   DOSDATA_JSON
 *
 *   ERIC G
 *
 *   Reads the DOSCAR.static file and then
 *   writes its contents to a JSON file. One 
 *   verison defaults to a ofstream while the 
 *   overloaded version takes any ostream.
 *
 *
 ****************************************************************/
namespace estructure{
  // Added by EG 
  // Converts a DOSCAR.static file into json format.
  bool DOSDATA_JSON(aurostd::xoption& vpflow,ostream& oss){
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::DOSDATA_JSON():";
    vector<string> tokens;
    aurostd::string2tokens(vpflow.getattachedscheme("DOSDATA2JSON"),tokens,",");
    bool SUCCESS=TRUE;
    string directory;
    vector<string> directories;
    for(uint i=0;i<tokens.size();i++){
      directory = aurostd::CleanFileName(tokens[i]);
      if(!aurostd::IsDirectory(directory)){
        cerr << function_name << " directory does not exist = " << directory << endl;
        continue;
      }
      directories.push_back(directory);
    }
    stringstream json; json.str("");
    json.precision(6);
    if(directories.size()>1){oss << "[" << std::endl;}
    for(uint i=0;i<directories.size();i++){
      directory=directories[i];
      if(LDEBUG) cerr << function_name << " working in directory=" << directory << endl;
      //oss << "{" << std::endl;  //CO20171025
      SUCCESS = SUCCESS && DOSDATA_JSON(vpflow,directory,json,true); //CO20171025
      oss << json.str(); json.str("");
      //oss <<std::endl  << "}"; //CO20171025
      if(i!=directories.size()-1){oss<<",";}
      oss << std::endl;
    }
    if(directories.size()>1){oss << "]" << std::endl;}
    return SUCCESS;
  }

  //Takes in a ofstream and spits out the revelevent JSON about the DOS. 
  bool DOSDATA_JSON(aurostd::xoption& vpflow, string directory, stringstream& json,bool wrapping_brackets){ //CO20171025
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::DOSDATA_JSON():";
    //bool isLSCOUPLING=FALSE;
    int DOSGRID; //, NIONS;
    double Efermi, Emax, Emin;
    //double DOSMAX=0.0;
    //string directory="./";
    string ICSDName=KBIN::ExtractSystemName(directory); //Get SystemName
    string stmp;//, line;

    //stringstream straus, strline, dosfile; //, stringstreamtmp, strline; 
    stringstream dosfile;//,iatomsfile;

    if(LDEBUG) cerr << function_name << " BEGIN" << endl;

    vector<string> tokens;
    aurostd::string2tokens(vpflow.getattachedscheme("DOSDATA2JSON::PARAMS"),tokens,",");
    double DOS_Emin=DEFAULT_DOS_EMIN,DOS_Emax=DEFAULT_DOS_EMAX,DOSSCALE=DEFAULT_DOS_SCALE;  // some defaults

    if(LDEBUG) cerr << function_name << " options=[" << vpflow.getattachedscheme("DOSDATA2JSON::PARAMS") << "]" << endl;
    if(LDEBUG) cerr << function_name << " tokens.size()=" << tokens.size() << endl;
    if(LDEBUG) for(uint i=0;i<tokens.size();i++) cerr << function_name << " tokens.at(i)=" << tokens.at(i) << endl;

    //if(tokens.size()>0) {
    //  init::ErrorOption(options,"estructure::DOSDATA_JSON","aflow --plotdosweb[=directory[,DOS_Emin[,DOS_Emax[,DOSSCALE]]]]]");
    //}
    //if(tokens.size()>=1) directory = tokens.at(0);
    if(tokens.size()>=1) DOS_Emin = aurostd::string2utype<double>(tokens.at(0)); 
    if(tokens.size()>=2) DOS_Emax = aurostd::string2utype<double>(tokens.at(1));
    if(tokens.size()>=3) DOSSCALE = aurostd::string2utype<double>(tokens.at(2));

    if(LDEBUG) cerr << function_name << " directory=[" << directory << "]" << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emin=" << DOS_Emin << endl;
    if(LDEBUG) cerr << function_name << " DOS_Emax=" << DOS_Emax << endl;
    if(LDEBUG) cerr << function_name << " DOSSCALE=" << DOSSCALE << endl;

    //READ DOSCAR.static
    bool found=FALSE;

    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(!found&&aurostd::FileExist(directory+"/DOSCAR.static"+XHOST.vext.at(iext)))
        found=aurostd::efile2stringstream(directory+"/DOSCAR.static"+XHOST.vext.at(iext),dosfile);
    }
    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(!found&&aurostd::FileExist(directory+"/DOSCAR"+XHOST.vext.at(iext)))
        found=aurostd::efile2stringstream(directory+"/DOSCAR"+XHOST.vext.at(iext),dosfile);
    }

    if(!found) {
      cerr << function_name << " ERROR: DOSCAR[.static][.EXT] not found in the directory, aborting."<< endl;
      return FALSE;
    }

    //CO20171025 START
    //READ POSCAR.static
    string POSCAR_file="";

    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(POSCAR_file.empty()&&aurostd::FileExist(directory+"/POSCAR.static"+XHOST.vext.at(iext)))
        POSCAR_file=directory+"/POSCAR.static"+XHOST.vext.at(iext);
    }
    for(uint iext=0;iext<XHOST.vext.size();iext++) { 
      if(POSCAR_file.empty()&&aurostd::FileExist(directory+"/POSCAR"+XHOST.vext.at(iext)))
        POSCAR_file=directory+"/POSCAR"+XHOST.vext.at(iext);
    }

    if(POSCAR_file.empty()) {
      cerr << function_name << " ERROR: POSCAR[.static][.EXT] not found in the directory, aborting."<< endl;
      return FALSE;
    }

    xstructure xstr(POSCAR_file,IOVASP_POSCAR);
    if(!xstr.CalculateSymmetry()){
      cerr << function_name << " ERROR: Unable to calculate symmetry of structure found in POSCAR, aborting." << endl;
      return FALSE;
    }

    vector<int> iatoms;
    for(uint i=0;i<xstr.iatoms.size();i++){iatoms.push_back(xstr.iatoms[i][0]);}

    string name=ICSDName;
    vector<string> vspecies;
    aflowlib::GetSpeciesDirectory(directory,vspecies);

    vector<double> number;
    for(uint i=0;i<xstr.num_each_type.size();i++){number.push_back(xstr.num_each_type[i]);}

    //CO20171018 - do NOT read iatoms file, this comes pre-relaxation
    //aflow has a habit of shrinking the structure between relax2 and static IF POSSIBLE
    //[OBSOLETE]  //READ iatoms.out file
    //[OBSOLETE]  bool iatomsfound=FALSE;
    //[OBSOLETE]  if(!iatomsfound&&aurostd::FileExist(directory+"/aflow.iatoms.out"+XHOST.vext.at(iext))) iatomsfound=aurostd::efile2stringstream(directory+"/aflow.iatoms.out"+XHOST.vext.at(iext),iatomsfile);
    //[OBSOLETE]  if(!iatomsfound) {
    //[OBSOLETE]    cerr << function_name << " ERROR: aflow.iatoms.out"+XHOST.vext.at(iext)+" not found in the directory, aborting."<< endl;
    //[OBSOLETE]    return FALSE;
    //[OBSOLETE]  }
    //[OBSOLETE]  vector<int> iatoms;
    //[OBSOLETE]  for(int i=0;i<3;i++) getline(iatomsfile,stmp);
    //[OBSOLETE]  /*cerr << stmp << endl;
    //[OBSOLETE]  iatomsfile >> stmp >> iatom; iatoms.push_back(iatom); getline(iatomsfile,stmp);
    //[OBSOLETE]  cerr << iatom << endl;
    //[OBSOLETE]  iatomsfile >> stmp >> iatom; iatoms.push_back(iatom);
    //[OBSOLETE]  cerr << iatom << endl;*/
    //[OBSOLETE]  int iatom =0;
    //[OBSOLETE]  int count =0;
    //[OBSOLETE]  while(iatomsfile >> stmp >> iatom){
    //[OBSOLETE]      getline(iatomsfile,stmp);
    //[OBSOLETE]      iatoms.push_back(iatom); 
    //[OBSOLETE]      count++;
    //[OBSOLETE]      //if(stmp == "------------------------------------------------------------------------------------------------") break;
    //[OBSOLETE]  }
    //[OBSOLETE]  string name;
    //[OBSOLETE]  vector<string> vspecies;
    //[OBSOLETE]  vector<double> number;
    //[OBSOLETE]  iatomsfile.clear();
    //[OBSOLETE]  iatomsfile.seekg (0, std::ios::beg);
    //[OBSOLETE]  for(int i=0;i<count+4;i++) getline(iatomsfile,stmp); 
    //[OBSOLETE]  iatomsfile >> name >> stmp; 
    //[OBSOLETE]  if(name.find("/") != std::string::npos) { name.erase(name.find("/"),name.length()); }
    //[OBSOLETE]  //cerr << name << endl;
    //[OBSOLETE]  XATOM_SplitAlloySpecies(name,vspecies);
    //[OBSOLETE]  //for(uint i=0;i<vspecies.size();i++) cerr << vspecies.at(i) << endl;
    //[OBSOLETE]  for(int i=0;i<6;i++) getline(iatomsfile,stmp);
    //[OBSOLETE]  //cerr << stmp << endl;
    //[OBSOLETE]  aurostd::string2tokens(stmp,number," ");
    //[OBSOLETE]  //for(uint i=0;i<number.size();i++) cerr << number.at(i) << endl;
    //[OBSOLETE]  //cerr << "inequilvent atoms : " << endl;
    //[OBSOLETE]  //for(uint i=0;i<iatoms.size();i++) cerr << iatoms.at(i) << endl;
    //CO20171025 STOP

    vector<vector<double> > TDOS, TOTALPDOS;
    vector<vector<vector<double> > > PDOS;
    GET_DOS_DATA(directory, Efermi, TDOS, TOTALPDOS, PDOS);       

    //CO20180216
    bool found_TDOS=(TDOS.size()>0 && TDOS[0].size()>0);
    bool found_PDOS=(PDOS.size()>0 && PDOS[0].size()>0 && PDOS[0][0].size()>0);

    for(int i=0;i<4;i++) getline(dosfile,stmp);
    /*dosfile >> ICSDName;*/ getline(dosfile,stmp);
    dosfile >> Emax >> Emin >> DOSGRID >> Efermi >> stmp; getline(dosfile, stmp);

    if(wrapping_brackets){json << "{" << std::endl;}  //CO20171025
    json << "     \"name\": " << "\"" << name << "\"," <<endl;
    json << "     \"species\": [" << "\"" << vspecies[0] << "\"";
    for(uint i=1;i<vspecies.size();i++) json << ", \"" << vspecies[i] << "\"";
    json << "]," << endl;
    json << "     \"composition\": [" << number[0]; //CO20171025
    for(uint i=1;i<number.size();i++) json << ", " << number[i];
    json << "]," << endl;
    json << "     \"Emin\": " << Emin << "," << std::endl;
    json << "     \"Emax\": " << Emax << "," << std::endl;
    json << "     \"Efermi\": " << Efermi << "," << std::endl;
    json << "     \"DOS_grid\": " << DOSGRID << ((found_TDOS||found_PDOS)?string(","):string("")) << std::endl; //CO20171025
    //*******************************************************************
    //********************          DOS           ***********************
    //*******************************************************************

    //--------------------    (non-polarized)     -----------------------
    if(found_TDOS){  //CO20180216
      if(TDOS[0].size() == 3){
        json << "     \"tDOS_data\": {" << std::endl; //CO20171025
        json << "          \"energy\": [";
        json << TDOS[0][0];
        for (int i=1; i <DOSGRID; i++)json << "," << TDOS[i][0];    
        json << "]," << std::endl;

        json << "          \"tDOS\": ["; //CO20171025
        json << TDOS[0][1];
        for (int i=1; i <DOSGRID; i++)json << "," << TDOS[i][1];    
        json << "]," << std::endl;

        json << "          \"sum\": [";
        json << TDOS[0][2];
        for (int i=1; i <DOSGRID; i++)json << "," << TDOS[i][2];    
        json << "]" << std::endl;
        json << "     }" << (found_PDOS?string(","):string("")) << std::endl; //CO20180216
      }

      //--------------------      (polarized)       -----------------------
      if(TDOS[0].size() == 5){
        json << "     \"tDOS_data\": {" << std::endl; //CO20171025
        json << "          \"energy\": [";
        json << TDOS[0][0];
        for (int i=1; i <DOSGRID; i++)json << "," << TDOS[i][0];    
        json << "]," << std::endl;

        json << "          \"spin_majority\": [";
        json << TDOS[0][1];
        for (int i=1; i <DOSGRID; i++)json << "," << TDOS[i][1];    
        json << "]," << std::endl;

        json << "          \"spin_minority\": [";
        json << TDOS[0][2];
        for (int i=1; i <DOSGRID; i++)json << "," << TDOS[i][2];    
        json << "]," << std::endl;

        json << "          \"sum_spin_majority\": [";
        json << TDOS[0][3];
        for (int i=1; i <DOSGRID; i++)json << "," << TDOS[i][3];    
        json << "]," << std::endl;

        json << "          \"sum_spin_minority\": [";
        json << TDOS[0][4];
        for (int i=1; i <DOSGRID; i++)json << "," << TDOS[i][4];    
        json << "]" << std::endl;

        json << "     }" << (found_PDOS?string(","):string("")) << std::endl;   //CO20180216
      }
    }

    //*******************************************************************
    //********************          PDOS          ***********************
    //*******************************************************************

    //--------------------s, p , d (non-polarized)-----------------------
    if(found_PDOS){
      if(PDOS[0][0].size()==4){
        json << "     \"pDOS_data\": {" << std::endl; //CO20171025

        json << "          \"orbitals\": [\"s\", \"p\", \"d\"]," << std::endl;
        json << "          \"spin_polarized\": false," << std::endl;

        json << "          \"energy\": [" << TOTALPDOS[0][0];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][0];
        json << "]," << std::endl;

        inequivalentAtomsJSON(PDOS,iatoms,number,vspecies,json);

        json << "          \"sum_s\": [" << TOTALPDOS[0][1];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][1];
        json << "]," << std::endl;

        json << "          \"sum_p\": [" << TOTALPDOS[0][2];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][2];
        json << "]," << std::endl;

        json << "          \"sum_d\": [" << TOTALPDOS[0][3];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][3];
        json << "]" << std::endl;

        json << "     }";
      }

      //--------------------s, p, d, f (non-polarized)-----------------------
      if(PDOS[0][0].size()==5){
        json << "     \"pDOS_data\": {" << std::endl; //CO20171025

        json << "          \"orbitals\": [\"s\", \"p\", \"d\", \"f\"]," << std::endl;
        json << "          \"spin_polarized\": false," << std::endl;

        json << "          \"energy\": [" << TOTALPDOS[0][0];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][0];
        json << "]," << std::endl;

        inequivalentAtomsJSON(PDOS,iatoms,number,vspecies,json);

        json << "          \"sum_s\": [" << TOTALPDOS[0][1];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][1];
        json << "]," << std::endl;

        json << "          \"sum_p\": [" << TOTALPDOS[0][2];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][2];
        json << "]," << std::endl;

        json << "          \"sum_d\": [" << TOTALPDOS[0][3];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][3];
        json << "]," << std::endl;

        json << "          \"sum_f\": [" << TOTALPDOS[0][4];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][4];
        json << "]" << std::endl;

        json << "     }";
      }

      //--------------------s, p , d (polarized)-----------------------
      if(PDOS[0][0].size()==7){
        json << "     \"pDOS_data\": {" << std::endl; //CO20171025

        json << "          \"orbitals\": [\"s\", \"p\", \"d\"]," << std::endl;
        json << "          \"spin_polarized\": true," << std::endl;

        json << "          \"energy\": [" << TOTALPDOS[0][0];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][0];
        json << "]," << std::endl;

        inequivalentAtomsJSON(PDOS,iatoms,number,vspecies,json);

        json << "          \"sum_s_majority\": [" << TOTALPDOS[0][1];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][1];
        json << "]," << std::endl;

        json << "          \"sum_s_minority\": [" << TOTALPDOS[0][2];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][2];
        json << "]," << std::endl;

        json << "          \"sum_p_majority\": [" << TOTALPDOS[0][3];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][3];
        json << "]," << std::endl;

        json << "          \"sum_p_minority\": [" << TOTALPDOS[0][4];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][4];
        json << "]," << std::endl;

        json << "          \"sum_d_majority\": [" << TOTALPDOS[0][5];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][5];
        json << "]," << std::endl;

        json << "          \"sum_d_minority\": [" << TOTALPDOS[0][6];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][6];
        json << "]" << std::endl;

        json << "     }";
      }

      //--------------------s, p, d, f (polarized)-----------------------
      if(PDOS[0][0].size()==9){
        json << "     \"pDOS_data\": {" << std::endl; //CO20171025

        json << "          \"orbitals\": [\"s\", \"p\", \"d\", \"f\"]," << std::endl;
        json << "          \"spin_polarized\": true," << std::endl;

        json << "          \"energy\": [" << TOTALPDOS[0][0];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][0];
        json << "]," << std::endl;

        inequivalentAtomsJSON(PDOS,iatoms,number,vspecies,json);

        json << "          \"sum_s_majority\": [" << TOTALPDOS[0][1];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][1];
        json << "]," << std::endl;

        json << "          \"sum_s_minority\": [" << TOTALPDOS[0][2];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][2];
        json << "]," << std::endl;

        json << "          \"sum_p_majority\": [" << TOTALPDOS[0][3];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][3];
        json << "]," << std::endl;

        json << "          \"sum_p_minority\": [" << TOTALPDOS[0][4];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][4];
        json << "]," << std::endl;

        json << "          \"sum_d_majority\": [" << TOTALPDOS[0][5];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][5];
        json << "]," << std::endl;

        json << "          \"sum_d_minority\": [" << TOTALPDOS[0][6];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][6];
        json << "]," << std::endl;

        json << "          \"sum_f_majority\": [" << TOTALPDOS[0][7];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][7];
        json << "]," << std::endl;

        json << "          \"sum_f_minority\": [" << TOTALPDOS[0][8];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][8];
        json << "]" << std::endl;

        json << "     }";
      }

      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2 (non-spin-polarized)-----
      if(PDOS[0][0].size()==10){
        json << "     \"pDOS_data\": {" << std::endl; //CO20171025

        json << "          \"orbitals\": [\"s\", \"p\", \"d\"]," << std::endl;
        json << "          \"spin_polarized\": false," << std::endl;

        json << "          \"energy\": [" << TOTALPDOS[0][0];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][0];
        json << "]," << std::endl;

        inequivalentAtomsJSON(PDOS,iatoms,number,vspecies,json);

        json << "          \"sum_s\": [" << TOTALPDOS[0][1];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][1];
        json << "]," << std::endl;

        json << "          \"sum_p\": [" << TOTALPDOS[0][2];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][2];
        json << "]," << std::endl;

        json << "          \"sum_d\": [" << TOTALPDOS[0][3];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][3];
        json << "]," << std::endl;

        json << "     }";
      }

      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... (LS COUPLINT)------------
      if(PDOS[0][0].size()==13){
        json << "     \"pDOS_data\": {" << std::endl; //CO20171025

        json << "          \"orbitals\": [\"s\", \"p\", \"d\"]," << std::endl;
        json << "          \"spin_polarized\": false," << std::endl;

        json << "          \"energy\": [" << TOTALPDOS[0][0];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][0];
        json << "]," << std::endl;

        inequivalentAtomsJSON(PDOS,iatoms,number,vspecies,json);

        json << "          \"sum_s\": [" << TOTALPDOS[0][1];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][1];
        json << "]," << std::endl;

        json << "          \"sum_p\": [" << TOTALPDOS[0][2];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][2];
        json << "]," << std::endl;

        json << "          \"sum_d\": [" << TOTALPDOS[0][3];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][3];
        json << "]" << std::endl;

        json << "     }";
      }

      //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2, f1 to f7 (non-spin-polarized)-----
      //--------------------                        OR                           ------------------------
      //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... ftotal ..(LS COUPLINT)------------
      if(PDOS[0][0].size()==17){
        json << "     \"pDOS_data\": {" << std::endl; //CO20171025

        json << "          \"orbitals\": [\"s\", \"p\", \"d\", \"f\"]," << std::endl;
        json << "          \"spin_polarized\": false," << std::endl;

        json << "          \"energy\": [" << TOTALPDOS[0][0];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][0];
        json << "]," << std::endl;

        inequivalentAtomsJSON(PDOS,iatoms,number,vspecies,json);

        json << "          \"sum_s\": [" << TOTALPDOS[0][1];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][1];
        json << "]," << std::endl;

        json << "          \"sum_p\": [" << TOTALPDOS[0][2];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][2];
        json << "]," << std::endl;

        json << "          \"sum_d\": [" << TOTALPDOS[0][3];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][3];
        json << "]," << std::endl;

        json << "          \"sum_f\": [" << TOTALPDOS[0][4];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][4];
        json << "]" << std::endl;

        json << "     }";
      }

      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn (spin-polarized)-----
      if(PDOS[0][0].size()==19){
        json << "     \"pDOS_data\": {" << std::endl; //CO20171025

        json << "          \"orbitals\": [\"s\", \"p\", \"d\"]," << std::endl;
        json << "          \"spin_polarized\": true," << std::endl;

        json << "          \"energy\": [" << TOTALPDOS[0][0];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][0];
        json << "]," << std::endl;

        inequivalentAtomsJSON(PDOS,iatoms,number,vspecies,json);

        json << "          \"sum_s_majority\": [" << TOTALPDOS[0][1];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][1];
        json << "]," << std::endl;

        json << "          \"sum_s_minority\": [" << TOTALPDOS[0][2];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][2];
        json << "]," << std::endl;

        json << "          \"sum_p_majority\": [" << TOTALPDOS[0][3];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][3];
        json << "]," << std::endl;

        json << "          \"sum_p_minority\": [" << TOTALPDOS[0][4];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][4];
        json << "]," << std::endl;

        json << "          \"sum_d_majority\": [" << TOTALPDOS[0][5];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][5];
        json << "]," << std::endl;

        json << "          \"sum_d_minority\": [" << TOTALPDOS[0][6];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][6];
        json << "]" << std::endl;

        json << "     }";
      }

      //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn, (f1, f2, f3...) (spin-polarized)-----
      if(PDOS[0][0].size()==33){
        json << "     \"pDOS_data\": {" << std::endl; //CO20171025

        json << "          \"orbitals\": [\"s\", \"p\", \"d\", \"f\"]," << std::endl;
        json << "          \"spin_polarized\": true," << std::endl;

        json << "          \"energy\": [" << TOTALPDOS[0][0];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][0];
        json << "]," << std::endl;

        inequivalentAtomsJSON(PDOS,iatoms,number,vspecies,json);

        json << "          \"sum_s_majority\": [" << TOTALPDOS[0][1];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][1];
        json << "]," << std::endl;

        json << "          \"sum_s_minority\": [" << TOTALPDOS[0][2];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][2];
        json << "]," << std::endl;

        json << "          \"sum_p_majority\": [" << TOTALPDOS[0][3];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][3];
        json << "]," << std::endl;

        json << "          \"sum_p_minority\": [" << TOTALPDOS[0][4];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][4];
        json << "]," << std::endl;

        json << "          \"sum_d_majority\": [" << TOTALPDOS[0][5];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][5];
        json << "]," << std::endl;

        json << "          \"sum_d_minority\": [" << TOTALPDOS[0][6];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][6];
        json << "]," << std::endl;

        json << "          \"sum_f_majority\": [" << TOTALPDOS[0][7];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][7];
        json << "]," << std::endl;

        json << "          \"sum_f_minority\": [" << TOTALPDOS[0][8];
        for(int i=1;i<DOSGRID;i++) json << "," << TOTALPDOS[i][8];
        json << "]" << std::endl;

        json << "     }";
      }
    }
    if(wrapping_brackets){json << std::endl << "}";} //CO20171025
    return TRUE; //tokens.size();    
  }

  /*------------------------------------------------------------------------------------/
   * inequivalentAtomsJSON                                                             /
   *                                                                                  /
   * Constructs the JSON part of the DOS json for the inequivalent atoms PDOS        /
   *                                                                                /
   * _____________________________________________________________________________*/
  uint inequivalentAtomsJSON(vector<vector<vector<double> > >& PDOS,  vector<int>& iatoms, vector<double>& numbers, vector<string>& vspecies, ostream& json){
    vector<int> sum_numbers;
    int sum = 0;
    for(uint i=0;i<numbers.size();i++){
      sum = sum + numbers.at(i);
      sum_numbers.push_back(sum);
    }

    //cerr << endl << endl;
    for(uint i=0;i<vspecies.size();i++){
      json << "          \"" << vspecies.at(i) << "\": {" << endl;
      int comma = false; 
      for(uint j=0;j<iatoms.size();j++){ 
        if(i){
          if(iatoms.at(j)>=sum_numbers.at(i-1) && iatoms.at(j)<sum_numbers.at(i)){
            if(comma) json << "," << endl;
            json << "               \"" << iatoms.at(j) << "\": {" << endl;
            constructInequivalentAtomPDOSJSON(PDOS,iatoms.at(j),json);
            json << "               }";
            comma=true;
          }
        } else {
          if(iatoms.at(j)<sum_numbers.at(i)){
            //cerr << sum_numbers.at(i) << endl;
            if(comma) json << "," << endl; 
            json << "               \"" << iatoms.at(j) << "\": {" << endl;
            constructInequivalentAtomPDOSJSON(PDOS,iatoms.at(j),json);
            json << "               }";
            comma=true; 
          }
        }
      }
      json << endl << "          }," << endl;
    } 
    return PDOS.size();
  }


  /*------------------------------------------------------------------------------------/
   * constructInequivalentAtomsPDOSJSON                                                /
   *                                                                                  /
   * Takes in the PDOS data and determines the correct JSON output based on its      /
   * contents.                                                                       /
   * _____________________________________________________________________________*/
  uint constructInequivalentAtomPDOSJSON(vector<vector<vector<double> > >& PDOS, int iatom, ostream& json){
    //--------------------s, p , d (non-polarized)-----------------------
    if(PDOS[0][0].size()==4){
      json << "                    \"s\": [" << PDOS[iatom][0][1];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1];
      json << "]," << endl;
      json << "                    \"p\": [" << PDOS[iatom][0][2];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][2];
      json << "]," << endl;
      json << "                    \"d\": [" << PDOS[iatom][0][3];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][3];
      json << "]," << endl;
      json << "                    \"total\": [" << PDOS[iatom][0][1]+PDOS[iatom][0][2]+PDOS[iatom][0][3];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1]+PDOS[iatom][k][2]+PDOS[iatom][k][3];
      json << "]" << endl;

    }
    //--------------------s, p , d, f (non-polarized)-----------------------
    if(PDOS[0][0].size()==5){
      json << "                    \"s\": [" << PDOS[iatom][0][1];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1];
      json << "]," << endl;
      json << "                    \"p\": [" << PDOS[iatom][0][2];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][2];
      json << "]," << endl;
      json << "                    \"d\": [" << PDOS[iatom][0][3];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][3];
      json << "]," << endl;
      json << "                    \"f\": [" << PDOS[iatom][0][4];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][4];
      json << "]," << endl;
      json << "                    \"total\": [" << PDOS[iatom][0][1]+PDOS[iatom][0][2]+PDOS[iatom][0][3]+PDOS[iatom][0][4];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1]+PDOS[iatom][k][2]+PDOS[iatom][k][3]+PDOS[iatom][k][4];
      json << "]" << endl;
    }
    //--------------------s, p , d (polarized)-----------------------
    if(PDOS[0][0].size()==7){
      json << "                    \"s_majority\": [" << PDOS[iatom][0][1];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1];
      json << "]," << endl;
      json << "                    \"s_minority\": [" << PDOS[iatom][0][2];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][2];
      json << "]," << endl;
      json << "                    \"p_majority\": [" << PDOS[iatom][0][3];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][3];
      json << "]," << endl;
      json << "                    \"p_minority\": [" << PDOS[iatom][0][4];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][4];
      json << "]," << endl;
      json << "                    \"d_majority\": [" << PDOS[iatom][0][5];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][5];
      json << "]," << endl;
      json << "                    \"d_minority\": [" << PDOS[iatom][0][6];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][6];
      json << "]," << endl;
      json << "                    \"total_majority\": [" << PDOS[iatom][0][1]+PDOS[iatom][0][3]+PDOS[iatom][0][5];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1]+PDOS[iatom][k][3]+PDOS[iatom][k][5];
      json << "]," << endl;
      json << "                    \"total_minority\": [" << PDOS[iatom][0][2]+PDOS[iatom][0][4]+PDOS[iatom][0][6];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][2]+PDOS[iatom][k][4]+PDOS[iatom][k][6];
      json << "]" << endl;
    }
    //--------------------s, p, d, f (polarized)-----------------------
    if(PDOS[0][0].size()==9){
      json << "                    \"s_majority\": [" << PDOS[iatom][0][1];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1];
      json << "]," << endl;
      json << "                    \"s_minority\": [" << PDOS[iatom][0][2];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][2];
      json << "]," << endl;
      json << "                    \"p_majority\": [" << PDOS[iatom][0][3];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][3];
      json << "]," << endl;
      json << "                    \"p_minority\": [" << PDOS[iatom][0][4];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][4];
      json << "]," << endl;
      json << "                    \"d_majority\": [" << PDOS[iatom][0][5];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][5];
      json << "]," << endl;
      json << "                    \"d_minority\": [" << PDOS[iatom][0][6];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][6];
      json << "]," << endl;
      json << "                    \"f_majority\": [" << PDOS[iatom][0][7];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][7];
      json << "]," << endl;
      json << "                    \"f_minority\": [" << PDOS[iatom][0][8];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][8];
      json << "]," << endl;
      json << "                    \"total_majority\": [" << PDOS[iatom][0][1]+PDOS[iatom][0][3]+PDOS[iatom][0][5]+PDOS[iatom][0][7];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1]+PDOS[iatom][k][3]+PDOS[iatom][k][5]+PDOS[iatom][k][7];
      json << "]," << endl;
      json << "                    \"total_minority\": [" << PDOS[iatom][0][2]+PDOS[iatom][0][4]+PDOS[iatom][0][6]+PDOS[iatom][0][8];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][2]+PDOS[iatom][k][4]+PDOS[iatom][k][6]+PDOS[iatom][k][8];
      json << "]" << endl;
    }
    //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2 (non-spin-polarized)-----
    if(PDOS[0][0].size()==10){
      json << "                    \"s\": [" << PDOS[iatom][0][1];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1];
      json << "]," << endl;
      json << "                    \"py\": [" << PDOS[iatom][0][2];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][2];
      json << "]," << endl;
      json << "                    \"pz\": [" << PDOS[iatom][0][3];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][3];
      json << "]," << endl;
      json << "                    \"px\": [" << PDOS[iatom][0][4];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][4];
      json << "]," << endl;
      json << "                    \"dxy\": [" << PDOS[iatom][0][5];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][5];
      json << "]," << endl;
      json << "                    \"dyz\": [" << PDOS[iatom][0][6];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][6];
      json << "]," << endl;
      json << "                    \"dz2\": [" << PDOS[iatom][0][7];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][7];
      json << "]," << endl;
      json << "                    \"dxz\": [" << PDOS[iatom][0][8];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][8];
      json << "]," << endl;
      json << "                    \"dx2-y2\": [" << PDOS[iatom][0][9];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][9];
      json << "]," << endl;
      json << "                    \"total\": [" << PDOS[iatom][0][1]+PDOS[iatom][0][2]+PDOS[iatom][0][3]+PDOS[iatom][0][4]+PDOS[iatom][0][5]+PDOS[iatom][0][6]+PDOS[iatom][0][7]+PDOS[iatom][0][8]+PDOS[iatom][0][9];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1]+PDOS[iatom][k][2]+PDOS[iatom][k][3]+PDOS[iatom][k][4]+PDOS[iatom][k][5]+PDOS[iatom][k][6]+PDOS[iatom][k][7]+PDOS[iatom][k][8]+PDOS[iatom][k][9];
      json << "]" << endl;
    }
    //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... (LS COUPLINT)------------
    if(PDOS[0][0].size()==13){
      json << "                    \"s_total\": [" << PDOS[iatom][0][1];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1];
      json << "]," << endl;
      json << "                    \"sx\": [" << PDOS[iatom][0][2];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][2];
      json << "]," << endl;
      json << "                    \"sy\": [" << PDOS[iatom][0][3];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][3];
      json << "]," << endl;
      json << "                    \"sz\": [" << PDOS[iatom][0][4];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][4];
      json << "]," << endl;
      json << "                    \"p_total\": [" << PDOS[iatom][0][5];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][5];
      json << "]," << endl;
      json << "                    \"px\": [" << PDOS[iatom][0][6];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][6];
      json << "]," << endl;
      json << "                    \"py\": [" << PDOS[iatom][0][7];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][7];
      json << "]," << endl;
      json << "                    \"pz\": [" << PDOS[iatom][0][8];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][8];
      json << "]," << endl;
      json << "                    \"d_total\": [" << PDOS[iatom][0][9];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][9];
      json << "]," << endl;
      json << "                    \"dx\": [" << PDOS[iatom][0][10];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][10];
      json << "]," << endl;
      json << "                    \"dy\": [" << PDOS[iatom][0][11];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][11];
      json << "]," << endl;
      json << "                    \"dz\": [" << PDOS[iatom][0][12];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][12];
      json << "]," << endl;
      json << "                    \"total\": [" << PDOS[iatom][0][1]+PDOS[iatom][0][5]+PDOS[iatom][0][9];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1]+PDOS[iatom][k][5]+PDOS[iatom][k][9];
      json << "]" << endl;

    }
    //--------------------s, py, pz, px, dxy, dyz, dz2, dxz, dx2-y2, f1 to f7 (non-spin-polarized)-----
    //--------------------                        OR                           ------------------------
    //--------------------stotal, sx, sy, xz, ptotal, px, py, pz ... ftotal ..(LS COUPLINT)------------
    if(PDOS[0][0].size()==17){
      cerr << "TODO" << endl;
    }
    //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn (spin-polarized)-----
    if(PDOS[0][0].size()==19){
      json << "                    \"s_majority\": [" << PDOS[iatom][0][1];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1];
      json << "]," << endl;
      json << "                    \"s_minority\": [" << PDOS[iatom][0][2];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][2];
      json << "]," << endl;
      json << "                    \"py_majority\": [" << PDOS[iatom][0][3];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][3];
      json << "]," << endl;
      json << "                    \"py_minority\": [" << PDOS[iatom][0][4];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][4];
      json << "]," << endl;
      json << "                    \"pz_majority\": [" << PDOS[iatom][0][5];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][5];
      json << "]," << endl;
      json << "                    \"pz_minority\": [" << PDOS[iatom][0][6];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][6];
      json << "]," << endl;
      json << "                    \"px_majority\": [" << PDOS[iatom][0][7];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][7];
      json << "]," << endl;
      json << "                    \"px_minority\": [" << PDOS[iatom][0][8];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][8];
      json << "]," << endl;
      json << "                    \"dxy_majority\": [" << PDOS[iatom][0][9];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][9];
      json << "]," << endl;
      json << "                    \"dxy_minority\": [" << PDOS[iatom][0][10];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][10];
      json << "]," << endl;
      json << "                    \"dyz_majority\": [" << PDOS[iatom][0][11];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][11];
      json << "]," << endl;
      json << "                    \"dyz_minority\": [" << PDOS[iatom][0][12];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][12];
      json << "]," << endl;
      json << "                    \"dz2_majority\": [" << PDOS[iatom][0][13];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][13];
      json << "]," << endl;
      json << "                    \"dz2_minority\": [" << PDOS[iatom][0][14];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][14];
      json << "]," << endl;
      json << "                    \"dxz_majority\": [" << PDOS[iatom][0][15];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][15];
      json << "]," << endl;
      json << "                    \"dxz_minority\": [" << PDOS[iatom][0][16];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][16];
      json << "]," << endl;
      json << "                    \"dx2-y2_majority\": [" << PDOS[iatom][0][17];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][17];
      json << "]," << endl;
      json << "                    \"dx2-y2_minority\": [" << PDOS[iatom][0][18];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][18];
      json << "]" << endl;
    }
    //--------------------s, (py, pz, px)_spin_up_dn, (dxy, dyz, dz2, dxz, dx2-y2)_spin_up_dn, (f1, f2, f3...) (spin-polarized)-----
    if(PDOS[0][0].size()==33){
      json << "                    \"s_majority\": [" << PDOS[iatom][0][1];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][1];
      json << "]," << endl;
      json << "                    \"s_minority\": [" << PDOS[iatom][0][2];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][2];
      json << "]," << endl;
      json << "                    \"py_majority\": [" << PDOS[iatom][0][3];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][3];
      json << "]," << endl;
      json << "                    \"py_minority\": [" << PDOS[iatom][0][4];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][4];
      json << "]," << endl;
      json << "                    \"pz_majority\": [" << PDOS[iatom][0][5];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][5];
      json << "]," << endl;
      json << "                    \"pz_minority\": [" << PDOS[iatom][0][6];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][6];
      json << "]," << endl;
      json << "                    \"px_majority\": [" << PDOS[iatom][0][7];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][7];
      json << "]," << endl;
      json << "                    \"px_minority\": [" << PDOS[iatom][0][8];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][8];
      json << "]," << endl;
      json << "                    \"dxy_majority\": [" << PDOS[iatom][0][9];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][9];
      json << "]," << endl;
      json << "                    \"dxy_minority\": [" << PDOS[iatom][0][10];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][10];
      json << "]," << endl;
      json << "                    \"dyz_majority\": [" << PDOS[iatom][0][11];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][11];
      json << "]," << endl;
      json << "                    \"dyz_minority\": [" << PDOS[iatom][0][12];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][12];
      json << "]," << endl;
      json << "                    \"dz2_majority\": [" << PDOS[iatom][0][13];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][13];
      json << "]," << endl;
      json << "                    \"dz2_minority\": [" << PDOS[iatom][0][14];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][14];
      json << "]," << endl;
      json << "                    \"dxz_majority\": [" << PDOS[iatom][0][15];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][15];
      json << "]," << endl;
      json << "                    \"dxz_minority\": [" << PDOS[iatom][0][16];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][16];
      json << "]," << endl;
      json << "                    \"dx2-y2_majority\": [" << PDOS[iatom][0][17];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][17];
      json << "]," << endl;
      json << "                    \"dx2-y2_minority\": [" << PDOS[iatom][0][18];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][18];
      json << "]," << endl;
      json << "                    \"f1_majority\": [" << PDOS[iatom][0][19];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][19];
      json << "]," << endl;
      json << "                    \"f1_minority\": [" << PDOS[iatom][0][20];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][20];
      json << "]," << endl;
      json << "                    \"f2_majority\": [" << PDOS[iatom][0][21];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][21];
      json << "]," << endl;
      json << "                    \"f2_minority\": [" << PDOS[iatom][0][22];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][22];
      json << "]," << endl;
      json << "                    \"f3_majority\": [" << PDOS[iatom][0][23];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][23];
      json << "]," << endl;
      json << "                    \"f3_minority\": [" << PDOS[iatom][0][24];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][24];
      json << "]," << endl;
      json << "                    \"f4_majority\": [" << PDOS[iatom][0][25];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][25];
      json << "]," << endl;
      json << "                    \"f4_minority\": [" << PDOS[iatom][0][26];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][26];
      json << "]," << endl;
      json << "                    \"f5_majority\": [" << PDOS[iatom][0][27];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][27];
      json << "]," << endl;
      json << "                    \"f5_minority\": [" << PDOS[iatom][0][28];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][28];
      json << "]," << endl;
      json << "                    \"f6_majority\": [" << PDOS[iatom][0][29];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][29];
      json << "]," << endl;
      json << "                    \"f6_minority\": [" << PDOS[iatom][0][30];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][30];
      json << "]," << endl;
      json << "                    \"f7_majority\": [" << PDOS[iatom][0][31];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][31];
      json << "]," << endl;
      json << "                    \"f7_minority\": [" << PDOS[iatom][0][32];
      for(uint k=1;k<PDOS[0].size();k++) json << "," << PDOS[iatom][k][32];
      json << "]" << endl;
    }
    return PDOS.size();
  } 

} // namespace estructure



/*********************************************************
 *   BANDSDATA_JSON
 *
 *   ERIC G
 *
 *   Gathers the BANDS data and constucts a json file. 
 *   The way the bands data is calculated is copied from 
 *   the Bands plot functions above.
 *   
 *
 *********************************************************/
namespace estructure {

  bool BANDSDATA_JSON(aurostd::xoption& vpflow,ostream& oss){
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::BANDSDATA_JSON():";
    vector<string> tokens;
    aurostd::string2tokens(vpflow.getattachedscheme("BANDSDATA2JSON"),tokens,",");
    bool SUCCESS=TRUE;
    string directory;
    vector<string> directories;
    for(uint i=0;i<tokens.size();i++){
      directory = aurostd::CleanFileName(tokens[i]);
      if(!aurostd::IsDirectory(directory)){
        cerr << function_name << " directory does not exist = " << directory << endl;
        continue;
      }
      directories.push_back(directory);
    }
    stringstream json; json.str("");
    json.precision(6);
    if(directories.size()>1){oss << "[" << std::endl;}
    for(uint i=0;i<directories.size();i++){
      directory=directories[i];
      if(LDEBUG) cerr << function_name << " working in directory=" << directory << endl;
      //oss << "{" << std::endl; //CO20171025
      SUCCESS = SUCCESS && BANDSDATA_JSON(vpflow,directory,json,true); //CO20171025
      oss << json.str(); json.str("");
      //oss <<std::endl  << "}"; //CO20171025
      if(i!=directories.size()-1){oss<<",";}
      oss << std::endl;
    }
    if(directories.size()>1){oss << "]" << std::endl;}
    return SUCCESS;
  }

  bool BANDSDATA_JSON(aurostd::xoption& vpflow, string directory, stringstream& json,bool wrapping_brackets){ //CO20171025
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string function_name = XPID + "estructure::BANDSDATA_JSON():";
    stringstream message;
    if(LDEBUG) cerr << function_name << " BEGIN" << endl;

    if(vpflow.flag("BANDSDATA2JSON")){;} //dummy load

    //ofstream json(json_dir.c_str());
    //json.precision(6);

    //vector<string> tokens;
    //aurostd::string2tokens(options,tokens,",");

    //if(LDEBUG) cerr << function_name << " options=[" << options << "]" << endl;

    int ISPIN=1, NIONS, NELECT, Nbands, NKPOINTS, KPOINTSGRID;
    double Efermi, ftmp, ftmpup, ftmpdn;
    string LattName, ICSDName, DOSCARfile, OUTCARfile, EIGENVALfile, POSCARfile, KPOINTSfile, stmp, line;
    stringstream straus, stringstreamtmp, strline, dosfile, ss_outcar, ss_doscar, ss_engenval, ss_kpoints;
    stringstream ss_eigenval;

    //if(tokens.size()>=1) directory= tokens.at(0);
    if(LDEBUG) cerr << function_name << " working in directory= " << directory << endl;

    ICSDName= KBIN::ExtractSystemName(directory); //Get SystemName

    string anchor_word_Efermi = "E-fermi";
    string anchor_word_NIONS = "NIONS";
    string anchor_word_vc = "volume of cell";
    string anchor_word_LSORBIT="LSORBIT =      T";

    aflowlib::vaspfile2stringstream(directory, "OUTCAR", ss_outcar);
    xvector<double> a1(3); xvector<double> a2(3); xvector<double> a3(3);
    xvector<double> b1(3); xvector<double> b2(3); xvector<double> b3(3);


    while(getline(ss_outcar, line)) {
      if (line.find(anchor_word_Efermi) !=string::npos) {
        strline.clear();    
        strline.str(line);
        strline >> stmp >> stmp >> Efermi;
      }
      if (line.find(anchor_word_NIONS) !=string::npos) {
        strline.clear();    
        strline.str(line);
        strline >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> stmp >> NIONS;
      }
      if (line.find(anchor_word_vc) !=string::npos) {
        getline(ss_outcar, line); ss_outcar >> a1[1] >> a1[2] >> a1[3] >> b1[1] >> b1[2] >> b1[3];
        getline(ss_outcar, line); ss_outcar >> a2[1] >> a2[2] >> a2[3] >> b2[1] >> b2[2] >> b2[3];
        getline(ss_outcar, line); ss_outcar >> a3[1] >> a3[2] >> a3[3] >> b3[1] >> b3[2] >> b3[3];  
      }
    }

    //***********************************DEALING WITH BANDSDATA**************************************************************

    aflowlib::vaspfile2stringstream(directory, "EIGENVAL", ss_engenval);
    //cout << ss_engenval.str() << endl;throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,"Throw for debugging purposes.",_GENERIC_ERROR_);

    //Read FLAG of SPIN, if SPIN=1,Non-spin-polarized; IF SPIN=2, spin-polarized
    ss_engenval >> stmp >> stmp >> stmp >> ISPIN;   

    //Read the headfile of EIGENVAL 
    for(int i=0; i< 5; i++) getline(ss_engenval, stmp);
    ss_engenval >> NELECT >> NKPOINTS >> Nbands;
    getline(ss_engenval, stmp);  //Read the line containing NELECT, NKPOINTS, NBANDS

    //Creating data to store bands data
    vector<vector<double> > datakpoints(NKPOINTS);
    vector<vector<double> > dataup(NKPOINTS); //Define two-dimensional arrary
    vector<vector<double> > datadn(NKPOINTS); //Define two-dimensional arrary
    for (int i=0; i<NKPOINTS; i++){
      datakpoints[i].resize(3);
    }
    for (int i=0; i<NKPOINTS; i++){
      dataup[i].resize(Nbands); datadn[i].resize(Nbands);
    }
    //Obtain the bands data and store them into dataup and datadn, respectively
    if(ISPIN==1){
      for(int ik=0; ik< NKPOINTS; ik++){
        getline(ss_engenval, stmp); //Negelecting empty line
        ss_engenval >> datakpoints[ik][0] >> datakpoints[ik][1] >> datakpoints[ik][2];  
        getline(ss_engenval, stmp); //Negelecting kpoint coordinate
        int ib=-1;  
        for(int i=0; i<Nbands; i++){
          ss_engenval>>ftmp>>ftmp;
          ib=ib+1;
          dataup[ik][ib]=ftmp;
        }
        getline(ss_engenval,stmp);
      }
    }
    else if(ISPIN==2){
      for(int ik=0; ik< NKPOINTS; ik++){
        getline(ss_engenval, stmp); //Negelecting empty line
        ss_engenval >> datakpoints[ik][0] >> datakpoints[ik][1] >> datakpoints[ik][2];  
        getline(ss_engenval, stmp); //Negelecting kpoint coordinate
        int ib=-1;  
        for(int i=0; i<Nbands; i++){
          ss_engenval>>ftmp>>ftmpup>>ftmpdn;
          ib=ib+1;
          dataup[ik][ib]=ftmpup;
          datadn[ik][ib]=ftmpdn;
        }
        getline(ss_engenval,stmp);
      }
    }
    else {
      cerr << "Can not detect spin flag! Error, Aborting!" << endl;
      return FALSE;
    }
    //READ KPOINTS  
    aflowlib::vaspfile2stringstream(directory, "KPOINTS", ss_kpoints);

    ss_kpoints >> LattName >> stmp; getline(ss_kpoints, stmp);
    ss_kpoints >> KPOINTSGRID >> stmp >> stmp >> stmp; getline(ss_kpoints, stmp);
    getline(ss_kpoints, stmp);
    getline(ss_kpoints, stmp);

    // Get special kpoints from KPOINTS.bands
    // Get Lables of KPOINTS from KPOINTS.bands
    vector<vector<double> > kpoints;  
    vector<string> kpointslabel,kpointslabel_html,kpointslabel_gnuplot,kpointslabel_latex; //CO20171025
    int count=0, j=0; //count is the number of rows of kpoints
    // cout << ss_kpoints.str() << endl;
    while(getline(ss_kpoints, line)){
      if(aurostd::CountWordsinString(line)>=3){
        vector<double> kpt_tmp;
        double a1, a2, a3;
        string a5;
        strline.clear();
        strline.str(line);
        strline >> a1 >> a2 >> a3 >> stmp >> a5;
        kpt_tmp.push_back(a1);
        kpt_tmp.push_back(a2);
        kpt_tmp.push_back(a3);
        kpoints.push_back(kpt_tmp);
        kpointslabel.push_back(a5);
        kpointslabel_html.push_back(a5); //CO20171025
        kpointslabel_gnuplot.push_back(a5); //CO20171025
        kpointslabel_latex.push_back(a5); //CO20171025
        j++;
      }
      count = j;
    }
    //*******************************Redefine the symbols of special kpoints
    for (int i=0; i< count; i++) {kpointslabel[i]=fixKPOINT_SPECIALONLY(kpointslabel[i]);}//fixKPOINT(kpointslabel[i]);  //CO20170831 - fix all at once
    for (int i=0; i< count; i++) {kpointslabel_html[i]=fixKPOINT_HTML(kpointslabel_html[i]);}//fixKPOINT(kpointslabel[i]);  //CO20170831 - fix all at once
    for (int i=0; i< count; i++) {kpointslabel_gnuplot[i]=fixKPOINT_SPECIALONLY(fixKPOINT_GNUPLOT(kpointslabel_gnuplot[i],true));}//fixKPOINT(kpointslabel[i]);  //CO20170831 - fix all at once
    for (int i=0; i< count; i++) {kpointslabel_latex[i]=fixKPOINT_SPECIALONLY(fixKPOINT_LATEX(kpointslabel_latex[i]));}//fixKPOINT(kpointslabel[i]);  //CO20170831 - fix all at once
    //[OBSOLETE]    if (kpointslabel[i].compare("\\Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]    if (kpointslabel[i].compare("Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]    if (kpointslabel[i].compare("\\Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]    if (kpointslabel[i].compare("Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]    if (kpointslabel[i].compare("\\Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]    if (kpointslabel[i].compare("Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //Combine the Labels of special kpoints 
    string newlabel;
    for (int i=1; i< (count-1); i=i+2){
      if (kpointslabel[i].compare(kpointslabel[i+1])!=0) {
        bool need_space=!aurostd::substring2bool(kpointslabel[i],"_"); //CO20170830 - if subscript, extra space looks ODD!
        //string newlabel = aurostd::attach(kpointslabel[i]+(need_space?" ":""),kpointslabel[i+1]);  //CO20170830 - italics and make space for first italics
        newlabel = aurostd::attach(kpointslabel[i],kpointslabel[i+1]);  //CO20170830 - italics and make space for first italics
        kpointslabel[i] = newlabel;
        kpointslabel[i+1] = newlabel;
        //CO20171025 START
        newlabel = aurostd::attach(kpointslabel_html[i]+(need_space?" ":""),kpointslabel_html[i+1]);  //CO20170830 - italics and make space for first italics
        kpointslabel_html[i] = newlabel;
        kpointslabel_html[i+1] = newlabel;
        newlabel = aurostd::attach(kpointslabel_gnuplot[i]+(need_space?" ":""),kpointslabel_gnuplot[i+1]);  //CO20170830 - italics and make space for first italics
        kpointslabel_gnuplot[i] = newlabel;
        kpointslabel_gnuplot[i+1] = newlabel;
        newlabel = aurostd::attach(kpointslabel_latex[i]+(need_space?" ":""),kpointslabel_latex[i+1]);  //CO20170830 - italics and make space for first italics
        kpointslabel_latex[i] = newlabel;
        kpointslabel_latex[i+1] = newlabel;
        //CO20171025 STOP
      }
    }
    //*******************************Redefine the symbols of special kpoints

    //Converting kpoints into Cartesian
    vector<vector<double> > kpcart;
    for (int i=0; i<count; i++){
      vector<double> kpcart_tmp;
      double c1=0, c2=0, c3=0;
      c1=kpoints[i][0]*b1[1]+kpoints[i][1]*b2[1]+kpoints[i][2]*b3[1];
      c2=kpoints[i][0]*b1[2]+kpoints[i][1]*b2[2]+kpoints[i][2]*b3[2];
      c3=kpoints[i][0]*b1[3]+kpoints[i][1]*b2[3]+kpoints[i][2]*b3[3];
      kpcart_tmp.push_back(c1);
      kpcart_tmp.push_back(c2);
      kpcart_tmp.push_back(c3);
      kpcart.push_back(kpcart_tmp);
    }

    //Check number of kpoints

    if ((count/2)*KPOINTSGRID!=NKPOINTS) {
      message << "Please check your KPOINTS.bands and EIGENVAL.bands. files! The number of kpoints are different!!!" << endl;
      message << "KPOINTSGRID=" << KPOINTSGRID << endl;
      message << "count=" << count << endl;
      message << "(count/2)*KPOINTSGRID=" << (count/2)*KPOINTSGRID << endl;
      message << "NKPOINTS=" << NKPOINTS << endl;
      throw aurostd::xerror(_AFLOW_FILE_NAME_,function_name,message,_VALUE_ERROR_);
    }

    //Calcuating klinedirect from the direct points
    vector<double> klinecart(NKPOINTS);     
    double koffset=0;
    double kx1, ky1, kz1, kx2, ky2, kz2, dkx, dky, dkz, dk;
    int ind=0;
    for (int i=0; i<count/2; i++){
      j=2*i;
      kx1=kpcart[j][0]; ky1=kpcart[j][1]; kz1=kpcart[j][2];
      kx2=kpcart[j+1][0]; ky2=kpcart[j+1][1]; kz2=kpcart[j+1][2];
      dkx = kx2-kx1;
      dky = ky2-ky1;
      dkz = kz2-kz1;
      dk= (sqrt(dkx*dkx + dky*dky +dkz*dkz))/(KPOINTSGRID-1);
      klinecart[ind]=koffset; ind++;
      for (int ii=1; ii<KPOINTSGRID; ii++){
        klinecart[ind]= koffset + ii*dk;
        ind++;
      }
      koffset = koffset + dk*(KPOINTSGRID-1);
    }

    //*******************************Redefine the symbols of special kpoints
    //[OBSOLETE]for (int i=0; i< count; i++){
    //[OBSOLETE]    if (kpointslabel[i].compare("\\Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]    if (kpointslabel[i].compare("Gamma")==0) kpointslabel[i]="G";
    //[OBSOLETE]    if (kpointslabel[i].compare("\\Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]    if (kpointslabel[i].compare("Sigma")==0) kpointslabel[i]="Sigm";
    //[OBSOLETE]    if (kpointslabel[i].compare("\\Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]    if (kpointslabel[i].compare("Sigma_1")==0) kpointslabel[i]="Sigm_1";
    //[OBSOLETE]}
    //[OBSOLETE]//Combine the Labels of special kpoints 
    //[OBSOLETE]for (int i=1; i< (count-1); i=i+2) {
    //[OBSOLETE]  if(kpointslabel[i].compare(kpointslabel[i+1])!=0) {
    //[OBSOLETE]    string newlabel = aurostd::attach(fixKPOINT(kpointslabel[i])+" ",fixKPOINT(kpointslabel[i+1]));  //CO20170830 - italics and make space for first italics
    //[OBSOLETE]    kpointslabel[i] = newlabel;
    //[OBSOLETE]    kpointslabel[i+1] = newlabel;
    //[OBSOLETE]  } else {
    //[OBSOLETE]    kpointslabel[i] = fixKPOINT(kpointslabel[i]); //CO20170830 - italics
    //[OBSOLETE]    kpointslabel[i+1] = fixKPOINT(kpointslabel[i+1]); //CO20170830 - italics
    //[OBSOLETE]  }
    //[OBSOLETE]}
    //*******************************Redefine the symbols of special kpoints

    //**************************************Redefine the cartesian coordinates of special kpoints****************************************
    vector<double>  SPKPOINTScart(count);
    vector<double>  SPKPOINTScart_LABEL(count);

    //Get the cartesian coordinates of the special kpoints and store them into SPKPOINTScart
    for (int i=0; i<count; i=i+2){
      SPKPOINTScart[i]=klinecart[(i/2)*(KPOINTSGRID)];
      SPKPOINTScart[i+1]=klinecart[(i/2+1)*(KPOINTSGRID)-1];
    }
    //NO SHIFT - CO20170830
    for (int i=0; i< count; i=i+2) {SPKPOINTScart_LABEL[i]=SPKPOINTScart[i];}
    SPKPOINTScart_LABEL[count-1]=SPKPOINTScart[count-1];
    //Shifting the cartesian coordinates of special KPOINTS;
    //[OBSOLETE]for (int i=0; i< count; i=i+2){
    //[OBSOLETE]    if (kpointslabel[i].size()==1)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.006;
    //[OBSOLETE]    else if (kpointslabel[i].size()==3)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.018;
    //[OBSOLETE]    else if (kpointslabel[i].size()==5)  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i]-0.030;
    //[OBSOLETE]    else  SPKPOINTScart_LABEL[i]=SPKPOINTScart[i];
    //[OBSOLETE]}
    //[OBSOLETE]SPKPOINTScart_LABEL[count-1]=SPKPOINTScart[count-1]-0.006;
    //**************************************Redefine the cartesian coordinates of special kpoints****************************************

    //string bandsdatafile = ICSDName + "_BANDS.dat";
    // ofstream bandsfin;
    // bandsfin.open(bandsdatafile.c_str());
    // bandsfin.setf(ios_base::fixed,ios_base::floatfield);  //Formating output
    //bandsfin.precision(4);
    vector<vector<double> > bandsdata(NKPOINTS);
    if(wrapping_brackets){json << "{" << std::endl;} //CO20171025
    //Writing bands data into file
    if (ISPIN==1) { 
      for (int i=0; i<NKPOINTS; i++){
        bandsdata[i].resize(Nbands+1);
        bandsdata[i][0]=klinecart[i];
      }
      for (int i=0; i<NKPOINTS; i++)
        for (int ib=0; ib<Nbands; ib++) {
          bandsdata[i][ib+1]=dataup[i][ib]-Efermi;  //Zero point Shifts to Efermi
        }
      //json << "{" << endl;
      DOSDATA_JSON(vpflow,directory,json,false); //CO20171025
      json << "," << endl;
      json << "     \"title\": \"" << ICSDName << " (" << LattName << ")\"," << endl; //CO20171025
      json << "     \"n_kpoints\": " << NKPOINTS << "," << endl; //CO20171025
      json << "     \"n_bands\": " << Nbands << "," << endl; //CO20171025

      json << "     \"kpoint_labels\": ["; //CO20171025
      json << "\"" << kpointslabel[0] << "\"";
      for(int i=2;i<count;i=i+2) json << ",\"" <<  kpointslabel[i] << "\"";
      json << ",\"" << kpointslabel[count-1] << "\"";
      json << "]," << endl;

      //   json << "     \"kpoint_labels_html\": ["; //CO20171025
      //   if(kpointslabel[0]=="G") json << "\"&Gamma;\""; else if(kpointslabel[0]=="Sigm") json << "\"&Sigma;\""; else if(kpointslabel[0]=="Sigm_1") json << "\"&Sigma;<sub>1</sub>\""; else if(kpointslabel[0]=="Y_1") json << "\"Y<sub>1</sub>\""; else if(kpointslabel[0]=="Z_1") json << "\"Z<sub>1</sub>\""; else json << "\"" << kpointslabel[0] << "\"";
      //   for(int i=2;i<count;i=i+2) if(kpointslabel[i]=="G") json << ",\"&Gamma;\""; else if(kpointslabel[i]=="Sigm") json << ",\"&Sigma;\""; else if(kpointslabel[i]=="Sigm_1") json << ",\"&Sigma;<sub>1</sub>\""; else if(kpointslabel[i]=="Y_1") json << ",\"Y<sub>1</sub>\""; else if(kpointslabel[i]=="Z_1") json << ",\"Z<sub>1</sub>\""; else json << ",\"" << kpointslabel[i] << "\"";
      //   json << "]," << endl;

      json << "     \"kpoint_labels_latex\": ["; //CO20171025
      json << "\"" << kpointslabel_latex[0] << "\""; //CO20171025
      for(int i=2;i<count;i=i+2) json <<",\"" << kpointslabel_latex[i] <<"\""; //CO20171025
      json << ",\"" << kpointslabel_latex[count-1] << "\""; //CO20171025
      json << "]," << endl;

      //CO20171025 START
      json << "     \"kpoint_labels_gnuplot\": [";
      json << "\"" << kpointslabel_gnuplot[0] << "\"";
      for(int i=2;i<count;i=i+2) json <<",\"" << kpointslabel_gnuplot[i] <<"\"";
      json << ",\"" << kpointslabel_gnuplot[count-1] << "\"";
      json << "]," << endl;

      json << "     \"kpoint_labels_html\": [";
      json << "\"" << kpointslabel_html[0] << "\"";
      for(int i=2;i<count;i=i+2) json <<",\"" << kpointslabel_html[i] <<"\"";
      json << ",\"" << kpointslabel_html[count-1] << "\"";
      json << "]," << endl;

      json << "     \"kpoint_positions\": [";
      json <<  SPKPOINTScart[0];
      for(int i=2;i<count;i=i+2) json << "," <<  SPKPOINTScart[i];
      json << "," << SPKPOINTScart[count-1];
      json << "]," << endl;

      json << "     \"bands_data\": [";
      json << "[" << bandsdata[0][0];
      for(int i=1; i<Nbands+1;i++) json <<"," <<  bandsdata[0][i];
      json << "]," << endl;
      //CO20171025 STOP

      for (int ik=1;ik<NKPOINTS;ik++){
        json << "          [";
        for (int ib=0; ib<Nbands+1; ib++){
          if(ib!=0) json << "," <<  bandsdata[ik][ib];
          else json << bandsdata[ik][ib];
        }
        if(ik!=NKPOINTS-1) json << "]," << endl;
        else json << "]"  << endl;
      }
      json << "     ]"; //<< endl;
      //json << "}" << endl;
    }
    //Spin-polarized
    if (ISPIN==2) { 
      vector<vector<double> > bandsdata_dn(NKPOINTS);

      for (int i=0; i<NKPOINTS; i++){
        bandsdata[i].resize(Nbands+1);
        bandsdata_dn[i].resize(Nbands+1);
        bandsdata[i][0]=klinecart[i];
        bandsdata_dn[i][0]=klinecart[i];
      }
      for (int i=0; i<NKPOINTS; i++)
        for (int ib=0; ib<Nbands; ib++) {
          bandsdata[i][ib+1]=dataup[i][ib]-Efermi;  //Zero point Shifts to Efermi
          bandsdata_dn[i][ib+1]=datadn[i][ib]-Efermi;  //Zero point Shifts to Efermi
        }

      //json << "{" << endl;
      DOSDATA_JSON(vpflow,directory,json,false);  //CO20180216 - removed erroneous wrapping brackets
      json << "," << endl;
      json << "     \"title\": \"" << ICSDName << " (" << LattName << ")\"," << endl; //CO20171025
      json << "     \"n_kpoints\": " << NKPOINTS << "," << endl; //CO20171025
      json << "     \"n_bands\": " << Nbands << "," << endl; //CO20171025

      json << "     \"kpoint_labels\": ["; //CO20171025
      json << "\"" << kpointslabel[0] << "\"";
      for(int i=2;i<count;i=i+2) json << ",\"" <<  kpointslabel[i] << "\"";
      json << ",\"" << kpointslabel[count-1] << "\"";
      json << "]," << endl;

      json << "     \"kpoint_labels_latex\": ["; //CO20171025
      json << "\"" << kpointslabel_latex[0] << "\""; //CO20171025
      for(int i=2;i<count;i=i+2) json <<",\"" << kpointslabel_latex[i]<<"\""; //CO20171025
      json << ",\"" << kpointslabel_latex[count-1] << "\""; //CO20171025
      json << "]," << endl; //CO20171025

      json << "     \"kpoint_labels_gnuplot\": ["; //CO20171025
      json << "\"" << kpointslabel_gnuplot[0] << "\""; //CO20171025
      for(int i=2;i<count;i=i+2) json <<",\"" << kpointslabel_gnuplot[i]<<"\""; //CO20171025
      json << ",\"" << kpointslabel_gnuplot[count-1] << "\""; //CO20171025
      json << "]," << endl; //CO20171025

      json << "     \"kpoint_labels_html\": ["; //CO20171025
      json << "\"" << kpointslabel_html[0] << "\""; //CO20171025
      for(int i=2;i<count;i=i+2) json <<",\"" << kpointslabel_html[i]<<"\""; //CO20171025
      json << ",\"" << kpointslabel_html[count-1] << "\""; //CO20171025
      json << "]," << endl;

      json << "     \"kpoint_positions\": ["; //CO20171025
      json <<  SPKPOINTScart[0];
      for(int i=2;i<count;i=i+2) json << "," <<  SPKPOINTScart[i];
      json << "," << SPKPOINTScart[count-1];
      json << "]," << endl;

      json << "     \"bands_data_majority\": ["; //CO20171025
      json << "[" << bandsdata[0][0];
      for(int i=1; i<Nbands+1;i++) json <<"," <<  bandsdata[0][i];
      json << "]," << endl;

      for (int ik=1;ik<NKPOINTS;ik++){
        json << "          [";
        for (int ib=0; ib<Nbands+1; ib++){
          if(ib!=0) json << "," <<  bandsdata[ik][ib];
          else json << bandsdata[ik][ib];
        }
        if(ik!=NKPOINTS-1) json << "]," << endl;
        else json << "]"  << endl;
      }
      json << "     ]," << endl;

      json << "     \"bands_data_minority\": ["; //CO20171025
      json << "[" << bandsdata_dn[0][0];
      for(int i=1; i<Nbands+1;i++) json <<"," <<  bandsdata_dn[0][i];
      json << "]," << endl;

      for (int ik=1;ik<NKPOINTS;ik++){
        json << "          [";
        for (int ib=0; ib<Nbands+1; ib++){
          if(ib!=0) json << "," <<  bandsdata_dn[ik][ib];
          else json << bandsdata_dn[ik][ib];
        }
        if(ik!=NKPOINTS-1) json << "]," << endl;
        else json << "]"  << endl;
      }
      json << "     ]"; // << endl;
      //json << "}" << endl;
    }
    if(wrapping_brackets){json << std::endl << "}";} //CO20171025
    return TRUE;//tokens.size();
  }


  // Function converts labels to their HTML code.. Sorry for the ugly if-else-if chain.
  string linelabel2HTML(string linelabel){
    if(linelabel=="G"){
      return "&Gamma;";
    } else if(linelabel=="Sigm"){
      return "&Sigma;";
    } else if(linelabel=="Sigm_1"){
      return "&Sigma;<sub>1<\\/sub>";
    } else if(linelabel=="Y_1"){
      return "Y<sub>1<\\/sub>";
    } else if(linelabel=="Z_1"){
      return "Z<sub>1<\\/sub>";
    } else if(linelabel=="M_1"){
      return "M<sub>1<\\/sub>";
    } else if(linelabel=="H_1"){
      return "H<sub>1<\\/sub>";
    } else if(linelabel=="F_1"){
      return "F<sub>1<\\/sub>";
    } else if(linelabel=="A_1"){
      return "A<sub>1<\\/sub>";
    } else if(linelabel=="D_1"){
      return "D<sub>1<\\/sub>";
    } else if(linelabel=="P_1"){
      return "P<sub>1<\\/sub>";
    } else if(linelabel=="Q_1"){
      return "Q<sub>1<\\/sub>";
    } else if(linelabel=="I|I_1"){
      return "I<sub>1<\\/sub>|I";
    } else if(linelabel=="H_1|H"){
      return "H<sub>1<\\/sub>|H";
    } else if(linelabel=="X|X_1"){
      return "X<sub>1<\\/sub>|X";
    } else if(linelabel=="H_1|I"){
      return "H<sub>1<\\/sub>|I";
    } else if(linelabel=="F_1|F_2"){
      return "F<sub>1<\\/sub>|F<sub>2<\\/sub>";
    } else if(linelabel=="Y|Y_1"){
      return "Y|Y<sub>1<\\/sub>";
    } else if(linelabel=="W|L_1"){
      return "W|L<sub>1<\\/sub>";
    } else if(linelabel=="X_1|X"){
      return "X<sub>1<\\/sub>|X";
    } else if(linelabel=="C|C_1"){
      return "C|C<sub>1<\\/sub>";
    } else if(linelabel=="B_1|B"){
      return "B<sub>1<\\/sub>|B";
    } else {
      return linelabel;
    }    
  }

}//namespace estructure



#endif // _AFLOW_ESTRUCTURE_CPP_

// ***************************************************************************
// *                                                                         *
// *           Aflow STEFANO CURTAROLO - Duke University 2003-2021           *
// *                                                                         *
// ***************************************************************************
