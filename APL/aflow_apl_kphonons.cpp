// ***************************************************************************
// *                                                                         *
// *             STEFANO CURTAROLO - Duke University 2003-2021               *
// *                                                                         *
// ***************************************************************************

#include "../aflow.h"
#include "aflow_apl.h"

#define _ASTROPT_APL_OLD_ string("[AFLOW_PHONONS]") //CO20170601, ensure backwards compatibility (we ALWAYS support LEGACY)
#define _ASTROPT_APL_ string("[AFLOW_APL]") //CO20170601
#define _ASTROPT_QHA_ string("[AFLOW_QHA]") //CO20170601
#define _ASTROPT_AAPL_ string("[AFLOW_AAPL]") //CO20170601
//temporary directory for storing QHA files
#define _STROPT_ string("[VASP_FORCE_OPTION]") //ME20181226

#define APL_AFLOWIN_DEFAULT string("aflow_apl.in")  // ME20210901

static const string _ANHARMONIC_IFCS_FILE_[2] = {"anharmonicIFCs_3rd.xml", "anharmonicIFCs_4th.xml"};
static const int _NUM_RELAX_ = 2; //ME20181226
static const string _APL_RELAX_PREFIX_ = "relax_apl"; //ME20181226  //ME20190125
static const string _APL_ORIG_PREFIX_  = "_apl"; //AS20210302

namespace KBIN {
  //ME20181107 - Relax structure with PREC=PHONONS before running APL
  //ME20200102 - Make k-point grid commensurate with supercell size
  bool relaxStructureAPL_VASP(int start_relax,
      const string& AflowIn,
      aurostd::xoption& aplopts,  //ME20200102
      const xvector<int>& scell_dims,  //ME20200102
      bool relax_commensurate,
      _xvasp& xvasp,
      _aflags& aflags,
      _kflags& kflags,
      _vflags& vflags,
      ofstream& fileMessage,
      ostream& oss) {
    stringstream message;

    if (start_relax == _NUM_RELAX_) return true;  // Nothing to do here

    // Store original settings
    string prec = vflags.KBIN_VASP_FORCE_OPTION_PREC.xscheme;
    bool prec_entry = vflags.KBIN_VASP_FORCE_OPTION_PREC.isentry;
    aurostd::xoption kbin_vasp_run = vflags.KBIN_VASP_RUN;
    int nrelax = xvasp.NRELAX;

    // Change to RELAX
    vflags.KBIN_VASP_RUN.flag("RELAX", true);
    vflags.KBIN_VASP_RUN.flag("STATIC", false);
    vflags.KBIN_VASP_RUN.flag("RELAX_STATIC", false);
    vflags.KBIN_VASP_RUN.flag("RELAX_STATIC_BANDS", false);
    vflags.KBIN_VASP_RUN.flag("STATIC_BANDS", false);

    // Change to phonon settings
    string prec_phonons = xvasp.aplopts.getattachedscheme("AFLOWIN_FLAG::APL_PREC");
    vflags.KBIN_VASP_FORCE_OPTION_PREC.pop(prec);
    vflags.KBIN_VASP_FORCE_OPTION_PREC.push(prec_phonons);
    vflags.KBIN_VASP_FORCE_OPTION_PREC.isentry = true;

    //ME20200427
    bool Krun = true;
    if (relax_commensurate) {
      // Determine k-point grid that is commensurate with the grid of the supercell
      //ME20200102
      // Determine k-point grid that is commensurate with the k-point grid of
      // the supercell. APL automatically chooses the k-point grid for the
      // relaxation to be commensurate with the k-point grid for the supercell.
      // For example, if a 3x2x1 supercell uses a 2x2x3 k-point grid, the unit
      // cell will be relaxed using a 6x4x3 k-point grid. This minimizes the
      // risk of ghost forces in the supercell calculations.
      apl::Supercell scell(xvasp.str, fileMessage, aflags.Directory, oss);
      scell.build(scell_dims, false);
      string scheme_phonons = vflags.KBIN_VASP_KPOINTS_PHONONS_KSCHEME.content_string;
      int kppra_phonons = vflags.KBIN_VASP_KPOINTS_PHONONS_KPPRA.content_int;
      xvector<int> kpts_sc(3), kpts_pc(3);
      if (vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string.empty()) {
        int NK = (int) ((double) kppra_phonons/scell.getSupercellStructure().atoms.size() + 0.5);
        if (NK < 1) NK = 1;
        KPPRA(kpts_sc[1], kpts_sc[2], kpts_sc[3], scell.getSupercellStructure().lattice, NK);
      } else {
        vector<int> kpts;
        aurostd::string2tokens(vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string, kpts, " xX");
        kpts_sc = aurostd::vector2xvector(kpts);
      }
      for (int i = 1; i < 4; i++) kpts_pc[i] = scell_dims[i] * kpts_sc[i];
      message << "Relaxations will be performed on a " << aurostd::joinWDelimiter(kpts_pc, "x") << " k-point grid.";
      pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags.Directory, fileMessage, oss);

      // Create k-points file
      stringstream kpts_file;
      kpts_file << "k-points automatically generated by APL, supercell = " << aurostd::joinWDelimiter(scell_dims, "x") << ",";
      if (vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string.empty()) kpts_file << " kppra = " << kppra_phonons;
      kpts_file << " (k = " << aurostd::joinWDelimiter(kpts_sc, "x")  << ")" << std::endl;
      kpts_file << "0" << std::endl;
      kpts_file << scheme_phonons << std::endl;
      kpts_file << aurostd::joinWDelimiter(kpts_pc, " ") << std::endl;
      kpts_file << "0 0 0" << std::endl;

      // Store old settings and switch to k-points mode to explicit with new file
      aurostd::xoption kbin_vasp_kpoints_mode_back = vflags.KBIN_VASP_KPOINTS_MODE;
      aurostd::xoption kbin_vasp_kpoints_file_back = vflags.KBIN_VASP_KPOINTS_FILE;
      string kbin_vasp_kpoints_explicit_start_stop_back = vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP.str();
      vflags.KBIN_VASP_KPOINTS_MODE.clear();
      vflags.KBIN_VASP_KPOINTS_FILE.clear();
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP.str("");
      vflags.KBIN_VASP_KPOINTS_MODE.flag("EXPLICIT", true);
      vflags.KBIN_VASP_KPOINTS_MODE.flag("EXPLICIT_START_STOP", true);
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP << kpts_file.str();

      // Run relxations
      Krun = runRelaxationsAPL_VASP(start_relax, AflowIn, xvasp, aflags, kflags, vflags, fileMessage);

      // Consistency check: Redetermine the supercell dimensions and the k-point
      // grid for the supercell calculations with the relaxed structure. If they
      // do not agree, then the structure has changed too much and the relaxation
      // did not use an appropriate k-point grid.
      // The k-points scheme MUST be resolved pre-phonon-relaxation and made consistent
      // with the desired supercell dimensions, otherwise ghost-forces may appear.
      scell.clearSupercell();
      scell.initialize(xvasp.str);
      bool scell_verbose = aplopts.flag("SCELL::VERBOSE");
      aplopts.flag("SCELL::VERBOSE", false);
      xvector<int> scell_dims_new = scell.determineSupercellDimensions(aplopts);
      aplopts.flag("SCELL::VERBOSE", scell_verbose);
      if (scell_dims != scell_dims_new) {
        message << "Supercell dimensions of the input structure (" << aurostd::joinWDelimiter(scell_dims, "x") << ")"
          << " and the relaxed structure (" << aurostd::joinWDelimiter(scell_dims_new, "x") << ")"
          << " do not agree. This is likely due to different symmetries in these structures. Use"
          << " an input structure that is closer to the fully relaxed one, remove all"
          << " CONTCAR." << _APL_RELAX_PREFIX_ << "* files, and run APL again.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _RUNTIME_ERROR_);
      }
      // k-point grid comparison only relevant when KPPRA is used
      if (!vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string.empty()) {
        xvector<int> kpts_sc_new(3);
        scell.build(scell_dims_new, false);
        int NK = (int) ((double) kppra_phonons/scell.getSupercellStructure().atoms.size() + 0.5);
        if (NK < 1) NK = 1;
        KPPRA(kpts_sc_new[1], kpts_sc_new[2], kpts_sc_new[3], scell.getSupercellStructure().lattice, NK);
        if (kpts_sc != kpts_sc_new) {
          message << "k-point grids of the supercells of the input structure (" << aurostd::joinWDelimiter(kpts_sc, "x") << ")"
            << " and the relaxed structure (" << aurostd::joinWDelimiter(kpts_sc_new, "x") <<  ")"
            << " do not agree. This is likely due to different symmetries in these structures. Use"
            << " an input structure that is closer to the fully relaxed one, remove all"
            << " CONTCAR." << _APL_RELAX_PREFIX_ << "* files, and run APL again.";
          throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _RUNTIME_ERROR_);
        }
      }

      // Restore original settings
      vflags.KBIN_VASP_KPOINTS_MODE = kbin_vasp_kpoints_mode_back;
      vflags.KBIN_VASP_KPOINTS_FILE = kbin_vasp_kpoints_file_back;
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP.str("");
      vflags.KBIN_VASP_KPOINTS_EXPLICIT_START_STOP << kbin_vasp_kpoints_explicit_start_stop_back;
    } else {
      Krun = runRelaxationsAPL_VASP(start_relax, AflowIn, xvasp, aflags, kflags, vflags, fileMessage);
    }

    vflags.KBIN_VASP_FORCE_OPTION_PREC.pop(prec_phonons);
    vflags.KBIN_VASP_FORCE_OPTION_PREC.push(prec);
    vflags.KBIN_VASP_FORCE_OPTION_KPOINTS.isentry = prec_entry;
    xvasp.NRELAX = nrelax;
    vflags.KBIN_VASP_RUN = kbin_vasp_run;

    return Krun;
  }

  bool runRelaxationsAPL_VASP(int start_relax, const string& AflowIn, _xvasp& xvasp,
      _aflags& aflags, _kflags& kflags, _vflags& vflags, ofstream& fileMessage) {
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    ostringstream aus;

    bool Krun = VASP_Produce_and_Modify_INPUT(xvasp, AflowIn, fileMessage, aflags, kflags, vflags);
    Krun = (Krun && VASP_Write_INPUT(xvasp, vflags, _APL_ORIG_PREFIX_));

    //ME20200115 - set for SPIN_REMOVE_RELAX
    xvasp.NRELAX = _NUM_RELAX_;

    if (Krun) {
      int i;
      for (i = start_relax; Krun && i <= _NUM_RELAX_; i++) {
        aus << 11111*i << " RELAXATION APL - " << xvasp.Directory << " - K=[" << xvasp.str.kpoints_k1 << " " << xvasp.str.kpoints_k2 << " " << xvasp.str.kpoints_k3 << "]" << " - " << kflags.KBIN_BIN << " - " << Message(_AFLOW_FILE_NAME_) << endl;
        aurostd::PrintMessageStream(fileMessage, aus, XHOST.QUIET);
        if (i < _NUM_RELAX_) {
          Krun = VASP_Run(xvasp, aflags, kflags, vflags, _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i), _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i), true, fileMessage);
          XVASP_INCAR_SPIN_REMOVE_RELAX(xvasp, aflags, vflags, i, true, fileMessage); //CO20210315 - always write_incar
          XVASP_KPOINTS_IBZKPT_UPDATE(xvasp, aflags, vflags, i, true, fileMessage); //CO20210315 - always write_kpoints
        } else { 
          Krun = VASP_Run(xvasp, aflags, kflags, vflags, _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i), true, fileMessage);
          XVASP_INCAR_SPIN_REMOVE_RELAX(xvasp, aflags, vflags, i, false, fileMessage);  //ME20200115 - or else SPIN_REMOVE_RELAX_2 does not work  //CO20210315 - write_incar only if (i<num_relax), no static afterward
        }
      }
      if (Krun && (i == _NUM_RELAX_)) {
        aus << 11111*i << " RELAXATION APL END - " << xvasp.Directory << " - K=[" << xvasp.str.kpoints_k1 << " " << xvasp.str.kpoints_k2 << " " << xvasp.str.kpoints_k3 << "]" << " - " << kflags.KBIN_BIN << " - " << Message(_AFLOW_FILE_NAME_) << endl;
      }
    }
    if (!Krun) return false;

    // Update structure - do not set xvasp.str = str_fin or all other
    // information (species, PPs) will be deleted!
    stringstream xstr;
    string filename = aflags.Directory + "/CONTCAR." + _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(_NUM_RELAX_);  //ME20190308
    if (!aurostd::FileExist(filename)) return false;
    aurostd::file2stringstream(filename, xstr);
    xstructure str_fin(xstr, IOVASP_AUTO);
    // Restore species and PP information
    str_fin.species = xvasp.str.species; //ME20190109
    str_fin.species_pp = xvasp.str.species_pp; //ME20190109
    str_fin.species_pp_type = xvasp.str.species_pp_type; //ME20190109
    str_fin.species_pp_version = xvasp.str.species_pp_version; //ME20190109
    str_fin.species_pp_ZVAL = xvasp.str.species_pp_ZVAL; //ME20190109
    str_fin.species_pp_vLDAU = xvasp.str.species_pp_vLDAU; //ME20190109

    xvasp.str = str_fin; //ME20190109
    if(LDEBUG){std::cerr << xvasp.str << std::endl;} //ME20190308
    pflow::fixEmptyAtomNames(xvasp.str,true);  //ME20190308

    // Safeguard for when CONVERT is set in the aflow.in file
    // CONVERT_UNIT_CELL may shift the origin, so not doing it here
    // would lead to inconsistencies when between the supercell creation
    // and the APL/AAPL analysis
    //ME20200102 - should not be necessary anymore when the state is saved,
    // but it's good to convert it anyway to get "nicer" lattice vectors
    if (!vflags.KBIN_VASP_FORCE_OPTION_CONVERT_UNIT_CELL.flag("PRESERVE") &&
        !vflags.KBIN_VASP_FORCE_OPTION_CONVERT_UNIT_CELL.xscheme.empty()) { //ME20190109
      xvasp.str.Standard_Lattice_primitive = false;
      xvasp.str.Standard_Lattice_conventional = false;
      VASP_Convert_Unit_Cell(xvasp, vflags, aflags, fileMessage, aus);
    }

    return Krun;
  }

  void VASP_RunPhonons_APL(_xvasp& xvasp,
      string AflowIn,
      _aflags& aflags,
      _kflags& kflags,
      _vflags& vflags, ofstream& FileMESSAGE, ostream& oss) {
    _xinput xinput(xvasp);
    _xflags xflags(vflags);
    RunPhonons_APL(xinput,AflowIn,aflags,kflags,xflags,FileMESSAGE, oss);
  }

  void RunPhonons_APL(_xinput& xinput,
      string AflowIn,
      _aflags& aflags,
      _kflags& kflags,
      _xflags& xflags, 
      ofstream& FileMESSAGE,
      ostream& oss) {

    bool LDEBUG = (FALSE || XHOST.DEBUG);

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                               INITIALIZE                                //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    xinput.xvasp.AVASP_arun = true;
    stringstream message;

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [0]" << std::endl;
    // Test
    if (!(kflags.KBIN_PHONONS_CALCULATION_APL || kflags.KBIN_PHONONS_CALCULATION_QHA || kflags.KBIN_PHONONS_CALCULATION_AAPL)) return; //PN20180705

    //determine if we have a consistent mode defined between input and flags
    if(xinput.AFLOW_MODE_VASP){
      if(!xflags.AFLOW_MODE_VASP){
        cerr << "ERROR: KBIN::RunPhonons_APL: mismatch types between xinput(VASP) and xflags(!VASP)" << endl;
        return;
      }
    } else if(xinput.AFLOW_MODE_AIMS){
      if(!xflags.AFLOW_MODE_AIMS){
        cerr << "ERROR: KBIN::RunPhonons_APL: mismatch types between xinput(AIMS) and xflags(!AIMS)" << endl;
        return;
      }
    } //CO20200106 - patching for auto-indenting
    //else if(xinput.AFLOW_MODE_ALIEN){  //alien doesn't have xstr, so we ignore  //[CO20200106 - close bracket for indenting]}
    else {
      cerr << "ERROR: KBIN::RunPhonons_APL: unknown input type" << endl;
      return;
    }

    //CO
    //fix names if necessary, but do not remove pp info, we need mass!
    if(xinput.AFLOW_MODE_VASP){pflow::fixEmptyAtomNames(xinput.xvasp.str,true);}

    string _ASTROPT_ = ""; //CO20170601
    if (kflags.KBIN_PHONONS_CALCULATION_AAPL) {
      _ASTROPT_ = _ASTROPT_AAPL_;    //CO20170601
    } else if (kflags.KBIN_PHONONS_CALCULATION_QHA){
      _ASTROPT_ = _ASTROPT_QHA_;    //CO20170601
    } else {
      _ASTROPT_ = _ASTROPT_APL_;    //CO20170601
    }

    pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, "RUNNING...", aflags, FileMESSAGE, oss);

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                      READ PARAMETERS FROM AFLOWIN                       //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [1a]" << std::endl;

    //ME20181019 - Overwrite defaults for CHGCAR, WAVECAR, etc. Only write
    // these files if the user explicitly sets these flags. Otherwise, APL will
    // use too much disk space.
    if (xinput.AFLOW_MODE_VASP) {
      xflags.vflags.KBIN_VASP_FORCE_OPTION_BADER.options2entry(AflowIn,_STROPT_+"BADER=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_BADER",xflags.vflags.KBIN_VASP_FORCE_OPTION_BADER.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_BADER.isentry && DEFAULT_VASP_FORCE_OPTION_BADER) {
        message << "Switching OFF BADER for APL calculations (default: OFF)."; //CO20181226 - default OFF
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
      }

      xflags.vflags.KBIN_VASP_FORCE_OPTION_CHGCAR.options2entry(AflowIn,_STROPT_+"CHGCAR=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_CHGCAR",xflags.vflags.KBIN_VASP_FORCE_OPTION_CHGCAR.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_CHGCAR.isentry && DEFAULT_VASP_FORCE_OPTION_CHGCAR) {
        message << "Switching OFF CHGCAR for APL calculations (default: OFF).";  //CO20181226 - default OFF
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
      }

      xflags.vflags.KBIN_VASP_FORCE_OPTION_ELF.options2entry(AflowIn,_STROPT_+"ELF=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_ELF",xflags.vflags.KBIN_VASP_FORCE_OPTION_ELF.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_ELF.isentry && DEFAULT_VASP_FORCE_OPTION_ELF) {
        message << "Switching OFF ELF for APL calculations (default: OFF)."; //CO20181226 - default OFF
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
      }

      xflags.vflags.KBIN_VASP_FORCE_OPTION_WAVECAR.options2entry(AflowIn,_STROPT_+"WAVECAR=",false);
      xinput.xvasp.aopts.flag("FLAG::AVASP_WAVECAR",xflags.vflags.KBIN_VASP_FORCE_OPTION_WAVECAR.option);
      if (!xflags.vflags.KBIN_VASP_FORCE_OPTION_WAVECAR.isentry && DEFAULT_VASP_FORCE_OPTION_WAVECAR) {
        message << "Switching OFF WAVECAR for APL calculations (default: OFF).";  //CO20181226 - default OFF
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
      }
    }

    //ME20200427 - added grid option. It has priority, so check that the formatting is correct.
    if (xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.isentry) {
      vector<int> kpts;
      aurostd::string2tokens(xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_GRID.content_string, kpts, " xX");
      if (kpts.size() != 3) {
        message << "Incorrect format for KPOINTS_GRID";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_ILLEGAL_);
      }
    }

    // Make sure that the formatting for the k-point shift is correct
    if (xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_SHIFT.isentry) {
      vector<int> kpts;
      aurostd::string2tokens(xflags.vflags.KBIN_VASP_KPOINTS_PHONONS_SHIFT.content_string, kpts, " ,;");
      if (kpts.size() != 3) {
        message << "Incorrect format for KPOINTS_SHIFT";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_ILLEGAL_);
      }
    }

    // APL ----------------------------------------------------------------------

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [1b]" << std::endl;

    /***************************** READ PARAMETERS *****************************/

    aurostd::xoption aplopts;
    int USER_MAXSHELL = 0;  // Not implemented yet
    for (uint i = 0; i < kflags.KBIN_MODULE_OPTIONS.aplflags.size(); i++) {
      const string& key = kflags.KBIN_MODULE_OPTIONS.aplflags[i].keyword;
      message << (kflags.KBIN_MODULE_OPTIONS.aplflags[i].isentry? "Setting" : "DEFAULT") << " " << _ASTROPT_ << key << "=" << kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme;
      pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
      aplopts.flag(key, kflags.KBIN_MODULE_OPTIONS.aplflags[i].option);
      aplopts.flag(key + "_ENTRY", kflags.KBIN_MODULE_OPTIONS.aplflags[i].isentry); // ME20210505
      aplopts.push_attached(key, kflags.KBIN_MODULE_OPTIONS.aplflags[i].xscheme);
    }

    /***************************** CHECK PARAMETERS *****************************/

    apl::validateParametersAPL(aplopts, aflags, FileMESSAGE, oss);
    aplopts.flag("SUPERCELL::VERBOSE", true);  // Use verbose output for supercell construction

    // Process some APL strings
    // Relax structure
    int START_RELAX = 0;
    if (aplopts.flag("RELAX")) {
      START_RELAX = 1;
      if(xinput.AFLOW_MODE_VASP){
        // Check if the structure has already been relaxed
        for (int i = 1; i <= _NUM_RELAX_; i++) {
          string contcar = aflags.Directory + "/CONTCAR." + _APL_RELAX_PREFIX_ + aurostd::utype2string<int>(i);
          if (aurostd::EFileExist(contcar) || aurostd::FileExist(contcar)) {  //ME20200103 - also look for uncompressed files
            START_RELAX++;
          } else {
            break;
          }
        }
        if (START_RELAX == _NUM_RELAX_ + 1) {
          message << "Structure has already been relaxed. Relaxation will be skipped.";
          aplopts.flag("RELAX", false);
        } else if (START_RELAX != 1) {
          message << "APL has already performed " << (START_RELAX + 1) << " relaxations.";
          message << " Number of relaxations remaining: " << (_NUM_RELAX_ - START_RELAX + 1) << ".";
        }
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
      } else {
        aplopts.flag("RELAX", false);
        message << "RELAX option only supported for VASP. Relaxations will be skipped.";
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
      }
    }

    // DOS
    vector<string> tokens;
    vector<int> USER_DOS_MESH;
    vector<xvector<double> > USER_DOS_PROJECTIONS;
    if (aplopts.flag("DOS") || aplopts.flag("TP")) {  //ME20190423
      aurostd::string2tokens(aplopts.getattachedscheme("DOSMESH"), USER_DOS_MESH, " xX");
      // ME20190625 - projected DOS
      // ME20200213 - now has fully atom projected DOS (use zero vector to indicate)
      if (aplopts.flag("DOS_PROJECT")) {
        if (aplopts.flag("DOS_CART") || aplopts.flag("DOS_FRAC")) {
          string projscheme = "";
          if (aplopts.flag("DOS_CART")) projscheme = aplopts.getattachedscheme("DOSPROJECTIONS_CART");
          else projscheme = aplopts.getattachedscheme("DOSPROJECTIONS_FRAC");
          aurostd::string2tokens(projscheme, tokens, "; ");
          vector<double> proj;
          for (uint i = 0; i < tokens.size(); i++) {
            aurostd::string2tokens(tokens[i], proj, ", ");
            USER_DOS_PROJECTIONS.push_back(aurostd::vector2xvector<double>(proj));
          }
        } else {
          xvector<double> proj(3);
          USER_DOS_PROJECTIONS.push_back(proj);
        }
      }
    }

    /****************************** OUTPUT SUMMARY ******************************/

    message << "Parameters for the Automatic Phonon Library successfully read." << std::endl;
    message << "The structure will " << (aplopts.flag("RELAX")?"":"NOT ") << "be relaxed before running APL." << std::endl;
    message << "The hibernate feature is switched " << (aplopts.flag("HIBERNATE")?"ON":"OFF") << "." << std::endl;
    message << "Phonons will be calculated using the " << (aplopts.getattachedscheme("ENGINE")=="DM"?"Direct":"Linear Response") << " Method." << std::endl;

    if (aplopts.getattachedscheme("ENGINE") == "DM") {
      message << "The distortion magnitude will be " << aplopts.getattachedscheme("DMAG") << " Angstrom." << std::endl;
      if (aplopts.flag("DXYZONLY")) {
        message << "Only distortions along the lattice vectors will be used." << std::endl;
      } else {
        message << "Atoms will be distorted along the lattice vectors, face diagonals, and body diagonals." << std::endl;
      }
      if (aplopts.flag("DSYMMETRIZE")) {
        message << "Non-symmetric distortion directions will be determined for each site." << std::endl;
      } else {
        message << "Distortions will be generated in three independent directions." << std::endl;
      }
      if (aplopts.flag("DSYMMETRIZE")) { //CO20190131
        message << "Distortion directions will be determined for inequivalent sites only." << std::endl;
      } else {
        message << "Distortion directions will be determined for ALL sites." << std::endl;
      }
      // Output now so that the warning about positive directions are can be displayed properly
      pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
      if (aurostd::toupper(aplopts.getattachedscheme("DPM"))[0] == 'A') {
        message << "Positive/negative distortion directions will be determined for each site."; 
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
      } else if (aplopts.flag("DPM")) {
        message << "Distortions will be generated in both the positive and negative direction.";
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
      } else {
        message << "Distortions will only be generated in the positive direction - this is NOT recommended.";
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
      }
      message << "Forces from the undistored state will " << (aplopts.flag("ZEROSTATE")?"":"NOT ") << "be used." << std::endl;
    }

    message << "Polar corrections will " << (aplopts.flag("POLAR")?"":"NOT ") << "be employed." << std::endl;
    message << "Frequencies will be returned in this format: " << aplopts.getattachedscheme("FREQFORMAT") << "." << std::endl;

    message << "The supercell will be built using ";
    if (aplopts.flag("SUPERCELL")) {
      message << "the dimensions " << aplopts.getattachedscheme("SUPERCELL::VALUE") << "." << std::endl;
    } else if (aplopts.flag("MINATOMS") || aplopts.flag("MINATOMS_UNIFORM")) {
      message << "at least " << aplopts.getattachedscheme("SUPERCELL::VALUE") << " atoms." << std::endl;
    } else if (aplopts.flag("MINSHELLS")) {
      message << "at least " << aplopts.getattachedscheme("SUPERCELL:VALUE") << " shells." << std::endl;
    }

    if (aplopts.flag("DC")) {
      message << "Phonon dispersion curves will be calculated ";
      if (aplopts.getattachedscheme("DCPATH") == "LATTICE") {
        message << "using the default path of the lattice (see DOI 10.1016/j.commatsci.2010.05.010). ";
      } else {
        string dc_initcoords_frac = aplopts.getattachedscheme("DCINITCOORDSFRAC");
        string dc_initcoords_cart = aplopts.getattachedscheme("DCINITCOORDSCART");
        message << "along the " << (aplopts.flag("DC_CART")?"Cartesian":"fractional") << " coordinates ";
        message << "[" << (aplopts.flag("DC_CART")?aplopts.getattachedscheme("DCINITCOORDSCART"):aplopts.getattachedscheme("DCINITCOORDSFRAC")) << "].";
      }
      message << " Each subpath will be divided into " << aplopts.getattachedscheme("DCPOINTS") << " points." << std::endl;
    } else {
      message << "Phonon dispersion curves will NOT be calculated." << std::endl;
    }

    if (aplopts.flag("DOS") || aplopts.flag("TP")) {  //ME20190423
      string dosmethod = aplopts.getattachedscheme("DOSMETHOD");
      message << "Phonon DOS will be calculated using the ";
      message << (dosmethod == "LT"?"Linear Tetrahedron":"Root Sampling") << " method ";
      message << "along a " << aplopts.getattachedscheme("DOSMESH");
      message << " mesh with " << aplopts.getattachedscheme("DOSPOINTS") << " bins.";
      if (dosmethod == "RS")
        message << " A smearing value of " << aplopts.getattachedscheme("DOSSMEAR") << " eV will be used.";
      //ME20190626 - projected DOS
      if ((USER_DOS_PROJECTIONS.size() == 0) || (dosmethod == "RS")) {
        message << " Projected phonon DOS will NOT be calculated.";
      } else {
        message << " Projected phonon DOS will be calculated along the "
          << (aplopts.flag("DOS_CART")?"fractional":"Cartesian") << " directions ";
        for (uint i = 0; i < USER_DOS_PROJECTIONS.size(); i++) {
          message << "[" << aurostd::joinWDelimiter(aurostd::vecDouble2vecString(aurostd::xvector2vector<double>(USER_DOS_PROJECTIONS[i])), ", ") << "]";
          message << ((i < USER_DOS_PROJECTIONS.size() - 1)?", ":".");
        }
      }
      message << std::endl;
    } else {
      message << "Phonon DOS will NOT be calculated." << std::endl;
    }

    if (aplopts.flag("TP")) {
      message << "Thermodynamic properties will be calculated between ";
      message << aplopts.getattachedscheme("TSTART") << " K and " << aplopts.getattachedscheme("TEND") << " K ";
      message << "in " << aplopts.getattachedscheme("TSTEP") << " K steps." << std::endl;
    } else {
      message << "Thermodynamic properties will NOT be calculated." << std::endl;
    }
    pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
    //ME20181026 END

    // AAPL ----------------------------------------------------------------------

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [1c]" << std::endl;

    //ME20181027 START

    /***************************** READ PARAMETERS *****************************/

    aurostd::xoption aaplopts;
    if (kflags.KBIN_PHONONS_CALCULATION_AAPL) {
      for (uint i = 0; i < kflags.KBIN_MODULE_OPTIONS.aaplflags.size(); i++) {
        const string& key = kflags.KBIN_MODULE_OPTIONS.aaplflags[i].keyword;
        message << (kflags.KBIN_MODULE_OPTIONS.aaplflags[i].isentry? "Setting" : "DEFAULT") << " " << _ASTROPT_ << key << "=" << kflags.KBIN_MODULE_OPTIONS.aaplflags[i].xscheme;
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
        aaplopts.flag(key, kflags.KBIN_MODULE_OPTIONS.aaplflags[i].option);
        aaplopts.push_attached(key, kflags.KBIN_MODULE_OPTIONS.aaplflags[i].xscheme);
      }
      apl::validateParametersAAPL(aaplopts, aflags, FileMESSAGE, oss);
      // Additional parameters from APL
      aaplopts.push_attached("DMAG", aplopts.getattachedscheme("DMAG"));
      aaplopts.flag("ZEROSTATE", aplopts.flag("ZEROSTATE"));
      vector<string> tokens;

      /****************************** OUTPUT SUMMARY ******************************/

      message << "Parameters for the Automatic Anharmonic Phonon Library successfully read." << std::endl;
      message << "Four-phonon processes will " << (aaplopts.flag("FOURTH_ORDER")?"":"NOT ") << "be included in the calculations.";

      bool defaults = (!aaplopts.flag("CUT_RAD") && !aaplopts.flag("CUT_SHELL"));
      if (defaults || aaplopts.flag("CUT_RAD")) {
        aurostd::string2tokens(aaplopts.getattachedscheme("CUT_RAD"), tokens, ",");
        message << "The cutoff to compute the 3rd order anharmonic IFCs will be ";
        message << tokens[0] << " Angstrom." << std::endl;
        if (aaplopts.flag("FOUTH_ORDER")) {
          message << "The cutoff to compute the 4th order anharmonic IFCs will be ";
          message << tokens[1] << " Angstrom." << std::endl;
        }
      }
      if (defaults || aaplopts.flag("CUT_RAD")) {
        aurostd::string2tokens(aaplopts.getattachedscheme("CUT_SHELL"), tokens, ",");
        message << "The calculation of 3rd order anharmonic IFCs will consider up to ";
        message << tokens[0] << " coordination shells." << std::endl;
        if (aaplopts.flag("FOURTH_ORDER")) {
          message << "The calculation of 4th order anharmonic IFCs will consider up to ";
          message << tokens[1] << " coordination shells." << std::endl;
        }
      }

      if (aaplopts.flag("KPPRA")) message << "AAPL will use a KPPRA of " << aaplopts.getattachedscheme("KPPRA") << " for static calculations." << std::endl;

      message << "Anharmonic IFCs will be calculated with a convergence criterion of " << aaplopts.getattachedscheme("SUMRULE") << "." << std::endl;
      message << "A mixing coefficient of " << aaplopts.getattachedscheme("MIXING_COEFFICIENT")<< " will be used." << std::endl;
      message << "Anharmonic IFCs need to be converged within " << aaplopts.getattachedscheme("SUMRULE_MAX_ITER") << " iterations." << std::endl;

      message << "Thermal conductivity will be calculated between ";
      message << aaplopts.getattachedscheme("TSTART") << " K";
      message << " and " << aaplopts.getattachedscheme("TEND") << "K";
      message << " in " << aaplopts.getattachedscheme("TSTEP") << " K steps." << std::endl;

      message << "The Boltzmann Transport Equation will be solved using ";
      if (aaplopts.getattachedscheme("BTE") == "RTA") {
        message << "the Relaxation Time Approximation Approximation (RTA)." << std::endl;
      } else {
        message << "an iterative scheme." << std::endl;
      }
      message << "The equation will be solved using the tetrahedron method along a ";
      message << aaplopts.getattachedscheme("THERMALGRID") << " q-point mesh." << std::endl;
      message << "Isotope effects will " << (aaplopts.flag("ISOTOPE")?"":"NOT ") << "be included." << std::endl;
      if (aaplopts.flag("BOUNDARY") || aaplopts.flag("CUMULATIVEK")) {
        message << "Boundary effects will be included via ";
        if (aaplopts.flag("BOUNDARY")) {
          message << "boundary scattering with a grain size of ";
        } else {
          message << "cumulative thermal conductivity and a mean free path of at most ";
        }
        message << aaplopts.getattachedscheme("NANO_SIZE") << " nm." << std::endl;
      } else {
        message << "Boundary effects will NOT be included." << std::endl;
      }
    } else {
      message << "Anharmonic force constants and thermal conductivity will NOT be calculated.";
    }
    pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
    //ME20181027 STOP

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [1c]" << std::endl;

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                          PREPARE CALCULATIONS                           //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [2]" << std::endl;

    //fix vasp bin for LR or DM+POLAR
    if (aplopts.getattachedscheme("ENGINE") == "LR" || (aplopts.getattachedscheme("ENGINE") == string("DM") && aplopts.flag("POLAR"))) {
      if(xflags.AFLOW_MODE_VASP && !XHOST.GENERATE_AFLOWIN_ONLY){  //ME20190313 - Do not check the VASP binary for generate_aflowin_only
        try {
          // Check the version of VASP binary
          message << "Checking VASP version for linear response calculations.";
          //[CO20210315 - new style]string vaspVersion;
          //[CO20210315 - new style]vaspVersion = getVASPVersionNumber( (kflags.KBIN_MPI ? kflags.KBIN_MPI_BIN : kflags.KBIN_BIN ) );
          double vaspVersion=KBIN::getVASPVersionDouble( (kflags.KBIN_MPI ? kflags.KBIN_MPI_BIN : kflags.KBIN_BIN ) );  //CO20210315
          //[CO20210315 - new style]if (!vaspVersion.empty())
          if (aurostd::isequal(vaspVersion,0.0)==false){  //CO20210315
            //[CO20210315 - new style]message << "[" << vaspVersion[0] << "]."; //CO20210315
            //[CO20210315 - new style]if ((vaspVersion[0] - '0') < 5) //cool way of getting ascii value:  https://stackoverflow.com/questions/36310181/char-subtraction-in-c
            message << "[" << vaspVersion << "]."; //CO20210315
            if (vaspVersion < 5) {  //CO20210315
              pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
              //ME20190107 - fix both serial and MPI binaries
              kflags.KBIN_SERIAL_BIN = DEFAULT_VASP5_BIN;
              kflags.KBIN_MPI_BIN = DEFAULT_VASP5_MPI_BIN;
              if (kflags.KBIN_MPI) {
                kflags.KBIN_BIN = kflags.KBIN_MPI_BIN;
              } else {
                kflags.KBIN_BIN = kflags.KBIN_SERIAL_BIN;
              }
              message << "Modifying VASP bin to " << kflags.KBIN_BIN << " (AUTO modification).";  //ME20190109
              pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
            } else {
              message << " OK.";
              pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
            }
          } else {
            message << "Failed.";
            pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
            throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, "Unexpected binary format.", _FILE_WRONG_FORMAT_);
          }
        } catch (aurostd::xerror& excpt) {
          message << "Failed to identify the version of the VASP binary." << std::endl;
          message << excpt.buildMessageString() << std::endl;
          pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
        }
      }
    }

    //ME20200102 BEGIN
    // The PHPOSCAR file now also serves as the canonical structure
    // for the phonon calculations. This prevents any changes in symmetry codes,
    // especially the structure conversion codes, from changing the structure
    // between AFLOW versions.
    string phposcar_file = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_APL_PHPOSCAR_FILE);
    if (aurostd::EFileExist(phposcar_file)) {
      message << "Reading structure from file " << phposcar_file << ".";
      pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
      xinput.getXStr() = xstructure(phposcar_file, IOVASP_POSCAR);
    }

    // Set up the phonon calculator
    apl::PhononCalculator phcalc(FileMESSAGE, oss);
    if (xflags.vflags.AFLOW_SYSTEM.content_string.empty()) {
      phcalc._system = xinput.getXStr().title;
    } else {
      phcalc._system = xflags.vflags.AFLOW_SYSTEM.content_string;
    }
    phcalc.setDirectory(aflags.Directory);
    phcalc.setNCPUs(kflags);
    phcalc.setPolarMaterial(aplopts.flag("POLAR"));
    phcalc.initialize_supercell(xinput.getXStr());
    apl::Supercell& supercell = phcalc.getSupercell();

    // Determine the supercell dimensions
    xvector<int> scell_dims = supercell.determineSupercellDimensions(aplopts);

    // Don't relax when we already have a PHPOSCAR file (state saved)
    if (!aurostd::EFileExist(phposcar_file) && aplopts.flag("RELAX")) {
      //ME20190107 - Relax after fixing the vasp bin to make version consistent.
      // Run relaxations if necessary
      bool Krun=true;
      string function;
      if (xinput.AFLOW_MODE_VASP) {
        Krun = relaxStructureAPL_VASP(START_RELAX, AflowIn, aplopts, scell_dims,
            aplopts.flag("RELAX_COMMENSURATE"), xinput.xvasp, aflags, kflags, xflags.vflags, FileMESSAGE);
      }
      if (!Krun) {
        message << "Relaxation calculations did not run successfully.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _RUNTIME_ERROR_);
      }

      // Reinitialize the supercell with the new structure
      supercell.initialize(xinput.getXStr());
    }

    // Build after relaxations are done
    supercell.build(scell_dims);
    if (USER_MAXSHELL > 0) supercell.setupShellRestrictions(USER_MAXSHELL);

    //ME20200427 - If NBANDS has been specified, store the number of supercells
    // to scale.
    if (xflags.vflags.KBIN_VASP_FORCE_OPTION_NBANDS_EQUAL.isentry) {
      int ncells = scell_dims[1] * scell_dims[2] * scell_dims[3];
      xinput.xvasp.aopts.push_attached("AFLOW_APL::NCELLS", aurostd::utype2string<int>(ncells));
    }

    // Write supercell input structure into PHPOSCAR to save state
    // unless it has been read before.
    if (!aurostd::EFileExist(phposcar_file)) {
      xstructure xstr = supercell.getInputStructureLight();
      xstr.is_vasp5_poscar_format = true;
      stringstream poscar;
      poscar << xstr;
      aurostd::stringstream2file(poscar, phposcar_file);
      if (!aurostd::FileExist(phposcar_file)) {
        message << "Cannot open output file " << phposcar_file << ".";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _FILE_ERROR_);
      }
    }
    //ME20200102 END

    // AS20201203 BEGIN OBSOLETE
    // //ME20190626 - Convert projection directions for DOS to Cartesian
    // if ((USER_DOS_PROJECTIONS.size() > 0) && aplopts.flag("DOS_FRAC")) {
    //   for (uint p = 0; p < USER_DOS_PROJECTIONS.size(); p++) {
    //     USER_DOS_PROJECTIONS[p] = xinput.getXStr().f2c * USER_DOS_PROJECTIONS[p];
    //   }
    // }
    // AS20201203 END OBSOLETE

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                           QHA                                           //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    //AS20200709 BEGIN
    // convert an array of xoptions to a single xoption using defaults for missing
    // properties
    //ME20210831 - Only validate and process if we have a QHA calculations
    if (kflags.KBIN_PHONONS_CALCULATION_QHA) {
      aurostd::xoption qhaopts;
      for (uint i = 0; i < kflags.KBIN_MODULE_OPTIONS.qhaflags.size(); i++) {
        const string& key = kflags.KBIN_MODULE_OPTIONS.qhaflags[i].keyword;
        message << (kflags.KBIN_MODULE_OPTIONS.qhaflags[i].isentry? "Setting" : "DEFAULT")
          << " " << _ASTROPT_ << key << "=" << kflags.KBIN_MODULE_OPTIONS.qhaflags[i].xscheme;
        pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
        qhaopts.flag(key, kflags.KBIN_MODULE_OPTIONS.qhaflags[i].option);
        qhaopts.push_attached(key, kflags.KBIN_MODULE_OPTIONS.qhaflags[i].xscheme);
      }

      apl::validateParametersQHA(qhaopts, aflags, FileMESSAGE, oss);
      //AS20200709 END

      //AS20200513 BEGIN
      apl::QHA qha(supercell.getInputStructureLight(), xinput,
          qhaopts, aplopts, FileMESSAGE, oss);

      qha.system_title = phcalc._system;
      qha.run(xflags, aflags, kflags);
      return;
    }
    //AS20200513 END

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                           CALCULATE PHONONS                             //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    // FORCE CONSTANTS ----------------------------------------------------------
    bool stagebreak = false;

    // Harmonic force constants
    string hibfile = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_HARMIFC_FILE);
    bool awakeHarmIFCs = (aplopts.flag("HIBERNATE") && aurostd::EFileExist(hibfile));
    bool apl_stagebreak = false;
    // Try to read first
    if (awakeHarmIFCs) {
      try {
        pflow::logger(_AFLOW_FILE_NAME_, "APL", "Awakening...", aflags, FileMESSAGE, oss);
        phcalc.awake();
      } catch (aurostd::xerror& e) {
        message << e.buildMessageString() << " Skipping awakening...";
        pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
        awakeHarmIFCs = false;
      }
    }

    // Reading failed - calculate
    if (!awakeHarmIFCs) {
      // Set up calculator
      apl::ForceConstantCalculator fccalc(supercell, aplopts, FileMESSAGE, oss);
      apl_stagebreak = fccalc.runVASPCalculations(xinput, aflags, kflags, xflags, AflowIn);
      fccalc.saveState(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_STATE_FILE);
      if (!apl_stagebreak) {
        apl_stagebreak = !(fccalc.run());
        if (!apl_stagebreak) {
          if (aplopts.flag("HIBERNATE")) fccalc.hibernate();
          phcalc.setHarmonicForceConstants(fccalc);
        }
      }
    }

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [3b]" << std::endl;

    stagebreak = (stagebreak || apl_stagebreak);

    // Anharmonic force constants
    bool aapl_stagebreak = false;
    if (kflags.KBIN_PHONONS_CALCULATION_AAPL) {
      int max_order = (aaplopts.flag("FOURTH_ORDER") ? 4 : 3);
      for (int o = 3; o <= max_order; o++) {
        // Try and load IFCs from file
        string ifcs_hib_file = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_AAPL_FILE_PREFIX + _ANHARMONIC_IFCS_FILE_[o-3]);
        bool awakeAnharmIFCs = (aplopts.flag("HIBERNATE") && aurostd::EFileExist(ifcs_hib_file));
        if (awakeAnharmIFCs) {
          try {
            message << "Reading anharmonic IFCs from " << ifcs_hib_file << ".";
            pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
            phcalc.readAnharmonicIFCs(ifcs_hib_file);
          } catch (aurostd::xerror& excpt) {
            message<< excpt.buildMessageString() + " Skipping awakening of ";
            if (o == 3) message << "3rd";
            else message << aurostd::utype2string<int>(o) + "th";
            message << excpt.buildMessageString() + " order anharmonic IFCs.";
            pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
            awakeAnharmIFCs = false;
          }
        }

        // Reading failed - calculate
        if (!awakeAnharmIFCs) {
          // Setup calculations
          apl::AnharmonicIFCs anharm(FileMESSAGE, oss);
          anharm.setDirectory(aflags.Directory);
          anharm.initialize(phcalc.getSupercell(), o, aaplopts);
          aapl_stagebreak = (anharm.runVASPCalculations(xinput, aflags, kflags, xflags) || aapl_stagebreak);
          // Calculate IFCs
          if (!aapl_stagebreak) {
            aapl_stagebreak = !(anharm.calculateForceConstants());
            if (!aapl_stagebreak) {
              if (aplopts.flag("HIBERNATE")) anharm.writeIFCsToFile(ifcs_hib_file);
              phcalc.setAnharmonicForceConstants(anharm);
            }
          }
        }
      }
    }
    //ME201901029 BEGIN
    stagebreak = (stagebreak || aapl_stagebreak);

    // At least one calculation has not finished - return
    if (stagebreak) {
      message << "Stopped. Waiting for required calculations...";  //CO20181226
      pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss, _LOGGER_NOTICE_);
      return;
    }

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                           PHONON PROPERTIES                             //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    stringstream apl_outfile; // ME20210927 - summary file

    // Get the format of frequency desired by user ///////////////////////

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [5a]" << std::endl;

    apl::IPCFreqFlags frequencyFormat = apl::NONE;

    string USER_FREQFORMAT = aurostd::toupper(aplopts.getattachedscheme("FREQFORMAT"));
    if (!USER_FREQFORMAT.empty()) {
      // Convert format to machine representation
      tokens.clear();
      aurostd::string2tokens(USER_FREQFORMAT, tokens, string(" |:;,"));
      for (uint i = 0; i < tokens.size(); i++) {
        if (tokens.at(i) == string("OMEGA")) {
          frequencyFormat |= apl::OMEGA;
          continue;
        }
        if (tokens.at(i) == string("HERTZ")) {
          frequencyFormat |= apl::HERTZ;
          continue;
        } else if (tokens.at(i) == string("THZ")) {
          frequencyFormat |= apl::THZ;
          continue;
        } else if (tokens.at(i) == string("CM-1") || tokens.at(i) == string("RECIPROCAL_CM")) {
          frequencyFormat |= apl::RECIPROCAL_CM;
          continue;
        } else if (tokens.at(i) == string("MEV")) {
          frequencyFormat |= apl::MEV;
          continue;
        }
        if (tokens.at(i) == string("ALLOW_NEGATIVE")) {
          frequencyFormat |= apl::ALLOW_NEGATIVE;
          continue;
        }
      }
      // Check if there was specified unit keyword...
      if (((frequencyFormat & ~apl::OMEGA) & ~apl::ALLOW_NEGATIVE) == apl::NONE)
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, "Ambiguous frequency format.", _INPUT_AMBIGUOUS_);
    } else {
      frequencyFormat = apl::THZ | apl::ALLOW_NEGATIVE;
    }

    // PHONON DISPERSIONS ---------------------------------------------------------

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [5b]" << std::endl;

    if (aplopts.flag("DC")) {
      apl::PhononDispersionCalculator pdisc(phcalc);

      // Init path according to the aflow's definition for elec. struc.
      //ME20181029 - Restructured
      if (aplopts.getattachedscheme("DCPATH") == "LATTICE") {
        if (!supercell.projectToPrimitive()) {  //ME20200117 - project to primitive
          message << "Could not map the AFLOW standard primitive cell to the supercell.";
          message << " Phonon dispersions will be calculated using the original structure instead.";
          pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
        }
        pdisc.initPathLattice("", aurostd::string2utype<int>(aplopts.getattachedscheme("DCPOINTS")));
      } else {
        pdisc.initPathCoords(aplopts.getattachedscheme("DCINITCOORDS"),
            aplopts.getattachedscheme("DCINITCOORDSLABELS"),
            aurostd::string2utype<int>(aplopts.getattachedscheme("DCPOINTS")), aplopts.flag("DCCORDS_CART"));
      }
      //ME20190501 Allow user to override path
      string USER_DC_USERPATH = aplopts.getattachedscheme("DCUSERPATH");
      if(!USER_DC_USERPATH.empty()){  // Set path
        pdisc.setPath(USER_DC_USERPATH);
      }

      // Calculate frequencies on path
      pdisc.calc(frequencyFormat);

      // Write results into PDIS file
      pdisc.writePDIS(aflags.Directory);
      pdisc.writePHEIGENVAL(aflags.Directory);  //ME20190614
      if (aplopts.getattachedscheme("DCPATH") == "LATTICE") supercell.projectToOriginal();  //ME20200117 - reset to original
    }

    // PHONON DOS AND THERMODYNAMIC PROPERTIES ----------------------------------------

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [5c]" << std::endl;

    if (aplopts.flag("DOS") || aplopts.flag("TP")) {
      // Calculate DOS
      if (!phcalc.getQMesh().initialized()) phcalc.initialize_qmesh(USER_DOS_MESH);
      apl::DOSCalculator dosc(phcalc, aplopts);//AS20201203 input parameters are passed via xoption
      dosc.calc(aurostd::string2utype<int>(aplopts.getattachedscheme("DOSPOINTS")), aurostd::string2utype<double>(aplopts.getattachedscheme("DOSSMEAR")));
      if (aplopts.flag("DOS")) {
        dosc.writePDOS(aflags.Directory);
        dosc.writePHDOSCAR(aflags.Directory);  //ME20190614
      }

      // Calculate thermal properties
      if (aplopts.flag("TP")) {
        //if (!dosc.hasImaginaryFrequencies()) //ME20200210 - Do not skip, just ignore contributions of imaginary frequencies and throw a warning
        apl::ThermalPropertiesCalculator tpc(dosc, FileMESSAGE, aflags.Directory, oss);  //ME20190423
        //ME20200108 - new ThermalPropertiesCalculator format
        double USER_TP_TSTART = aurostd::string2utype<double>(aplopts.getattachedscheme("TSTART"));
        double USER_TP_TEND = aurostd::string2utype<double>(aplopts.getattachedscheme("TEND"));
        double USER_TP_TSTEP = aurostd::string2utype<double>(aplopts.getattachedscheme("TSTEP"));
        tpc.calculateThermalProperties(USER_TP_TSTART, USER_TP_TEND, USER_TP_TSTEP);
        // ME20211019 - additional output formats
        string tpfile = aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_THERMO_FILE;
        tpc.writePropertiesToFile(tpfile, txt_ft);
        tpfile = aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_THERMO_JSON;
        tpc.writePropertiesToFile(tpfile, json_ft);
        tpc.addToAPLOut(apl_outfile);

        if (aplopts.flag("DISPLACEMENTS")) {
          apl::AtomicDisplacements ad(phcalc);
          ad.calculateMeanSquareDisplacements(USER_TP_TSTART, USER_TP_TEND, USER_TP_TSTEP);
          ad.writeMeanSquareDisplacementsToFile(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_MSQRDISP_FILE);
        }

        if (aplopts.flag("GROUP_VELOCITY")) {
          string gvelfile = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_GVEL_FILE);
          message << "Writing group velocities into file " << gvelfile << ".";
          pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);
          vector<vector<xvector<double> > > gvel = phcalc.calculateGroupVelocitiesOnMesh();
          phcalc.writeGroupVelocitiesToFile(gvelfile, gvel);
        }

        if (dosc.hasImaginaryFrequencies()) {  //ME20200210
          //ME20200210 - changed warning
          const vector<double>& freqs = dosc.getBins();
          const vector<double>& idos = dosc.getIDOS();
          uint i = 0;
          for (i = 0; i < freqs.size(); i++) {
            if (freqs[i] > -_FLOAT_TOL_) break;
          }
          if (i > 0) {
            double idos_percent = 100.0 * idos[i - 1]/idos.back();
            message << "There are imaginary frequencies in the phonon DOS, covering "
              << std::fixed << std::setprecision(1) << idos_percent << "\% of the integrated DOS. "
              << "These frequencies were omitted in the calculation of thermodynamic properties.";
            pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
          }
        }
      }
    }

    // ME20210927
    if (!apl_outfile.str().empty()) {
      string filename = aurostd::CleanFileName(aflags.Directory + "/" + DEFAULT_APL_FILE_PREFIX + DEFAULT_APL_OUT_FILE);
      aurostd::stringstream2file(apl_outfile, filename);
      if (!aurostd::FileExist(filename)) {
        string message = "Cannot open output file " + filename + ".";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _FILE_ERROR_);
      }
    }

    /////////////////////////////////////////////////////////////////////////////
    //                                                                         //
    //                         THERMAL CONDUCTIVITY                            //
    //                                                                         //
    /////////////////////////////////////////////////////////////////////////////

    if (LDEBUG) std::cerr << __AFLOW_FUNC__ << " DEBUG [6]" << std::endl;

    if (kflags.KBIN_PHONONS_CALCULATION_AAPL) {
      message << "Starting thermal conductivity calculations.";
      pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, aflags, FileMESSAGE, oss);

      apl::TCONDCalculator tcond(phcalc, aaplopts);
      tcond.calculateGrueneisenParameters();
      tcond.calculateThermalConductivity();
      tcond.writeOutputFiles(phcalc.getDirectory());
    }

  }
}  // namespace KBIN

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                                 VALIDATORS                               //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

namespace apl {

  void validateParametersAPL(aurostd::xoption& aplopts, const _aflags& aflags, ofstream& FileMESSAGE, ostream& oss) {
    string message;
    vector<string> tokens;
    string _ASTROPT_ = "[AFLOW_APL]";

    if (XHOST.GENERATE_AFLOWIN_ONLY && aplopts.flag("RELAX")) {
      aplopts.flag("RELAX", false);
      message = "RELAX will be switched OFF for generate_aflowin_only.";
      pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, FileMESSAGE, oss);
    }

    // Correct user engine
    string USER_ENGINE = aurostd::toupper(aplopts.getattachedscheme("ENGINE"));
    if (USER_ENGINE == "GSA") {
      message = "The Generalized Supercell Approach (GSA) is deprecated - replaced with the Direct Method (DM).";
      pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
      USER_ENGINE = "DM";
    }
    if ((USER_ENGINE != "DM") && (USER_ENGINE != "LR")) {
      message = "Wrong setting in " + _ASTROPT_ + "ENGINE. Use either DM or LR. ";
      message += " See README_AFLOW_APL.TXT for more information.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_ILLEGAL_);
    }
    aplopts.push_attached("ENGINE", USER_ENGINE);  // To make sure it's all caps

    validateParametersSupercellAPL(aplopts);

    if (aplopts.flag("DC")) {
      validateParametersDispersionsAPL(aplopts);
    }
    if (aplopts.flag("DOS") || aplopts.flag("TP")) {
      validateParametersDosAPL(aplopts, aflags, FileMESSAGE, oss);
    }
  }

  void validateParametersSupercellAPL(aurostd::xoption& aplopts) {
    string message = "";
    string _ASTROPT_ = "[AFLOW_APL]";
    // ME2021050 - isentry more reliable than option
    if (aplopts.flag("SUPERCELL_ENTRY")) {
      vector<int> tokens;
      string supercell_scheme = aplopts.getattachedscheme("SUPERCELL");
      aurostd::string2tokens(supercell_scheme, tokens, " xX,;");
      if (tokens.size() != 3 && tokens.size() != 9) {
        message = "Wrong setting in " + _ASTROPT_ + "SUPERCELL.";
        message += " See README_AFLOW_APL.TXT for the correct format.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_NUMBER_);
      }
      aplopts.push_attached("SUPERCELL::METHOD", "SUPERCELL");
      aplopts.push_attached("SUPERCELL::VALUE", supercell_scheme);
      aplopts.flag("MINATOMS", false);
      aplopts.flag("MINATOMS_UNIFORM", false);
      aplopts.flag("MINSHELL", false);
    } else if (aplopts.flag("MINATOMS_ENTRY") || aplopts.flag("MINATOMS_UNIFORM_ENTRY")) {
      if (aplopts.flag("MINATOMS_UNIFORM_ENTRY")) {
        aplopts.push_attached("SUPERCELL::METHOD", "MINATOMS_UNIFORM");
        aplopts.push_attached("SUPERCELL::VALUE", aplopts.getattachedscheme("MINATOMS_UNIFORM"));
        aplopts.flag("MINATOMS", false);
      } else {
        aplopts.push_attached("SUPERCELL::METHOD", "MINATOMS");
        aplopts.push_attached("SUPERCELL::VALUE", aplopts.getattachedscheme("MINATOMS"));
      }
      aplopts.flag("SUPERCELL", false);
      aplopts.flag("MINSHELL", false);
    } else if (aplopts.flag("MINSHELL_ENTRY")) {
      aplopts.push_attached("SUPERCELL::METHOD", "SHELLS");
      aplopts.push_attached("SUPERCELL::VALUE", aplopts.getattachedscheme("MINSHELL"));
      aplopts.flag("SUPERCELL", false);
      aplopts.flag("MINATOMS_UNIFORM", false);
      aplopts.flag("MINATOMS", false);
    } else { // Default: MINATOMS
      aplopts.push_attached("SUPERCELL::METHOD", "MINATOMS");
      aplopts.push_attached("SUPERCELL::VALUE", aplopts.getattachedscheme("MINATOMS"));
      aplopts.flag("SUPERCELL", false);
      aplopts.flag("MINATOMS_UNIFORM", false);
      aplopts.flag("MINSHELL", false);
    }
  }

  void validateParametersDispersionsAPL(aurostd::xoption& aplopts) {
    string message = "";
    vector<string> tokens;
    string scheme = "";
    string _ASTROPT_ = "[AFLOW_APL]";

    scheme = aurostd::toupper(aplopts.getattachedscheme("DCPATH"));
    if (scheme == "MANUAL") {
      string dc_initcoords_cart = aplopts.getattachedscheme("DCINITCOORDSCART");
      string dc_initcoords_frac = aplopts.getattachedscheme("DCINITCOORDSFRAC");
      if (dc_initcoords_cart.empty()) {
        aplopts.push_attached("DCINITCOORDS", dc_initcoords_frac);
        aurostd::string2tokens(dc_initcoords_frac, tokens, "  ;");
        aplopts.flag("DCCOORDS_FRAC", true);
        aplopts.flag("DCCOORDS_CART", false);
      } else {
        aplopts.push_attached("DCINITCOORDS", dc_initcoords_cart);
        aurostd::string2tokens(dc_initcoords_cart, tokens, "  ;");
        aplopts.flag("DCCOORDS_FRAC", false);
        aplopts.flag("DCCOORDS_CART", true);
      }
      uint ncoords = tokens.size();
      aurostd::string2tokens(aplopts.getattachedscheme("DCINITCOORDSLABELS"), tokens, " ,;");
      if (ncoords != tokens.size()) {
        message = "Mismatch between the number of points and the number of labels for the phonon dispersions.";
        message += " Check the parameters DCINITCOORDS" + string(dc_initcoords_frac.empty()?"CART":"FRAC") + " and DCINITCOORDSLABELS.";
        message += " See README_AFLOW_APL.TXT for more information.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_NUMBER_);
      }
    } else if (scheme != "LATTICE") {
      message = "Wrong setting in " + _ASTROPT_ + "DCPATH. Use either LATTICE or MANUAL.";
      message += " See README_AFLOW_APL.TXT for more information.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_ILLEGAL_);
    }
    aplopts.push_attached("DCPATH", scheme);  // to make sure it's all caps
  }

  void validateParametersDosAPL(aurostd::xoption& aplopts, const _aflags& aflags, ofstream& FileMESSAGE, ostream& oss) {
    string message = "";
    vector<string> tokens;
    string _ASTROPT_ = "[AFLOW_APL]";

    // DOS Method
    string dos_method = aurostd::toupper(aplopts.getattachedscheme("DOSMETHOD"));
    if ((dos_method != "LT") && (dos_method != "RS")) {
      message = "Wrong setting in " + _ASTROPT_ + "DOSMETHOD. Use either LT or RS.";
      message += " See README_AFLOW_APL.TXT for more information.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_ILLEGAL_);
    }
    aplopts.push_attached("DOSMETHOD", dos_method);  // To make sure the option is all caps
    double dos_smear = aurostd::string2utype<double>(aplopts.getattachedscheme("DOSSMEAR"));
    if ((dos_method == "RS") && (dos_smear < _ZERO_TOL_)) {
      message = "Smearing value for DOS not set or set to zero.";
      message += " APL will overwrite the smearing value to 0.05 eV.";
      pflow::logger(_AFLOW_FILE_NAME_, "APL", message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
      aplopts.push_attached("DOSSMEAR", "0.05");
    }

    // q-point mesh
    aurostd::string2tokens(aplopts.getattachedscheme("DOSMESH"), tokens, " xX");
    if (tokens.size() != 3) {
      message = "Wrong setting in " + _ASTROPT_ + "DOSMESH.";
      message += " See README_AFLOW_APL.TXT for the correct format.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_NUMBER_);
    }

    // DOS projections
    if (aplopts.flag("DOS_PROJECT")) {
      string dos_proj_cart = aplopts.getattachedscheme("DOSPROJECTIONS_CART");
      string dos_proj_frac = aplopts.getattachedscheme("DOSPROJECTIONS_FRAC");
      if (!dos_proj_frac.empty() || !dos_proj_cart.empty()) {
        if (!dos_proj_cart.empty() && !dos_proj_frac.empty()) {
          message = "Ambiguous input in APL DOS projections.";
          message += " Choose between DOSPROJECTIONS_CART and DOSPROJECTIONS_FRAC.";
          throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_AMBIGUOUS_);
        } else {
          string projscheme;
          if (!dos_proj_cart.empty()) {
            aplopts.flag("DOS_CART", true);
            aplopts.flag("DOS_FRAC", false);
            projscheme = dos_proj_cart;
          } else {
            aplopts.flag("DOS_CART", false);
            aplopts.flag("DOS_FRAC", true);
            projscheme = dos_proj_frac;
          }
          tokens.clear();
          aurostd::string2tokens(projscheme, tokens, "; ");
          for (uint i = 0; i < tokens.size(); i++) {
            vector<string> proj;
            aurostd::string2tokens(tokens[i], proj, ", ");
            if (proj.size() != 3) {
              message = "Wrong setting in DOSPROJECTIONS_";
              message += string(dos_proj_cart.empty()?"FRAC":"CART") + ".";
              message += " See README_AFLOW_APL.TXT for the correct format.";
              throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_NUMBER_);
            }
          }
        }
      }
    }

    // Thermal properties temperature
    if (aplopts.flag("TP")) {
      aurostd::string2tokens(aplopts.getattachedscheme("TPT"), tokens, " :");
      if (tokens.size() != 3) {
        message = "Wrong setting in " + _ASTROPT_ + "TPT.";
        message += " See README_AFLOW_APL.TXT for the correct format.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_NUMBER_);
      }
      double tstart = aurostd::string2utype<double>(tokens[0]);
      double tend = aurostd::string2utype<double>(tokens[1]);
      double tstep = aurostd::string2utype<double>(tokens[2]);
      if (tstart > tend) {
        message = "Start temperature is larger than end temperature.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _VALUE_ILLEGAL_);
      }
      if (tstep < _FLOAT_TOL_) {
        message = "Temperature step cannot be zero or negative.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _VALUE_ILLEGAL_);
      }
      aplopts.push_attached("TSTART", tokens[0]);
      aplopts.push_attached("TEND", tokens[1]);
      aplopts.push_attached("TSTEP", tokens[2]);
    }
  }

  // Checks that the AAPL parameters are valid and recasts them to be usable
  // by all AAPL classes.
  void validateParametersAAPL(xoption& aaplopts, const _aflags& aflags, ofstream& FileMESSAGE, ostream& oss) {
    string module = "AAPL";
    string scheme = "", message = "";
    vector<string> tokens;
    string _ASTROPT_ = "[AFLOW_AAPL]";

    // BTE
    scheme = aaplopts.getattachedscheme("BTE");
    if ((scheme != "RTA") && (scheme != "FULL")) {
      message = "Wrong setting in " + _ASTROPT_ + "BTE. Use either RTA or FULL.";
      message += " See README_AFLOW_APL.TXT for more information.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_ILLEGAL_);
    }

    // CUT_SHELL and CUT_RAD
    bool defaults = (!aaplopts.flag("CUT_SHELL") && !aaplopts.flag("CUT_RAD"));  // flag is false when isentry was false
    bool fourth_order = aaplopts.flag("FOURTH_ORDER");
    if (defaults || aaplopts.flag("CUT_RAD")) {
      aurostd::string2tokens(aaplopts.getattachedscheme("CUT_RAD"), tokens, " ,");
      if (tokens.size() < 1) {
        message = "Not enough entries in " + _ASTROPT_ + "CUT_RAD.";
        message += " See README_AFLOW_APL.TXT for more information.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_NUMBER_);
      } else if (tokens.size() > 2) {
        message = "Too many entries for " + _ASTROPT_ + "CUT_RAD. Excess entries will be ignored.";
        pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
      } 
      if (aaplopts.flag("FOURTH_ORDER")) {
        if (tokens.size() == 1) {
          message = "Only one entry found for the cutoff radius. 3rd and 4th order anharmonic IFCs will use the same value.";
          pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
          aaplopts.push_attached("CUT_RAD", tokens[0] + "," + tokens[0]);
        } else {
          aaplopts.push_attached("CUT_RAD", tokens[0] + "," + tokens[1]);
        }
      } else {
        aaplopts.push_attached("CUT_RAD", tokens[0]);
      }
    }
    if (defaults || aaplopts.flag("CUT_SHELL")) {
      aurostd::string2tokens(aaplopts.getattachedscheme("CUT_SHELL"), tokens, " ,");
      if (tokens.size() < 1) {
        message = "Not enough entries in " + _ASTROPT_ + "CUT_SHELL.";
        message += " See README_AFLOW_APL.TXT for more information.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_NUMBER_);
      } else if (tokens.size() > 2) {
        message = "Too many entries for " + _ASTROPT_ + "CUT_SHELL. Excess entries will be ignored.";
        pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
      } 
      if (aaplopts.flag("FOURTH_ORDER")) {
        if (tokens.size() == 1) {
          message = "Only one entry found for the cutoff shells. 3rd and 4th order anharmonic IFCs will use the same value.";
          pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
          aaplopts.push_attached("CUT_SHELL", tokens[0] + "," + tokens[0]);
        } else {
          aaplopts.push_attached("CUT_SHELL", tokens[0] + "," + tokens[1]);
        }
      } else {
        aaplopts.push_attached("CUT_SHELL", tokens[0]);
      }
    }
    // if only one parameter is set in the aflow.in file, unset the other
    if (aaplopts.flag("CUT_RAD") != aaplopts.flag("CUT_SHELL")) {
      if (!aaplopts.flag("CUT_RAD")) aaplopts.push_attached("CUT_RAD", (fourth_order?"0.0,0.0":"0.0"));
      if (!aaplopts.flag("CUT_SHELL")) aaplopts.push_attached("CUT_RAD", (fourth_order?"0,0":"0"));
    }

    // THERMALGRID
    scheme = aaplopts.getattachedscheme("THERMALGRID");
    aurostd::string2tokens(scheme, tokens, string(" xX"));
    if (tokens.size() != 3) {
      message = "Wrong setting in " + _ASTROPT_ + "THERMALGRID.";
      message += " See README_AFLOW_APL.TXT for the correct format.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_NUMBER_);
    }

    // TCT
    scheme = aaplopts.getattachedscheme("TCT");
    aurostd::string2tokens(scheme, tokens, string(" :"));
    if (tokens.size() == 3) {
      double USER_TCT_TSTART = aurostd::string2utype<double>(tokens[0]);
      double USER_TCT_TEND = aurostd::string2utype<double>(tokens[1]);
      double USER_TCT_TSTEP = aurostd::string2utype<double>(tokens[2]);
      if (USER_TCT_TSTEP < _ZERO_TOL_) {
        message = "Temperature step cannot be zero.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_ILLEGAL_);
      }
      if (USER_TCT_TSTART == 0) {
        message = "Thermal conductivity is infinite at 0 K and will be skipped.";
        pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, FileMESSAGE, oss);
        USER_TCT_TSTART += USER_TCT_TSTEP;
      }
      if (USER_TCT_TSTART > USER_TCT_TEND) {
        message = "Start temperature cannot be larger than final temperature.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_ILLEGAL_);
      }
      aaplopts.push_attached("TSTART", aurostd::utype2string<double>(USER_TCT_TSTART));
      aaplopts.push_attached("TEND", aurostd::utype2string<double>(USER_TCT_TEND));
      aaplopts.push_attached("TSTEP", aurostd::utype2string<double>(USER_TCT_TSTEP));
    } else {
      message = "Wrong setting in " + _ASTROPT_ + "TCT.";
      message += " See README_AFLOW_APL.TXT for the correct format.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INPUT_NUMBER_);
    }

    // BOUNDARY and CUMULATIVEK
    if (aaplopts.flag("BOUNDARY") && aaplopts.flag("CUMULATIVEK")) {
      aaplopts.flag("CUMULATIVEK", false);
      message = "Both boundary effects and cumulative thermal conductivity cannot be set at the same time.";
      message += " Cumulative thermal conductivity has been switched off.";
      pflow::logger(_AFLOW_FILE_NAME_, module, message, aflags, FileMESSAGE, oss, _LOGGER_WARNING_);
    }
  }

  //AS20200709 BEGIN
  /// Checks that the QHA parameters are valid and recasts them to be usable.
  void validateParametersQHA(xoption& qhaopts, const _aflags& aflags, ofstream& FileMESSAGE, ostream& oss)
  {
    vector<string> tokens;
    vector<double> dtokens;
    string option = "";

    pflow::logger(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, "Validating QHA parameters.", aflags,
        FileMESSAGE, oss, _LOGGER_MESSAGE_);

    // EOS_DISTORTION_RANGE
    option = "EOS_DISTORTION_RANGE";
    aurostd::string2tokens(qhaopts.getattachedscheme(option), dtokens, " :");
    if (dtokens.size() != 3) {
      string msg = "Wrong setting in  " + _ASTROPT_QHA_ + option + ".";
      msg += " The number of parameters is wrong.";
      msg += " Specify as " + option + "=" + AFLOWRC_DEFAULT_QHA_EOS_DISTORTION_RANGE;
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, msg, _INPUT_NUMBER_);
    }

    if (dtokens[1] < dtokens[0]){
      string msg = "Wrong setting in " + _ASTROPT_QHA_ + option + ".";
      msg += " The end of the range of given volumes is smaller than the beginning.";
      msg += " Specify as " + option + "=" + AFLOWRC_DEFAULT_QHA_EOS_DISTORTION_RANGE;
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, msg, _INPUT_NUMBER_);
    }

    // EOS_MODEL
    option = "EOS_MODEL";
    string MODEL = aurostd::toupper(qhaopts.getattachedscheme(option));
    aurostd::string2tokens(MODEL, tokens, ",");
    if ((tokens.size()<1) || (tokens.size() > 5)){
      string msg = "Wrong setting in " + _ASTROPT_QHA_ + option + ".";
      msg += " Either no model was given or the number of given models is too big.";
      msg += " Specify as "+option+"=SJ,BM2,BM3,BM4,M using each method once.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, msg, _INPUT_NUMBER_);
    }

    string token = "";
    // note: different models could be used "simultaneously"
    for (uint i=0; i<tokens.size(); i++){
      token = aurostd::toupper(tokens[i]);
      if (token == "SJ")  qhaopts.flag("EOS_MODEL:SJ",  true);
      if (token == "BM2") qhaopts.flag("EOS_MODEL:BM2", true);
      if (token == "BM3") qhaopts.flag("EOS_MODEL:BM3", true);
      if (token == "BM4") qhaopts.flag("EOS_MODEL:BM4", true);
      if (token == "M")   qhaopts.flag("EOS_MODEL:M",   true);
    }

    // GP_DISTORTION
    double gp_distortion = aurostd::string2utype<double>(qhaopts.getattachedscheme("GP_DISTORTION"));
    if (gp_distortion < _ZERO_TOL_){
      string msg = "Wrong setting in " + _ASTROPT_QHA_ + option + ".";
      msg += option + " should be a positive real number. ";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, msg, _INPUT_ILLEGAL_);
    }

    // MODE
    option = "MODE";
    string MODE = aurostd::toupper(qhaopts.getattachedscheme(option));
    aurostd::string2tokens(MODE, tokens, ",");
    if ((tokens.size()<1) || (tokens.size() > 4)){
      string msg = "Wrong setting in " + _ASTROPT_QHA_ + option + ".";
      msg += " Either no method was given or the number of given methods is too big.";
      msg += " Specify as "+option+"=QHA,QHA3P,SCQHA,QHANP using each method once.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, msg, _INPUT_NUMBER_);
    }

    // note: QHA, QHA3P and SCQHA could run "simultaneously"
    for (uint i=0; i<tokens.size(); i++){
      token = aurostd::toupper(tokens[i]);
      if (token == "QHA")   qhaopts.flag("MODE:QHA",   true);
      if (token == "QHA3P") qhaopts.flag("MODE:QHA3P", true);
      if (token == "SCQHA") qhaopts.flag("MODE:SCQHA", true);
      if (token == "QHANP") qhaopts.flag("MODE:QHANP", true);
    }

    // PDIS_T
    vector<int> itokens;
    option = "PDIS_T";
    aurostd::string2tokens(qhaopts.getattachedscheme(option), itokens, ",");
    if (!itokens.size()){
      string msg = "Wrong setting in " + _ASTROPT_QHA_ + option + ".";
      msg += " List of temperatures is not given.";
      msg += " Specify as " + option + AFLOWRC_DEFAULT_QHA_PDIS_T;
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, msg, _INPUT_NUMBER_);
    }

    for (uint i=0; i<itokens.size(); i++){
      if (itokens[i] < 0){
        string msg = "Wrong setting in " + _ASTROPT_QHA_ + option + ".";
        msg += " Negative temperature was given.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, msg, _INPUT_ILLEGAL_);
      }
    }

    // TAYLOR_EXPANSION_ORDER
    int TAYLOR_EXPANSION_ORDER = aurostd::string2utype<int>(qhaopts.getattachedscheme("TAYLOR_EXPANSION_ORDER"));
    if (TAYLOR_EXPANSION_ORDER <= 0){
      string msg = "Wrong setting in " + _ASTROPT_QHA_ + option + ".";
      msg += " Taylor expansion order parameter should be a positive integer.";
      msg += " Specify as " + option + "=";
      msg += aurostd::utype2string<int>(AFLOWRC_DEFAULT_QHA_TAYLOR_EXPANSION_ORDER);
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, msg, _INPUT_ILLEGAL_);
    }
  }
  //AS20200709 END
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                            INPUT FILE CREATORS                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

namespace apl {

  //createAflowInPhonons////////////////////////////////////////////////////////
  //ME20181022 - New method to create the aflow.in files. Uses the aflow.in
  // creator in aflow_avasp.cpp
  bool createAflowInPhonons(const _aflags& _aflowFlags, const _kflags& _kbinFlags, const _xflags& _xFlags, _xinput& xinp) {
    bool LDEBUG=(FALSE || XHOST.DEBUG);
    string soliloquy="apl::createAflowInPhonons():";
    bool write = false;
    if (xinp.AFLOW_MODE_VASP) {
      if(LDEBUG){
        std::cerr << soliloquy << " BEFORE xinp.xvasp.Directory=" << xinp.xvasp.Directory << std::endl;
        std::cerr << soliloquy << " BEFORE xinp.getDirectory()=" << xinp.getDirectory() << std::endl;
      }
      AVASP_populateXVASP(_aflowFlags, _kbinFlags, _xFlags.vflags, xinp.xvasp);
      if(LDEBUG){
        std::cerr << soliloquy << " AFTER xinp.xvasp.Directory=" << xinp.xvasp.Directory << std::endl;
        std::cerr << soliloquy << " AFTER xinp.getDirectory()=" << xinp.getDirectory() << std::endl;
      }
      xinp.setDirectory(xinp.xvasp.Directory);
      if (!filesExistPhonons(xinp)) {
        stringstream aflowin;
        write = true;
        AVASP_MakeSingleAFLOWIN(xinp.xvasp, aflowin, write);
      } else {
        write = false;
      }
    }
    return write;
  }

  //ME20181022 - Old method to create aflow.in files for AIMS
  void createAflowInPhononsAIMS(_aflags& _aflowFlags, _kflags& _kbinFlags, _xflags& _xFlags, string& _AflowIn, _xinput& xinp, ofstream& FileMESSAGE) {
    string message = "";
    if (!xinp.AFLOW_MODE_AIMS) {
      message = "This function only works with AIMS.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _RUNTIME_ERROR_);
    }
    xinp.xaims.CONTROL.str(std::string());
    KBIN::AIMS_Produce_CONTROL(xinp.xaims,_AflowIn,FileMESSAGE,_aflowFlags,_kbinFlags,_xFlags.aimsflags);  //DEFAULT
    KBIN::AIMS_Modify_CONTROL(xinp.xaims,FileMESSAGE,_aflowFlags,_kbinFlags,_xFlags.aimsflags);            //DEFAULT

    // Write aflow.in

    //copying from createAFLOWIN
    _vflags vflags(_xFlags.vflags);
    _xaims xaims(xinp.xaims);
    _aimsflags aimsflags(_xFlags.aimsflags);

    string directory=xinp.getDirectory();
    if(directory.empty()){
      message = "No output directory found";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _RUNTIME_ERROR_);
    }

    if(!aurostd::FileExist(directory)){aurostd::DirectoryMake(directory);}  // Create directory if it is not created
    aurostd::DirectoryChmod("777", directory);                              // CHMOD Directory 777

    stringstream outfile;

    // OK, fill it...
    outfile << AFLOWIN_SEPARATION_LINE << std::endl;
    outfile << "[AFLOW] _ ___ _" << std::endl;
    outfile << "[AFLOW] / \\| o \\ |" << std::endl;
    outfile << "[AFLOW] | o | _/ |_" << std::endl;
    outfile << "[AFLOW] |_n_|_| |___| automatic generated file" << std::endl;
    outfile << "[AFLOW]" << std::endl;
    outfile << AFLOWIN_SEPARATION_LINE << std::endl;
    outfile << "[AFLOW_MODE=AIMS]" << std::endl;
    if(!_kbinFlags.KZIP_BIN.empty()){outfile << "[AFLOW_MODE_ZIP=" << _kbinFlags.KZIP_BIN << "]" << std::endl;}  //CO

    //CO20180130 START
    //CO - at some point, fix alien mode for aims, for now omit!
    outfile << AFLOWIN_SEPARATION_LINE << std::endl;
    outfile << "[AIMS_CONTROL_MODE_EXPLICIT]START " << std::endl;
    outfile << xaims.CONTROL.str();
    outfile << "[AIMS_CONTROL_MODE_EXPLICIT]STOP " << std::endl;
    outfile << AFLOWIN_SEPARATION_LINE << std::endl;
    outfile << "[AIMS_GEOM_MODE_EXPLICIT]START " << std::endl;
    outfile << xaims.str;
    outfile << "[AIMS_GEOM_MODE_EXPLICIT]STOP " << std::endl;
    outfile << AFLOWIN_SEPARATION_LINE << std::endl;

    //also write out
    if(1){
      KBIN::AIMS_Write_CONTROL(xaims,aimsflags);
      xaims.GEOM.clear(); xaims.GEOM.str("");
      xaims.GEOM << xaims.str;

      string geom_filename = xaims.Directory + "/" + AFLOWRC_DEFAULT_AIMS_EXTERNAL_GEOM;
      aurostd::stringstream2file(xaims.GEOM, geom_filename);
      if(!aurostd::FileExist(geom_filename)){
        message = "Cannot create [" + AFLOWRC_DEFAULT_AIMS_EXTERNAL_GEOM + "] file.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _FILE_ERROR_);
      }
      aurostd::ChmodFile("a+rw", geom_filename);
    }

    //CO START
    string filename = directory + string("/") + _AFLOWIN_;
    aurostd::stringstream2file(outfile, filename);
    if (!aurostd::FileExist(filename)){
      message = "Cannot create [" + _AFLOWIN_ + "] file.";
      throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _FILE_ERROR_);
    }
    aurostd::ChmodFile("a+rw", filename); // CHMOD a+rw _AFLOWIN_
    //CO END
  }

}  // namespace apl

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                           OUTPUT FILE READERS                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

namespace apl {

  //outfileFoundAnywherePhonons/////////////////////////////////////////////////
  // Checks if output files can be found anywhere. If true, APL will assume that
  // no DFT calculations have run yet --> stagebreak
  bool outfileFoundAnywherePhonons(vector<_xinput>& xinps) {
    for (uint idxRun = 0; idxRun < xinps.size(); idxRun++) {
      string dir = xinps[idxRun].getDirectory();

      if(xinps[idxRun].AFLOW_MODE_VASP) {
        if(aurostd::EFileExist(dir + string("/vasprun.xml.static")) ||
            aurostd::EFileExist(dir + string("/vasprun.xml")) ||
            aurostd::EFileExist(dir + "/" + DEFAULT_AFLOW_QMVASP_OUT)) {  //ME20190607
          return true;
        }
      }
      if(xinps[idxRun].AFLOW_MODE_AIMS) {
        if(aurostd::EFileExist(xinps[idxRun].getDirectory() + string("/aims.out"))) {
          return true;
        }
      }
    }
    return false;
  }

  //filesExistPhonons/////////////////////////////////////////////////////////
  bool filesExistPhonons(_xinput& xinp) {
    string dir = xinp.getDirectory() + string("/");
    if (aurostd::FileExist(dir + _AFLOWIN_)) {
      return true;  //do not OVERWRITE an aflow.in
    }
    if (xinp.AFLOW_MODE_VASP){
      if(aurostd::EFileExist(dir + string("vasprun.xml.static")) ||
          aurostd::EFileExist(dir + string("vasprun.xml")) ||
          aurostd::EFileExist(dir + DEFAULT_AFLOW_QMVASP_OUT)) {  //ME20200203 - Added qmvasp file
        return true;
      }
    }
    if(xinp.AFLOW_MODE_AIMS){
      if(aurostd::EFileExist(dir + string("aims.out"))) {
        return true;
      }
    }
    return false;
  }

  //outfileFoundEverywherePhonons/////////////////////////////////////////////
  // Tests whether the necessary force files are present and complete in all
  // directories for the phonon calculatios. Also reads all forces. If false,
  // APL will assume that at least one DFT broke --> error
  bool outfileFoundEverywherePhonons(vector<_xinput>& xinps, const string& directory, ofstream& FileMESSAGE, ostream& oss, bool contains_born) {
    string mode = xinps[0].xvasp.AVASP_arun_mode;
    stringstream _logger;
    _logger << "Reading force files.";
    pflow::logger(_AFLOW_FILE_NAME_, mode, _logger, directory, FileMESSAGE, oss);
    uint ninps = xinps.size();
    if (contains_born) ninps--;
    for (uint idxRun = 0; idxRun < ninps; idxRun++) {
      _logger << "Reading force file " << (idxRun + 1) << "/" << ninps << "."; //CO20190116  //ME20190607
      pflow::logger(_AFLOW_FILE_NAME_, mode, _logger, xinps[idxRun].getDirectory(), FileMESSAGE, oss);
      string directory = xinps[idxRun].getDirectory();
      if (!readForcesFromDirectory(xinps[idxRun])) {
        _logger << "The force file in " << xinps[idxRun].getDirectory() << " directory is missing.";
        pflow::logger(_AFLOW_FILE_NAME_, mode, _logger, xinps[idxRun].getDirectory(), FileMESSAGE, oss);
        return false;
      }

      // Was it all right?
      if (!xinps[idxRun].getXStr().qm_calculated) {
        string message = "The force file in " + directory + " is wrong.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _FILE_CORRUPT_);
      }
    }
    _logger << "No errors caught, all force files read successfully."; //CO20190116  //ME20190607
    pflow::logger(_AFLOW_FILE_NAME_, mode, _logger, directory, FileMESSAGE, oss, _LOGGER_COMPLETE_);
    return true;
  }

  bool readForcesFromDirectory(_xinput& xinp) {
    uint natoms = xinp.getXStr().atoms.size();
    xinp.getXStr().qm_forces.clear();
    // Load data....
    if(xinp.AFLOW_MODE_VASP) {
      if (!aurostd::EFileExist(xinp.getDirectory() + "/" + DEFAULT_AFLOW_QMVASP_OUT)
          && !aurostd::EFileExist(xinp.getDirectory() + "/vasprun.xml.static")
          && !aurostd::EFileExist(xinp.getDirectory() + "/vasprun.xml")) {
        return false;
      }
      //ME20190607 BEGIN
      // Read forces from aflow qmvasp file - much faster
      string file = xinp.getDirectory() + "/" + DEFAULT_AFLOW_QMVASP_OUT;
      if (aurostd::EFileExist(file)) {
        xQMVASP qmvasp(file);
        xinp.getXStr().qm_forces = qmvasp.vforces;
      } else {
        file = xinp.getDirectory() + string("/vasprun.xml.static");
        if(!aurostd::EFileExist(file)) file = xinp.getDirectory() + string("/vasprun.xml");
        //xVASPRUNXML vasprunxml(file); OBSOLETE ME20190204 - far too slow
        xVASPRUNXML vasprunxml;
        vasprunxml.GetForcesFile(file);
        for (uint i = 0; i < vasprunxml.vforces.size(); i++) xinp.getXStr().qm_forces.push_back(vasprunxml.vforces[i]);
      }
      if (xinp.getXStr().qm_forces.size() == natoms) xinp.getXStr().qm_calculated = true;
      return true;
    } else if (xinp.AFLOW_MODE_AIMS){
      if(!aurostd::EFileExist(xinp.getDirectory() + string("/aims.out"))) {
        return false;
      }
      xAIMSOUT xaimsout(xinp.getDirectory() + "/aims.out");
      for (uint i = 0; i < xaimsout.vforces.size(); i++) xinp.getXStr().qm_forces.push_back(xaimsout.vforces[i]);
      if (xinp.getXStr().qm_forces.size() == natoms) xinp.getXStr().qm_calculated = true;
      return true;
    } else {
      return false;
    }
  }

  //subtractZeroStateForces///////////////////////////////////////////////////
  void subtractZeroStateForces(vector<_xinput>& xinps, bool contains_born) {
    uint ninps = xinps.size() - 1;
    if (contains_born) ninps--;
    uint natoms = xinps[ninps].getXStr().atoms.size();
    for (uint idxRun = 0; idxRun < ninps; idxRun++) {
      if (xinps[idxRun].getXStr().atoms.size() != natoms) {
        string message = "Structure and ZEROSTATE structure do not have the same number of atoms.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INDEX_MISMATCH_);
      }
      for (uint k = 0; k < natoms; k++) {
        xinps[idxRun].getXStr().qm_forces[k](1) = xinps[idxRun].getXStr().qm_forces[k](1) - xinps[ninps].getXStr().qm_forces[k](1);
        xinps[idxRun].getXStr().qm_forces[k](2) = xinps[idxRun].getXStr().qm_forces[k](2) - xinps[ninps].getXStr().qm_forces[k](2);
        xinps[idxRun].getXStr().qm_forces[k](3) = xinps[idxRun].getXStr().qm_forces[k](3) - xinps[ninps].getXStr().qm_forces[k](3);
      }
    }
  }

  //ME20190114
  // Cannot use const reference for zerostate because of getXStr()
  // This is used for AAPL and needs an extra input because the ZEROSTATE
  // calculation is not part of the xInputs vector
  void subtractZeroStateForces(vector<_xinput>& xinps, _xinput& zerostate) {
    string message = "";
    stringstream _logger;
    uint natoms = zerostate.getXStr().atoms.size();
    if (!zerostate.getXStr().qm_calculated) {
      readForcesFromDirectory(zerostate);
      if (!zerostate.getXStr().qm_calculated) {
        message = "The force file in " + zerostate.getDirectory() + " is wrong.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _FILE_CORRUPT_);
      }
    }
    for (uint idxRun = 0; idxRun < xinps.size(); idxRun++) {
      if (xinps[idxRun].getXStr().atoms.size() != natoms) {
        message = "Structure and ZEROSTATE structure do not have the same number of atoms.";
        throw aurostd::xerror(_AFLOW_FILE_NAME_, __AFLOW_FUNC__, message, _INDEX_MISMATCH_);
      }
      for (uint at = 0; at < natoms; at++) {
        xinps[idxRun].getXStr().qm_forces[at](1) = xinps[idxRun].getXStr().qm_forces[at](1) - zerostate.getXStr().qm_forces[at](1);
        xinps[idxRun].getXStr().qm_forces[at](2) = xinps[idxRun].getXStr().qm_forces[at](2) - zerostate.getXStr().qm_forces[at](2);
        xinps[idxRun].getXStr().qm_forces[at](3) = xinps[idxRun].getXStr().qm_forces[at](3) - zerostate.getXStr().qm_forces[at](3);
      }
    }
  }

}  // namespace apl

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                           GET aflow.in NAME                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

namespace apl {

  // Checks for APL aflow.in files for lib2raw. Adapted from AS.
  bool APL_Get_AflowInName(string& AflowInName, const string& directory_LIB)  {
    bool aflowin_found = false;
    vector<string> vaflowins;
    string stmp="";
    if (!AflowInName.empty()) vaflowins.push_back(AflowInName);
    if (!_AFLOWIN_.empty()) vaflowins.push_back(_AFLOWIN_);
    vaflowins.push_back(APL_AFLOWIN_DEFAULT);

    string aflowin_name = "", aflowin = "", fullpath_aflowin_name = "";
    for (uint i=0; i<vaflowins.size(); i++){
      aflowin_name = vaflowins[i];
      fullpath_aflowin_name = directory_LIB + '/' + aflowin_name;
      if(aurostd::EFileExist(fullpath_aflowin_name,stmp)&&aurostd::IsCompressed(stmp)){aurostd::UncompressFile(stmp);}
      if (aurostd::FileExist(fullpath_aflowin_name)){
        aflowin = aurostd::file2string(fullpath_aflowin_name);
        if (aflowin.empty()) continue;
      }

      aflowin = aurostd::RemoveComments(aflowin);
      if (aurostd::substring2bool(aflowin,_ASTROPT_APL_ + "CALC",TRUE) ||
          aurostd::substring2bool(aflowin,_ASTROPT_APL_OLD_ + "CALC",TRUE)){
        AflowInName = aflowin_name;
        aflowin_found = true;
        break;
      }
    }

    return aflowin_found;
  }
}

// ***************************************************************************
// *                                                                         *
// *             STEFANO CURTAROLO - Duke University 2003-2021               *
// *                                                                         *
// ***************************************************************************
